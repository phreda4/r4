#summary :r4 basic words

<<being translated>>

= Introduction =

The only thing the computer does is calculate and move numbers from one memory location to another, all the rest is illusion.

There are many ways to the same thing, but finding a simple way will benefit us in many aspects. To find this form it is important to deeply understand the problem and get rid of ideas that don't help. avoiding to think again about a problem is our issue here, the apparent comfort of not reinventing the wheel disappears when the smallest modification to the initial problem destroys all that's been done.

:r4 and forth use a different mechanism from the current processor architectures.

There are 2 number stacks : one of Data ( D stack) and the other of adresses ( R stack). They are available when the program is executing.

The Data Stack is used as a short term memory ( what is known as local variables in other languages) and to transmit values between words ( which is known as parameter passing).

The Return Stack stores return addresses as each word is executed. This stack reflects the execution flow and can be modified to alter the flow. It can also be used as an auxiliary data stack provided everything that is added is adequately removed.

The dictionary is an array that contains the definitions of each word. It starts by including the basic words comprised by the system. The code we program will consist in a list of definitions and at then the list of words that will be executed when the program starts, this list starts with a colon and a space.

The stacks only manipulate signed 32 bits integers, furthermore there are no data types. Data types ( such as the holy 'objects') are replaced by a powerful, simple and versatile concept :  ... the *word*

To program in :R4 we will define words as DATA ( with a # as precfix) or words as ACTIONS ( with a : prefix)

These WORDS defined as DATA or ACTIONs in the dictionary will define the algorithm in :r4.

= How it works =

The words are separated by spaces, it is the only syntactic rule.

The code is read word by word

When the word is a number:
|| Decimal || 2 || 
|| hexa || $3f ||  
|| binary || %110001 || 
|| fixed point || 0.23 || 

the language pushes the number on the Data Stack

If the current word is not a number then its definition is searched in the dictionary and executed.

If the dictionary does not comprise the word, then it is an error

The first word in the dictionary is END ";" semi-colon

It is used to end the definition of an ACTION :

:stacker 1 2 3 4 5 ;

here the stacker word is defined, it pushes 5 numbers onto the stack
";" defines the end of the word

The following 3 words comprise lists of words that are used by control structures : "(", ")(" and ")"

One should always remember about putting spaces between words

The following two words are used to build a list of words that is used only through its address given that it doesn't have a name. They're called lambda functions in lisp languages, but I prefer anonymous, [ y ]

Recordar otra vez los espacios y aqui deberia terminar con ; ya que sino la ejecucion seguiria por quien la definio.

Anonymous definition.
{{{
[
]
}}}
Defines an anonymous word, it has no name but its adress is pushed on the stack.

_Cuidado_
debe tener un fin de palabra ";" para que termine correctamente la ejecucion de la palabra anonima, el compilador actual no emite error y es valido poner por ejemplo
{{{ 
[ 1 ] 
}}}
sindo lo correcto poner 
{{{
[ 1 ; ]
}}}


Luego estan los condicionales, en dos formas, simples o doble, los simples son 4 preguntas

|| Es cero ? || 0? ||
|| No es cero ? || 1? ||
|| Es positivo ? 0 tambien || +? ||
|| Es negativo ? || -? ||

comprueba el Tope de la pila de datos (TOS) y ejecutan un bloque o no

Las 5 estructuras de control que tiene el lenguajes (REPEAT,IF,IF-ELSE,WHILE y UNTIL) se definen ubicando los condicionales en los diferentes lugares de los bloques.
IF 
{{{
0? ( ; ) | si el tope de la pila es 0 termina la palabra
| el tope segira siendo 0
}}}
IF-ELSE
{{{
-? ( neg )( ; ) | si es negativo lo niega sino termina
}}}
WHILE
{{{
5         | apilo 5
( 1? )(   | mientras no sea 0 (cero)
    1-    | resto uno
    )     | cuando es cero termina el bucle.
}}}
UNTIL
{{{
8         | apilo 8
( 1-      | resto 1
    -? )  | hasta que sea negativo el tope de la pila repito el bloque anterior
}}}

la 5 estructura de control se construye sin condicional
REPEAT
{{{
( 1 2 )	  | apila 1 luego 2 y repite
}}}


Comprueban el tope de la pila pero no la consumen.

como IF
0? ( ; ) 
si el tope de la pila es 0 termina la palabra y el tope segira siendo 0

como WHILE
5 ( 1? )( 1- )   
apilo 5
mientras no sea 0 (cero)
  resto uno
cuando es cero termina el bucle.

como UNTIL
8 ( 1- -? )
apilo 8
resto 1
hasta que sea negativo el tope de la pila repito el bloque anterior

Double conditionals
{{{
=?	| a b -- a		a = b ?
<?	| a b -- a		a < b ?
>?	| a b -- a		a > b ?
<=?	| a b -- a		a <= b ?
>=?	| a b -- a		a >= b ?
<>?	| a b -- a		a <> b ?
AND?	| a b -- a		a and b ?
NAND?	| a b -- a		a nand b ?
}}}

They compare the top of the stack with the second element, they remove the top of the stack value.

eg:
{{{
1 =? ( neg )  
0 ( 10 <? )( 1+ ) drop
}}}

Here it is useful to draw the state of the data stack before and after execution of the said word.

B=2
A=3   -->   C=5

THe dictionary starts with less than 250 words,

Ejecuta palabra por direccion.
{{{
EXEC  	| vector --  	
}}}
Lama al codigo del vector, si es 0 lo consume de la pila y no ejecuta nada.

Se puede definir como
{{{
:EXEC
    0? ( drop ; ) >r ;
}}}

Pila de Datos
{{{
DUP 	| a -- a a
DROP 	| a --
OVER 	| a b -- a b a
PICK2 	| a b c -- a b c a
PICK3 	| a b c d -- a b c d a
PICK4 	| a b c d e -- a b c d e a
SWAP 	| a b -- b a
NIP	| a b -- b
ROT 	| a b c -- b c a
2DUP 	| a b -- a b a b
2DROP   | a b --
3DROP   | a b c --
4DROP   | a b c d --
2OVER	| a b c d -- a b c d a b
2SWAP	| a b c d -- c d a b
}}}

Es un espacio de 2Kb de numeros entero con signo.
Palabras que acomodan parametros que se pasan en la pila.
Si para conectar dos palabras, aparecen juntas, muchas de estas, revisar la posicion de los parametros elegidos

Pila de Direcciones (pila R)
{{{
>R 	| a --      R: -- a
R> 	| -- a	    R: a --
R	| -- a      R: a -- a
R+	| v --	    R: a -- a+v
R@+	| -- v      R: a -- a+4
R!+	| v --	    R: a -- a+4
RDROP	| --	    R: a --
}}}

Es otro espacio de 2kb de direcciones (32 bits), tambien usada como pila auxiliar.
Tener en cuenta que desequilibra la pila utilizarlas.

Logic operations
{{{
AND 	| a b -- c     c = a AND b
OR 	| a b -- c     c = a OR b
XOR 	| a b -- c     c = a XOR b
NOT  	| a -- b       c = NOT b
}}}

Those ones, Boole and friends.

Arithmetic operations
{{{
+ 	| a b -- c	c=a+b
- 	| a b -- c	c=a-b
* 	| a b -- c	c=a*b
/ 	| a b -- c	c=a/b
*/ 	| a b c -- d	d=a*b/c	      resultado intermedio en 64 bits
*>>	| a b c -- d	d=(a*b)>>c    resultado intermedio en 64 bits
/MOD 	| a b -- c d	c=a/b  d=a resto b
MOD 	| a b -- c	c=a resto b
ABS	| a -- b	b=|a|
NEG 	| a -- b	b=-a
1+ 	| a -- b	b=a+1
4+	| a -- b	b=a+4
1- 	| a -- b	b=a-1
2/ 	| a -- b	b=a/2
2* 	| a -- b	b=a*2
<< 	| a b -- c	c=a<<b
>> 	| a b -- c	b=a>>b (arrastra signo)
}}}

Only signed 32 bit integer numbers are provided.
Several words are present for speed reasons.
The always present words are addition and bits shifting (+,>>,<<).

Direct memory access
{{{
@ 	| a -- b		b=32(a)
C@ 	| a -- b		b=8 (a)
W@	| a -- b		b=16(a)
!	| v d --		32(d) = v
C!	| v d --		8(d) = v
W! 	| v d --		16(d) = v
+! 	| v d --		32(d)=32(d)+v
C+!	| v d --		8(d)=8(d)+v
W+!  	| v d --		16(d)=16(d)+v
@+	| d -- d+4	dword
!+	| v d -- d+4
C@+	| d -- d+1	byte
C!+	| v d -- d+1
W@+	| d -- d+2	word
W!+	| v d -- d+2
}}}

Direct memory access is the most transparent way of using memory, the apparent fragility of this type of memory access is linked to the paranoia that consists in believing that the computer contains programs that attack each other ( more about this in "Thinking Forth" in the chapter where "Information Hiding" is mentionned).
In any case, imposing limits to accessing a part of the computer is not a good feature to have for a language that's used to program it.

Memory moves
{{{
MOVE	| de sr cnt --		Copies CNT dword from SR to DE
MOVE>   | de sr cnt --		Copies CNT dword from SR to DE (backwards)
CMOVE   | de sr cnt --		Copies CNT bytes from SR to DE
CMOVE>  | de sr cnt --		Copies CNT bytes from SR to DE (backwards)
MEM	| -- dir 		Free memory start address
}}}

In the VM, the running program has the following form :

|| CODE || 256KB ||
|| DATA + FREE MEMORY || 16MB ||

MEM is a pointer on the first free position in memory.
The memory chuncks MOVES are used for speed.

Files
{{{
DIR	| "foldername" –	Changes current directory
FILE	| n -- "filename"	Name of file  n
FSIZE	| n -- cnt		File size
VOL	| n -- "foldername"	Name of directory n
LOAD	| d "filename" -- e	Loads a file into memory
SAVE	| d n "filename" –	Write memory chunck into a file
}}}

Deleteing a file is done by writing 0 bytes in itself (not implemented for security reasons :)

Events
{{{
UPDATE	| --	Updates IRQs such as mouse, keyboard, sound, etc ...
END 	| --	Exit from :r4, closes everything, shuts down the VM
}}}

It is possible that UPDATE, END will disappear one day, they are almost never used..

System
{{{
MSEC 	| -- a 		system milliseconds
TIME 	| -- h m s 	hour, minute, second
DATE 	| -- d m a	dayn month, year
}}}

Time, what would we do without it ?

{{{
RUN  	| "main.txt" --	Loads, compiles and executes the file
}}}

In the current VM : loads, compiles and executes the 'main.txt' named file.

Graphics screen
{{{
SW 	| -- w		Screen width
SH 	| -- h		Screen height
CLS	| --		Clears screen
REDRAW  | --		Draws new FRAME
FRAMEV	| -- m		Address of video memory start
}}}

Pixel drawing
{{{
SETXY	| x y --    	puts graphics cursor on x,y
PX+!	| cant --   	adds cant to the graphics cursor
PX!+	| color --	draws with color and moves to the following pixel
PX@	| -- color	returns color of pixel under the graphics cursor
}}}

Drawing lines and polygons
{{{
PAPER	| a –-		Sets background color
INK	| a --		Sets drawing color
INK@	| -- a		Gets drawing color
ALPHA 	| a --		Sets alpha transparency
OP 	| x y –-	Origin point
CP 	| x y –-	Curve point
LINE 	| x y –-	Draws a line
CURVE 	| x y –-	Draws a curve
PLINE 	| x y --	Draws a polygon line
PCURVE 	| x y --	Draws a polygon curve
POLI	| --		Draws a polygon
FCOL	| c1 c2 --	sets 2 colors for a gradient
FCEN	| x y --	Gradient center
FMAT	| a b --	Gradient matrix
SFILL	| --		Solid filled polygon
LFILL	| --		Linear gradient filled polygon
RFILL	| --		Radial gradient filled polygon (or something close..)
}}}

These words are in the base dictionary for speed, there are versions of these words in the distribution also, there are used for ASM compilation.

Mouse
{{{
IPEN!	| v --  	Mouse IRQ vector ( or pen)
XYMOUSE | -- x y 	mouse coordinates
BMOUSE	| -- b		mouse buttons state
}}}

Keyboard
{{{
IKEY!	| v --    	Keyboard IRQ vector
KEY	| -- s		Last pressed key (scancode)
}}}

Joystick
{{{
CNTJOY	| -- cnt	number of joysticks detected
GETJOY	| j -- a	data for joystick j
}}}

The address returned by GETJOY points on the current number j joystick state.

The current structure makes it WINE compatible.
A mi, me da asi. 

|| number DWORD || Value || Meaning ||
|| 0 || $3f || ?? ||
|| 1|| $ff || ?? ||
|| 2 || $7fff || PAD 0 ||
|| 3 || $7fff || PAD 1 ||
|| 4 || $7fff || PAD 2 ||
|| 5 || $7fff || PAD 3 ||
|| 6 || 0 || ?? ||
|| 7 || 0 || ?? ||
|| 8 || 0 || BUTTONS ||
|| 9 || 0 || ANYBUTTON ||

have a look at test-joy.txt to see how to read it