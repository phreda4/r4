| Cell analisis
| PHREDA 2017
|-------------------------
^r4/compiler/r4-tokenprint.txt

#tokenini | inicion de tokens
#itok 0
#ncell 0 | cant

| Info de celdas
| RR WW FFFF
| R cnt de lecturas
| W cnt de escrituras
| flags........
|  $1 in W		| word
|  $2 out W
|  $4 in C		| call
|  $8 out C
| $10 var
| $20 dir var
| $40 dir code
| $80 copia de A en cellt
| $100 celda exec
#cells )( 1024
#cellt )( 1024 | token de origen o celda
| ff iii fff
#cellv )( 1024 | vida de celda

|--- PILA DATO
#dpila )( 1024
#dpila> 'dpila

|--- PILA RETORNO
#rpila )( 512
#rpila> 'rpila

|--- celdas de salida
#regout )( 256

|---------------
:newcell
	ncell
	0 over 2 << 'cells + !
	0 over 2 << 'cellt + !
	itok over 2 << 'cellv + ! | inicio de vida
	dup 1+ 'ncell !
	;
:endlive
	itok 10 << swap 2 << 'cellv + +!  ;

:d.pop		-4 'dpila> +! dpila> @ ;
:d.push		dpila> !+ 'dpila> ! ;
::d.TOS		dpila> 4 - @ ;
::d.NOS 	dpila> 8 - @ ;
::d.PK2 	dpila> 12 - @ ;
::d.PK3 	dpila> 16 - @ ;
::d.PK4 	dpila> 20 - @ ;

::d.drop	d.pop endlive ; | fin de vida
::d.swap	dpila> 8 - >r r@+ r@+ r> 8 - !+ ! ;
::d.rot		dpila> 12 - >r r@+ r@+ r@+ swap r> 12 - !+ !+ ! ;
::d.2swap	dpila> 16 - >r r@+ r@+ swap r@+ r@+ swap r> 16 - !+ !+ !+ ! ;

::r.pop		-4 'rpila> +! rpila> @ d.push ;
::r.push	d.pop rpila> !+ 'rpila> ! ;
::r.tos		rpila> 4 - @ ;
::r.drop	-4 'rpila> +! rpila> @ endlive ;

:tosinW		d.TOS 2 << 'cells + dup @ $1 or swap ! ;
:tosoutW    d.TOS 2 << 'cells + dup @ $2 or swap ! ;
:tosinC     d.TOS 2 << 'cells + dup @ $4 or swap ! ;
:tosoutC    d.TOS 2 << 'cells + dup @ $8 or swap ! ;
:tosVar     d.TOS 2 << 'cells + dup @ $10 or swap ! ;
:tosAV      d.TOS 2 << 'cells + dup @ $20 or swap ! ;
:tosAW      d.TOS 2 << 'cells + dup @ $40 or swap ! ;
:tosExe 	d.TOS 2 << 'cells + dup @ $100 or swap ! ;

:tosCPY | nro --
			d.TOS 2 << dup >r 'cellt + !
			r> 'cells + dup @ $80 or swap ! ;

:tos+1r		d.TOS
:+1r 		2 << 'cells + $1000000 swap +! ;
:tos+1w     d.TOS
:+1w 		2 << 'cells + $10000 swap +! ;

:tosTok		dup 4 - d.TOS 2 << 'cellt + ! ;

#lastdircode 0 | ultima direccion de codigo

:tosCode
	dup 4 - @ 8 >> 'lastdircode ! ;


:litn | --
	newcell d.push tosTok ;
:lits | --
	newcell d.push tosTok ;
:litv | --
	newcell d.push tosVar tosTok tosCode ;
:litAW	| -- ;dw dir word
	newcell d.push tosAW tosTok tosCode ;
:litAV	| -- ;dv dir var
	newcell d.push tosAV tosTok tosCode ;

:callW
	dup 4 - @ 8 >>
	dup dic>DATAU
	dup ( 1? )( 1- tosoutC d.drop ) drop
	swap dic>DATAD +
	( 1? )( 1- newcell d.push tosinC ) drop
	;

:exexec
	tosExe
    tos+1r d.drop
	lastdircode
	dup dic>DATAU
	dup ( 1? )( 1- tosoutC d.drop ) drop
	swap dic>DATAD +
	( 1? )( 1- newcell d.push tosinC ) drop
	;

|------ bloques de codigo
#nblock 0

| $1 ?( | $2 ?)( | $2 )( | $4 ?)
| 0 ( )		REP
| 1 ?( )	IF
| 2 ( ?)( ) WHI
| 3 ?( )( )	IFE
| 4 ( ?)	UNT
#blocki )( 1024	| tipo+info
#blocks )( 1024 | inicio-medio-fin

|----- pila para bloques
#pilab )( 256	#pilab> 'pilab

:bl.new
	nblock
	0 over 2 << 'blocks + !
	pilab> !+ 'pilab> !
	1 'nblock +! ;
:bl.end
	-4 'pilab> +! ;
:bl.now
	pilab> |'pilab =? ( drop 0 ; )
	4 - @ ; | -- nblo

:bl.cond? | -- 0/cond
	dup 8 - @ $ff and
	23 <? ( drop 0 ; )
	34 >? ( drop 0 ; )
	drop 1 ;

|---- bloques
:exestack
	rpila> 'rpila =? ( drop ; )
	4 - @
	2 << 'cells + dup @ $100 or swap !
	;

:w;		| ; | fin de palabra
	exestack
	dpila> 'dpila - 2 >>
	( 1? )( tosoutW d.drop 1- ) drop
	pilab> 'pilab =? ( drop ; ) drop
	8 bl.now 2 << 'blocki + +!
	;

|------------------------------------
#stki )( $fff		| stack of tokens
#memstk )( $ffff	| stack memory
#memstk> 'memstk

:stack!
	memstk>
	dup itok 2 << 'stki + !
	dpila> 'dpila - 2 >> swap c!+
	'dpila ( dpila> <? )( @+ rot c!+ swap ) drop
	rpila> 'rpila - 2 >> swap c!+
	'rpila ( rpila> <? )( @+ rot c!+ swap ) drop
	'memstk> ! ;

:stack@ | itok --
	2 << 'stki + @
	'dpila >r
	c@+ ( 1? )( 1- swap c@+ r!+ swap ) drop
	r> 'dpila> !
	'rpila >r
	c@+ ( 1? )( 1- swap c@+ r!+ swap ) 2drop
	r> 'rpila> ! ;

|----------------------------
:w(
	bl.new
	bl.now 2 << >r
	itok r 'blocks + !
	bl.cond? r> 'blocki + !
	;

:w)(
	bl.now 2 << >r
	itok 10 << r 'blocks + +!
	bl.cond? 0? ( r 'blocks + @ $3ff and stack@ ) drop	| ELSE copia pila de IF
	$2 r> 'blocki + +!
	;

:w)
	bl.now 2 << >r
	itok 20 << r 'blocks + +!
	bl.cond? 2 << r 'blocki + +!
	r> 'blocki + @ $7 and
	2 =? ( bl.now 2 << 'blocks + @ 10 >> $3ff and stack@ )	| WHILE
	1 =? ( bl.now 2 << 'blocks + @ $3ff and stack@ )	| IF
	drop
	bl.end ;

|---- condicionales
:c0	tos+1r ;
:c1 tos+1r d.drop tos+1r ;

|---- pila

:d.dup		d.tos dup +1r newcell d.push tosCpy ;
:d.over		d.NOS dup +1r newcell d.push tosCpy ;
:d.pick2	d.PK2 dup +1r newcell d.push tosCpy ;
:d.pick3	d.PK3 dup +1r newcell d.push tosCpy ;
:d.pick4	d.PK4 dup +1r newcell d.push tosCpy ;
:d.2dup		d.over d.over ;
:d.2over	d.pick3 d.pick3 ;
:d.nip		d.swap d.drop ;
:d.4DROP	d.drop
:d.3DROP	d.drop
:d.2DROP	d.drop d.drop ;

:r.r		r.tos +1r newcell d.push r.tos tosCpy ;
:r.r+		r.tos +1w d.drop ;			| R+    a --  R: b -- c
:r.r@+		r.tos +1w newcell d.push ;	| R@+    -- a R: b -- c
:r.r!+		r.tos +1w d.drop ;			| R!+   a --  R: b -- c

:op1a1		tos+1w ; | neg not 1+ 4+ 1- 2/ ..
:vop1a1 	tos+1w ; | abs  clz  ..
:op2a1		tos+1r d.drop tos+1w ; | + - * and or xor ..
:vop2a1 	tos+1r d.drop tos+1w ; | / mod
:xop2a1		tos+1r d.drop tos+1w ; | << >>
:op3a1		tos+1r d.drop tos+1r d.drop tos+1w ; | */
:vop3a1		tos+1r d.drop tos+1r d.drop tos+1w ; | *>> /<<
:op2a2		tos+1w d.swap tos+1w d.swap ; | mod/

| @ c@ w@
:1@		tosVar tos+1w ;
| ! c! w!
:1!		tosVar tos+1r d.drop tos+1r d.drop ;
| @+ c@+ w@+
:2@		tosVar tos+1w newcell d.push tos+1w ;
| !+ c!+ w!+
:2!		d.swap tos+1r d.swap tosVar tos+1w d.nip ;
| +! c+! w+!
:2+!	tosVar tos+1r d.drop tos+1r d.drop ;

:vuso6	tos+1r d.drop tos+1r d.drop
:vuso4	tos+1r d.drop
:vuso3	tos+1r d.drop
:vuso2	tos+1r d.drop
:vuso1	tos+1r d.drop ;
:vuso11	tos+1r ;
:vuso21	tos+1r d.drop tos+1r ;

:v1cte	newcell d.push tosoutC ;
:v3v	newcell d.push tosoutC
:v2v	newcell d.push tosoutC
:v1v	newcell d.push tosoutC ;

|------------------------
#cellexec
0		|0
0		|1 :  | --  define codigo
0		|2 :: | --  define codigo
0		|3 #  | --  define variable
0		|4 #: | --  define variable
0		|5 |  | -- comentario
0		|6 ^  | -- include
litN
litN
litN
litN	| -- n numero
litS	| -- s string
callW	| ..--..  word <---- debe ser calculado
litV	| -- v var
litAW	| -- dw dir word
litAV	| -- dv dir var

w;		| ; | fin de palabra
w(
w)(
w)
0 0						| [ ]
exexec					|EXEC  x/0 --    TOS es dcod
c0 c0 c0 c0				| 0?	a -- a
c1 c1 c1 c1 c1 c1 c1 c1	| =?	ab -- a
d.dup
d.drop
d.over
d.pick2
d.pick3
d.pick4
d.swap
d.nip
d.rot
d.2dup
d.2drop
d.3drop
d.4drop
d.2over
d.2swap

r.push	|>R		a -- R: -- a
r.pop	|R>		-- a R: a --
r.r		|R		-- a R: a -- a
r.r+	|R+		a -- R: b -- c
r.r@+	|R@+	-- a R: b -- c
r.r!+	|R!+	a -- R: b -- c
r.drop	|RDROP	R: a --

op2a1	|AND	ab -- c
op2a1	|OR		ab -- c
op2a1	|XOR	ab -- c
op1a1	|NOT	a -- b
op2a1	|+		ab -- c
op2a1	|-		ab -- c
op2a1	|*		ab -- c
vop2a1	|/		ab -- c
op3a1	|*/		abc -- d
vop3a1	|*>>	abc -- d
op2a2	|/MOD	ab -- cd
vop2a1	|MOD	ab -- c
vop1a1	|ABS	a -- b
op1a1	|SQRT	a -- b
vop1a1	|CLZ	a -- b
vop3a1	|<</	abc -- d
op1a1	|NEG	a -- b
op1a1	|1+		a -- b
op1a1	|4+		a -- b
op1a1	|1-		a -- b
op1a1	|2/		a -- b
op1a1	|2*		a -- b
xop2a1	|<<		ab -- c
xop2a1	|>>		ab -- c

1@	|@      a -- b     tos es ddat
1@	|C@     a -- b		tos es ddat
1@	|W@     a -- b      tos es ddat
1!	|!     ab --        tos es ddat
1!	|C!    ab --        tos es ddat
1!	|W!    ab --        tos es ddat
2+!	|+!    ab --        tos es ddat
2+!	|C+!   ab --        tos es ddat
2+!	|W+!   ab --        tos es ddat
2@	|@+     a -- bc     tos es ddat
2!	|!+    ab -- c      tos es ddat
2@	|C@+    a -- bc     tos es ddat
2!	|C!+   ab -- c      tos es ddat
2@	|W@+    a -- bc     tos es ddat
2!	|W!+   ab -- c      tos es ddat

vuso3	|MOVE  abc --       a,b es ddat
vuso3	|MOVE> abc --		a,b es ddat
vuso3	|CMOVE abc --		a,b es ddat
vuso3	|CMOVE> abc --		a,b es ddat
v1cte	|MEM	-- a		a es ddat

vuso11	|FFIRST    a -- b
v1v		|FNEXT  -- a
vuso21	|LOAD   ab -- c
vuso3	|SAVE   abc --
vuso3	|APPEND   abc --

vuso11	|UPDATE  a -- a
v2v		|XYMOUSE -- ab
v1v		|BMOUSE  -- a
vuso1	|IKEY!  a --
v1v		|KEY     -- a

v1v		|CNTJOY  -- a
v1v		|GETJOY  -- a

v1v	|MSEC    -- a
v3v	|TIME    -- abc
v3v	|DATE    -- abc
0	|END     --
vuso1	|RUN    a --
v1cte	|SW      -- a
v1cte	|SH      -- a
0	|CLS     --
0	|REDRAW  --
v1v	|FRAMEV  -- a
vuso2	|SETXY  ab --
vuso1	|PX+!   a --
vuso1	|PX!+   a --
v1v	|PX@     -- a
v1cte	|XFB     -- a
0	|>XFB    --
0	|XFB>    --
vuso1	|PAPER  a --
vuso1	|INK    a --
v1v		|INK@    -- a
vuso1	|ALPHA  a --
vuso2	|OP     ab --
vuso2	|LINE   ab --
vuso4	|CURVE  abcd --
vuso6	|CURVE3  abcdef --
vuso2	|PLINE  ab --
vuso4	|PCURVE abcd --
vuso6	|PCURVE3 abcdef --
0		|POLI    --
vuso2	|FCOL   ab --
vuso2	|FCEN   ab --
vuso2	|FMAT   ab --
0 0 0	|SFILL LFILL RFILL  --
vuso1	|TFILL  a --
vuso11	|SLOAD   a -- a
vuso1	|SPLAY  a --
vuso11	|SINFO   a -- a
vuso4	|SSET  a --
|---- falta
0	|OPENURL
0	|DOCINI
0	|DOCEND
0	|DOCAT
0	|DOCLINE
0	|DOCTEXT
0	|DOCFONT
0	|DOCBIT
0	|DOCRES
0	|DOCSIZE
0	|SYSTEM

:,stack
	'dpila
	( dpila> <? )( @+ "%d " ,print ) drop
	'rpila rpila> <>? ( " : " ,s )
	( rpila> <? )( @+ "%d " ,print ) drop
	;

|------------------------------------------
:init | word -- word
	0 'itok !
	0 'ncell !
	'dpila 'dpila> !
	'rpila 'rpila> !
	0 'nblock !
	'pilab 'pilab> !
	'memstk 'memstk> !
	dup dic>tok @ 'tokenini !
	dup dic>DATAU | usados
	( 1? )( 1-
		newcell d.push tosinW tos+1w
		) drop ;

:cadatoken
	$ff and 2 << 'cellexec + @
	0? ( drop ; )
	exec ;

::cellana | word --
	init
	dup dic>tok @ swap dic>len@
	( 1? )( 1-
		stack!
		swap @+
		"; " ,s dup tokenstr ,print
		cadatoken
		9 ,c "; ",s ,stack ,cr

|	"r4/compiler/code.asm" savemem | DEBUG

		swap
		1 'itok +!
		) 2drop ;

|.......
#regused> 1

:inireg
	1 'regused> ! ;

:addreg | cell --
	$ff and dup
	2 << 'cells + @ 16 >> $ff and
	0? ( 2drop  ; ) drop 	| cte!
	2 << 'cellv + dup
	@ 24 >> $ff and
	1? ( 2drop ; ) drop		| ya tiene reg!
	regused> 24 << swap +!
	1 'regused> +!
	;

:calcreg | pila --
	c@+
	( 1? )( 1- swap c@+ addreg swap ) drop
	c@+ 0? ( 2drop ; )
	abs | es -1 en show!!
	( 1? )( 1- swap c@+ addreg swap )
	2drop ;

::cell2reg | --
	inireg
    'stki >r
	0 ( itok <? )(
		r@+ calcreg
		1+ ) drop
	rdrop
	;

|------------------------ info
| flags........
|  $1 in W		| word
|  $2 out W
|  $4 in C		| call
|  $8 out C
| $10 var
| $20 dir var
| $40 dir code
| $80 copia de A
:cflags
	$1 and? ( " INW" ,s )
	$2 and? ( " OUTW" ,s )
	$4 and? ( " INC" ,s )
	$8 and? ( " OUTC" ,s )
	$10 and? ( " VAR" ,s )
	$20 and? ( " 'DATA" ,s )
	$40 and? ( " 'CODE" ,s )
	$80 and? ( " CPY" ,s )
	$100 and? ( " EXE" ,s )
	drop ;

:cconst
	" CTE" ,s
	" R:" ,s dup 24 >> $ff and ,d
	cflags
	over 2 << 'cellt + @
	0? ( drop ; )
	256 <? ( ,sp ,d ; )
	@ tokenstrA ,sp ,print
	;


:celli | nro --
	dup 16 >> $ff and
	0? ( drop cconst ; ) drop
	" R:" ,s dup 24 >> $ff and ,d
	" W:" ,s dup 16 >> $ff and ,d
	cflags
	;

:cellvida | nro
	2 << 'cellv + @
	dup 10 >> $3ff and over $3ff and
	" (%d:%d)" ,print
	24 >> $ff and " %d" ,print
	;

::cellinfo
	'cells 0
	( ncell <? )( swap
		over ,d
		@+ celli
		over cellvida
		,cr
		swap 1+ ) 2drop ;

#bloq "REP" "IF " "WHI" "IFE" "UNT"

:blinfo | nro --
	2 <<
	dup 'blocki + @
	$8 and? ( ";" ,s )
	$7 and 2 << 'bloq + ,s
	dup 'blocks + @
	dup $3ff and " (%d" ,print
	dup 10 >> $3ff and 0? ( drop ":" ,s )( ":%d:" ,print )
	20 >> $3ff and "%d)" ,print
	drop
	;

::blockinfo
	nblock 0? ( drop ; ) drop
	"block----" ,s ,cr
	0 ( nblock <? )(
    	dup blinfo
    	,cr
    	1+ ) drop ;

|-------------------------
:,stackm | itok --
	2 << 'stki + @
	c@+
	( 1? )( 1- swap c@+ ,sp ,d swap ) drop
	c@+ 0? ( 2drop ; )
	" r:" ,s abs | es -1 en show!!
	( 1? )( 1- swap c@+ ,sp ,d swap ) 2drop ;

::tokeninfo
	0 ( itok <? )(
		dup ,stackm
		,cr
		1+ ) drop ;