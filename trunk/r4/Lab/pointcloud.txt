^r4/lib/gui.txt


#3dcubedata
	| [[0, 4, 6, 2], [-1, 0, 0]]
    | [[1, 3, 7, 5], [+1, 0, 0]],
    | [[0, 1, 5, 4], [0, -1, 0]],
    | [[2, 6, 7, 3], [0, +1, 0]],
    | [[0, 2, 3, 1], [0, 0, -1]],
    | [[4, 5, 7, 6], [0, 0, +1]]

::3dcube | rx ry rz -- adr
	here
	| center 0 0 0
|	6 ( 1? )( 1-

	| 6
	| [[0, 4, 6, 2], [-1, 0, 0]]
    | [[1, 3, 7, 5], [+1, 0, 0]],
    | [[0, 1, 5, 4], [0, -1, 0]],
    | [[2, 6, 7, 3], [0, +1, 0]],
    | [[0, 2, 3, 1], [0, 0, -1]],
    | [[4, 5, 7, 6], [0, 0, +1]]

|  options = options || {};
|  var c = new CSG.Vector(options.center || [0, 0, 0]);
|  var r = !options.radius ? [1, 1, 1] : options.radius.length ?
|           options.radius : [options.radius, options.radius, options.radius];
|  return CSG.fromPolygons([
|  ].map(function(info) {
|    return new CSG.Polygon(info[0].map(function(i) {
|      var pos = new CSG.Vector(
|        c.x + r[0] * (2 * !!(i & 1) - 1),
|        c.y + r[1] * (2 * !!(i & 2) - 1),
|        c.z + r[2] * (2 * !!(i & 4) - 1)
|      );
|      return new CSG.Vertex(pos, new CSG.Vector(info[1]));
|    }));
|  }));
|};

| Construct a solid sphere. Optional parameters are `center`, `radius`,
| `slices`, and `stacks`, which default to `[0, 0, 0]`, `1`, `16`, and `8`.
| The `slices` and `stacks` parameters control the tessellation along the
| longitude and latitude directions.
|
| Example usage:
|
|     var sphere = CSG.sphere({
|       center: [0, 0, 0],
|       radius: 1,
|       slices: 16,
|       stacks: 8
|     });
|CSG.sphere = function(options) {
|  options = options || {};
|  var c = new CSG.Vector(options.center || [0, 0, 0]);
|  var r = options.radius || 1;
|  var slices = options.slices || 16;
|  var stacks = options.stacks || 8;
|  var polygons = [], vertices;
|  function vertex(theta, phi) {
|    theta *= Math.PI * 2;
|    phi *= Math.PI;
|    var dir = new CSG.Vector(
|      Math.cos(theta) * Math.sin(phi),
|      Math.cos(phi),
|      Math.sin(theta) * Math.sin(phi)
|    );
|    vertices.push(new CSG.Vertex(c.plus(dir.times(r)), dir));
|  }
|  for (var i = 0; i < slices; i++) {
|    for (var j = 0; j < stacks; j++) {
|      vertices = [];
|      vertex(i / slices, j / stacks);
|      if (j > 0) vertex((i + 1) / slices, j / stacks);
|      if (j < stacks - 1) vertex((i + 1) / slices, (j + 1) / stacks);
|      vertex(i / slices, (j + 1) / stacks);
|      polygons.push(new CSG.Polygon(vertices));
|    }
|  }
|  return CSG.fromPolygons(polygons);
|};

| Construct a solid cylinder. Optional parameters are `start`, `end`,
| `radius`, and `slices`, which default to `[0, -1, 0]`, `[0, 1, 0]`, `1`, and
| `16`. The `slices` parameter controls the tessellation.
|
| Example usage:
|
|     var cylinder = CSG.cylinder({
|       start: [0, -1, 0],
|       end: [0, 1, 0],
|       radius: 1,
|       slices: 16
|     });
|CSG.cylinder = function(options) {
|  options = options || {};
|  var s = new CSG.Vector(options.start || [0, -1, 0]);
|  var e = new CSG.Vector(options.end || [0, 1, 0]);
|  var ray = e.minus(s);
|  var r = options.radius || 1;
|  var slices = options.slices || 16;
||  var axisZ = ray.unit(), isY = (Math.abs(axisZ.y) > 0.5);
|  var axisX = new CSG.Vector(isY, !isY, 0).cross(axisZ).unit();
|  var axisY = axisX.cross(axisZ).unit();
|  var start = new CSG.Vertex(s, axisZ.negated());
|  var end = new CSG.Vertex(e, axisZ.unit());
|  var polygons = [];
|  function point(stack, slice, normalBlend) {
|    var angle = slice * Math.PI * 2;
|    var out = axisX.times(Math.cos(angle)).plus(axisY.times(Math.sin(angle)));
|    var pos = s.plus(ray.times(stack)).plus(out.times(r));
|    var normal = out.times(1 - Math.abs(normalBlend)).plus(axisZ.times(normalBlend));
|    return new CSG.Vertex(pos, normal);
|  }
|  for (var i = 0; i < slices; i++) {
|    var t0 = i / slices, t1 = (i + 1) / slices;
|    polygons.push(new CSG.Polygon([start, point(0, t0, -1), point(0, t1, -1)]));
|    polygons.push(new CSG.Polygon([point(0, t1, 0), point(0, t0, 0), point(1, t0, 0), point(1, t1, 0)]));
|    polygons.push(new CSG.Polygon([end, point(1, t1, 1), point(1, t0, 1)]));
|  }
|  return CSG.fromPolygons(polygons);
|};
|----------------



#xmin #ymin #xmax #ymax
#xsum #ysum
#xcam 0 #ycam 0 #zcam -10.0
#xr 0.20 #yr 0.25

:3dop project3d op ;
:3dline project3d line ;
:3dpline project3d pline ;

:ejes
	-5.0 0 0 3dop 5.0 0 0 3dline
	0 -5.0 0 3dop 0 5.0 0 3dline
	0 0 -5.0 3dop 0 0 5.0 3dline ;

:marcas
	-5.0 ( 5.0 <? )(
		dup 0.01 0 3dop dup -0.01 0 3dline
		0.01 over 0 3dop -0.01 over 0 3dline
		0 0.01 pick2 3dop 0 -0.01 pick2 3dline
		1.0 + ) drop ;

:grillaxy
	-5.0 ( 5.0 <=? )(
		dup -5.0 0 3dop dup 5.0 0 3dline
		-5.0 over 0 3dop 5.0 over 0 3dline
		1.0 + ) drop ;

:grillayz
	-5.0 ( 5.0 <=? )(
		0 over -5.0 3dop 0 over 5.0 3dline
		0 -5.0 pick2 3dop 0 5.0 pick2 3dline
		1.0 + ) drop ;

:grillaxz
	-5.0 ( 5.0 <=? )(
		dup 0 -5.0 3dop dup 0 5.0 3dline
		-5.0 0 pick2 3dop 5.0 0 pick2 3dline
		1.0 + ) drop ;

:teclado
	'exit >esc<
	[ 0.1 'ycam +! ; ] <up>
	[ -0.1 'ycam +! ; ] <dn>
	[ 0.1 'xcam +! ; ] <le>
	[ -0.1 'xcam +! ; ] <ri>
	[ 0.1 'zcam +! ; ] <pgdn>
	[ -0.1 'zcam +! ; ] <pgup>
	[ 0.01 'xr +! ; ] <spc>
	;

:freelook
	xymouse
	sh 2/ - 7 << swap
	sw 2/ - neg 7 << swap
	neg mrotx
	mroty ;

:drawp | x y z ---
	project3d |2dup op line ;
	-? ( 2drop ; ) sh >=? ( 2drop ; )
	swap -? ( 2drop ; ) sw >=? ( 2drop ; ) swap
	setxy
	ink@ px!+
	;

|-----------------
| rand en box
:rr
	rnd $1ffff and $ffff - ;

:drawpointrand
	2 rndseed
	0 ( 5000 <? )(
		rr rr rr drawp
		1+ ) drop
	;

|-----------------
| coordenadas esfericas
| x = sinUcosV
| y = sinUsinV
| z = cosU
:drawpoints
	0 ( 1.0 <? )(
		0 ( 1.0 <? )(
			over sincos | u v sinu cosu
			pick2 sincos | u v sinu cosu sinv cosv
			pick3 *. >r | u v sinu cosu sinv   r:x
			rot *. r>
			drawp
			0.05 + ) drop
		0.05 + ) drop
	;

|-----------------
|    Choose height u uniformly distributed in [-1,1].
|    Choose angle psi uniformly distributed on [0, 2*pi).
| r = sqrt(1-u^2).
| x = r * cos(psi).
| y = r * sin(psi).
:drawpointt
	-1.0 ( 1.0 <? )(
		0 ( 1.0 <? )(
			1 pick2 dup *. - sqrt.	| r
			over sincos				| r s c
			pick2 *. swap pick2 *.
			drawp
			0.05 + ) drop
		0.05 + ) drop
	;

| x y en 16 bits-- z en 32 bits
:morton2d | x y -- z
	dup 8 << or $00ff00ff and
	dup 4 << or $0f0f0f0f and
	dup 2 << or $33333333 and
	dup 2* or   $55555555 and
	2* swap
	dup 8 << or $00ff00ff and
	dup 4 << or $0f0f0f0f and
	dup 2 << or $33333333 and
	dup 2* or   $55555555 and
	or ;

|x y z . 10 bits
| sobra 2 bits!!
:morton3d | x y z -- Z
	dup 10 << or $000f801f and
	dup 4 << or  $00e181c3 and
	dup 2 << or  $03248649 and
	dup 2 << or  $09249249 and
	2* swap
	dup 10 << or $000f801f and
	dup 4 << or  $00e181c3 and
	dup 2 << or  $03248649 and
	dup 2 << or  $09249249 and
	or 2* swap
	dup 10 << or $000f801f and
	dup 4 << or  $00e181c3 and
	dup 2 << or  $03248649 and
	dup 2 << or  $09249249 and
	or ;


:main
	mark

	show clrscr
     	teclado
		1.0 3dmode
		freelook
		xcam ycam zcam mtrans
		gris grillaxy grillayz grillaxz
		blanco

|		drawpointrand
		drawpoints
		cminiflecha ;

: main ;