| LibColores
| PHREDA
|--------------------------------
^r4/lib/optdiv.txt

| degrade entre dos colores
|--------------------------------------
#rc #gc #bc
#sr #sg #sb

|---------------------
:pasocol | -- col
	rc sr + dup 'rc ! $ff0000 and
	gc sg + dup 'gc ! 8 >> $ff00 and or
	bc sb + dup 'bc ! 16 >> $ff and or ;

::cmorph | cant col1 col2 --
	over px!+
	over $ff0000 and dup 'rc ! over $ff0000 and swap - pick3  / 'sr !
	over 8 << $ff0000 and dup 'gc ! over 8 << $ff0000 and swap - pick3  / 'sg !
	swap 16 << $ff0000 and dup 'bc ! swap 16 << $ff0000 and swap - over  / 'sb !
	1- ( 1? )( 1- pasocol px!+ ) drop
	;

| diferencia de color
|--------------------------------------
|int DiffRGB2(unsigned long int a, unsigned long int b)
|  return abs((a>>16)-(b>>16)) + abs(((a>>8)&255)-((b>>8)&255)) + abs((a&255)-(b&255));
::diffrgb2 | a b -- v
	over 16 >> over 16 >> - abs | a b a1
	pick2 8 >> $ff and pick2 8 >> $ff and - abs + | a b a2
	rot $ff and rot $ff and - abs + ;

|uint32 vdavgpixel(uint32 a, uint32 b) {
|	return (a|b) - (((a^b)&0xfefefefe)>>1);
::colavg | a b -- c
	2dup xor $fefefefe and 2/ >r or r> - ;

|uint32 vdlerppixel(uint32 a, uint32 b, unsigned alpha) {
|	return a + (((((b&0xff00ff) - (a&0xff00ff))*alpha + 0x00800080)>>8) & 0xff00ff) +
|				(((((b&0xff00) - (a&0xff00))*alpha + 0x008000)>>8) & 0xff00);
:collerp | a b al --c
	>r dup
	$ff00ff and pick2 $ff00ff and - r * $800080 + 8 >> $ff00ff and r> swap >r >r
	$ff00 and swap $ff00 and - r> * $8000 + 8 >> $ff00 and r> + ;

|	punto de interpolacion
|	lineal  time1=0 time2=$10000
| mix=0		..a
| mix=1.0	..b
::interpolaf | a b mix -- v		;(a,b,mix) ((b*mix+a*((1<<16)-mix))>>16)
	dup >r * swap 1.0 r> - * + 16 >> ;


| yuv <-> rgb
|-----------------------------
::rgb2yuv | rgb -- yuv
	over 2* pick3 - pick2 - 3 >>  >r
	pick2 over - 2 >> 128 + >r
	+ + 2 >> r> r> ;

:bound | i -- i
	$ff >? ( $ff nip ) -? ( 0 nip ) ;

::yuv2rgb | yuv -- rgb
	pick2 16 - 76283 * pick2 128 - 132252 * + 16 >> bound >r
	pick2 16 - 76283 * pick2 128 - 25624 *  - pick2 128 - 53281 * - 16 >> bound >r
	nip 128 - 104595 * swap 16 - 76283 * + 16 >> bound r> r> ;

::yuv32 | yuv -- col
	pick2 16 - 76283 * pick2 128 - 132252 * + 16 >> bound >r
	pick2 16 - 76283 * pick2 128 - 25624 *  - pick2 128 - 53281 * - 16 >> bound 8 << $ff00 and >r
	nip 128 - 104595 * swap 16 - 76283 * + 16 >> bound 16 << $ff0000 and r> or r> or ;


| hsv 1.0 1.0 1.0 --> rgb

:h0 ;				|v, n, m
:h1 >r swap r> ;	|n, v, m
:h2 rot rot ;		|m, v, n
:h3 swap rot ;		|m, n, v
:h4 rot ;			|n, m, v
:h5 swap ;			|v, m, n
#acch h0 h1 h2 h3 h4 h5

::hsv2rgb | h s v -- rgb32
	1? ( 1- ) $ffff and swap
	0? ( drop nip 8 >> dup 8 << dup 8 << or or ; ) | hvs
	rot 1? ( 1- ) $ffff and
	dup 2* + 2*	| 6*
	dup 16 >> 	| vshH
	1 nand? ( $ffff rot - swap ) | vsfH
	>r $ffff and	| vsf
	1.0 pick2 - pick3 *. | vsfm
	>r
	*. 1.0 swap - | v (1-s*f)
	over *. r> | vnm
	r> 2 << 'acch + @ exec | rgb
	8 >> swap 8 >> 8 << or swap 8 >> 16 << or ;

|	if (s == 0) RGB(v, v, v);
|	i = floor(h);
|	f = h - i;
|	if ( !(i&1) ) f = 1 - f; // if i is even
|	m = v * (1 - s);
|	n = v * (1 - s * f);
|	switch (i) {
|		case 6:
|		case 0: RGB(v, n, m);
|		case 1: RGB(n, v, m);
|		case 2: RGB(m, v, n)
|		case 3: RGB(m, n, v);
|		case 4: RGB(n, m, v);
|		case 5: RGB(v, m, n);


::rgb2hsv | r g b -- h s v
	pick2 pick2 pick2 max max
	pick3 pick3 pick3 min min | rgb v x
	over =? ( nip nip nip nip 1.0 8 *>> dup dup ; )
	pick2 =? ( | min=B    r g b v x
		>r >r drop -
		1.0 r> r> )(
	pick3 =? ( | min=G
		>r >r rot - nip
		5.0 >r >r )(
	| min=R
		 >r >r - nip
		3.0 r> r> ) )
			| f i v x
	>r rot	| i v f
	over r - 16 << /.
	swap >r
	- | H
	r> r> | H v x
	over >r
	- 16 <<
	r 16 << /. | H S
	r> 1.0 8 * >> | HSV
	;
|	x = min(R, G, B);
|	v = max(R, G, B);
|	if(v == x) HSV(UNDEFINED, 0, v);
|	f = (R == x) ? G - B : ((G == x) ? B - R : R - G);
|	i = (R == x) ? 3 : ((G == x) ? 5 : 1);
|	HSV(i - f /(v - x), (v - x)/v, v);

