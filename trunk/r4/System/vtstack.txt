| pilas virtuales (datos y retorno)
| para emulador y compilador
| PHREDA 2011
|------------------------------------

^r4/system/r4token.txt

|--- registros  $iiffccss
| ii inicio
| cc cntdeop
| tipo  cte,str,var,dvar,dcod,mem,orig
| flags final,registro
|-----------

#nroi 0
#cntregs 0
#regs )( 1024	| info de registros
#regv )( 1024	| valor de registro

|-- registros
:setreg | valor --
	nroi 24 << or	| inicio
	cntregs 1- 2 <<
	'regs + !
	;


#tostr )( 4096	| indice de dib pilas
#tostr> 'tostr

#memp )( 4096	| dibujo de pilas
#memp> 'memp

:+memp | c --
	memp> c!+ 'memp> ! ;

#sst )( 1024 | pila de pilas
#sst> 'sst

:sst!
	sst> !+ 'sst> ! ;

:sst@
	-4 'sst> +! sst> @ ;

|--- Pila DATOS
#:dpila )( 1024 | 8bits
#:dpila> 'dpila
|----- PILA R
#:rpila )( 1048
#:rpila> 'rpila

::d.cnt dpila dpila> - 2 >> ;
::d.pop -4 'dpila> +! dpila> @ ;
::d.pop2 -8 'dpila> +! dpila> @+ swap @ ;
::d.pop3 -12 'dpila> +! dpila> @+ swap @+ swap @ ;
::d.push dpila> !+ 'dpila> ! ;
::d.TOS dpila> 4 - @ ;
::d.NOS dpila> 8 - @ ;
::d.PK2 dpila> 12 - @ ;
::d.PK3 dpila> 16 - @ ;
::d.PK4 dpila> 20 - @ ;

:usoreg | --
	d.TOS 2 << 'regs + dup
	@ dup $ffff00ff and swap
	$ff00 and $100 + or
	swap ! ;

:usomreg | --
	d.TOS 2 << 'regs + dup
	@ $80 or swap ! ;

:setrange | --
	d.TOS 2 << 'regs + dup
	@ $ff00ffff and
	nroi 16 << or
	swap ! ;

:d.pushNew | valor tipo --
	cntregs dup d.push
	2 << dup >r
	'regs + !
	r> 'regv + !
	1 'cntregs +! ;

::d.pushDec	1 d.pushNew ;
::d.pushHex	1 d.pushNew ;
::d.pushBin	1 d.pushNew ;
::d.pushFix	1 d.pushNew ;
::d.pushStr	2 d.pushNew ;
::d.pushVar	3 d.pushNew ;
::d.pushDVar 4 d.pushNew ;
::d.pushDCod 5 d.pushNew ;

:d.pushCalc		d.push ;
:d.pushMem		d.push ;
:d.pushCopy 6 d.pushNew ;


|-------- operaciones de pila
:vDROP		-4 'dpila> +! ;
:v2DROP 	-8 'dpila> +! ;
:v3DROP 	-12 'dpila> +! ;
:v4DROP 	-16 'dpila> +! ;

:vSWAP
	dpila> 8 - >r
	r@+ r@+ r> 8 -
	!+ ! ;
:vNIP
	dpila> 4 -
	dup @ over 4 - ! 'dpila> ! ;
:vROT
	dpila> 12 - >r
	r@+ r@+ r@+
	swap r> 12 - !+ !+ ! ;
:v2SWAP
	dpila> 16 - >r
	r@+ r@+ swap r@+ r@+ swap
	r> 32 - !+ !+ !+ ! ;

:sdup | dup
	| newreg con copy
	d.TOS d.pushCopy
	;
:sover | over
	d.NOS d.pushCopy ;
:spk2 	|PICK2  abc -- abca
	d.PK2 d.pushCopy ;
:spk3 	|PICK3  abcd -- abcda
	d.PK3 d.pushCopy ;
:spk4 	|PICK4  abcde -- abcdea
	d.PK4 d.pushCopy ;
:s2dup	|2DUP   ab -- abab
	sover sover ;
:s2over |2OVER  abcd -- abcdab
	spk3 spk3 ;

:d4 | 4drop
	setrange vdrop
:d3 | 3drop
	setrange vdrop
:d2 | 2drop
	setrange vdrop
:d1 | drop
	setrange vdrop ;

|--- aritmeticas y logica
:op2a1	| + - * and or xor << ..
	setrange vdrop usoreg setrange ;

:op1a1	| neg not 1+ 4+ 1- 2/ ..
	usoreg setrange ;

:op3a1	| *>> /<< */
	setrange vdrop setrange vdrop
	usoreg setrange ;

:op2a2	| mod/
	setrange vswap setrange vswap
	;

|--- pila de direccion
::r.pop	-4 'rpila> +! rpila> @ ;
::r.push rpila> !+ 'rpila> ! ;
::r.cnt	rpila> 'rpila - 2 >> ;
::r.tos rpila> 4 - @ ;

:r.pushNew | valor tipo --
	cntregs dup r.push
	2 << dup >r
	'regs + !
	r> 'regv + !
	1 'cntregs +! ;


:r.pushCopy r.push ;
:r.pushCalc r.push ;

:v>R		d.pop r.push ;
:vR>		r.pop d.push ;

:vr		|R      -- a R: a -- a
	d.tos d.pushCopy ;
:vr+		|R+    a -- R: b -- c
	d1 ;
:vr@+	|R@+    -- a R: b -- c
	vr> setrange usoreg usomreg v>r
	7 d.pushNew ;
:vr!+	|R!+   a -- R: b -- c
	vr> setrange usoreg usomreg v>r
	d1 ;
:vrdrop
	vr> d1 ;


|-------------------------------
::mappila | exe --
	'dpila ( dpila> <? )( @+ pick2 exec ) 2drop ;

::mappilar | exe --
	'rpila ( rpila> <? )( @+ pick2 exec ) 2drop ;

:stacks>str | --
	memp> tostr> !+ 'tostr> !
	[ 65 + +memp ; ] mappila
	$3A +memp
	[ 65 + +memp ; ] mappilar
	0 +memp
	;

:str>stacks | "" --
	| copia tos?
	'dpila 'dpila> !
	( c@+ $3a <>? )(
		65 - d.push
		) drop
	'rpila 'rpila> !
	( c@+ 1? )(
		65 - r.push
		) 2drop
	;

:stacknow | -- now
	tostr> 4 - @ ; | stack actual

:value
	dup 4 - @ 8 >> ;

|----------------------------
:litN	| 12
	value d.pushDec ;

:litS	| "kk"
	value d.pushStr ;

:callW	| ww
	dup 4 - @ 8 >> nro>mov @
|	dup 24 >> | no se propaga es flujo de ejecucion
|	-? ( ( 1? )( 1+ vrdrop ) drop )( ( 1? )( 1- newRegR ) drop ) 	|	'deltaR +!
	8 << 24 >>
	0? ( drop ; )
	-? ( ( 1? )( 1+ vdrop ) drop )( ( 1? )( 1- 0 d.pushDec ) drop ) 	|'deltaD +!
	;

:litV	| vv
	value d.pushVar ;
:litAV	| 'v
	value d.pushDVar ;
:litAW	| 'w
	value d.pushDCod ;


:1dw 	| exec
	setrange vdrop ;
:c0 | 0? 1? ..
	usoreg setrange ;
:c1 | =? <? ..
	setrange vdrop usoreg setrange ;


:1@
	usomreg setrange ;
:1!
	usomreg
	d2 ;
:2@	| @+
	usomreg setrange
	7 d.pushNew
	;
:2! | !+
	usomreg setrange
	vswap setrange vdrop ;
:2+! | +!
	usomreg
	d2 ;



:+mem
	6 d.pushNew ;

:v3v 0 d.pushNew 
:v2v 0 d.pushNew
:v1v 0 d.pushNew  ;

|--- condicionales
:salto? | -- 1/0
	dup 8 - @ $ff and
	18 >? ( 31 <? ( drop 1 ; ) )
	drop 0 ;

:;?
	dup 8 - @ $ff and
	12 =? ( drop 1 ; )
	drop 0 ;

:es(	|(
	stacknow sst!
	salto? sst!
	;

:es)(	|)(
	salto? 1? ( sst@ 2drop stacknow sst! 3 sst! ; ) | while
	sst@ 2drop
	sst@ dup sst!
	stacknow sst! 2 sst!
	str>stacks
	;

:tipo0 | (  ? ) o (    )
	sst@ drop ;

:tipo1 | ?( )
	;? 1? ( sst@ str>stacks drop ; )
	sst@ 2drop ;

:tipo2 | ?( )( )
	;? 1? ( sst@ sst@ str>stacks 2drop ; )
	sst@ str>stacks sst@ 2drop ;

:es)	|)
	sst@ 0? ( drop tipo0 ; )
	1- 0? ( drop tipo1 ; )
	1- 0? ( drop tipo2 ; )
	sst@ str>stacks	| ( ? )(  )
	sst@ 2drop
	;

|--- anonimas
:es[	|[
	stacknow sst! ;

:es]	|]
	sst@ str>stacks
	0 7 d.pushNew ;

| uso dD dR tipo
#acctoken
0	| 0
0	|1 :,,defc
0	|2 :,,defv
litN |3 :,,litd | --	n numero decimal
litN |4 :,,lith | --	n numero hexa
litN |5 :,,litb | -- n numero binario
litN |6 :,,litf | --	n numero punto fijo
litS |7 :,,lits | --	s string
callW |8 :,,word 	| ..--..  word <---- debe ser calculado
litV |9 :,,var 	| -- v var
litAW |10:,,dword | -- dw dir word
litAV |11:,,dvar 	| -- dv dir var
0	|; | fin de palabra (12)
es(	|(
es)(	|)(
es)	|)
es[	|[
es]	|]
1dw	|EXEC  x/0 --    TOS es dcod
c0	|0? a -- a
c0	|+? a -- a
c0	|-? a -- a
c0	|1? a -- a
c1	|=?  ab -- a
c1	|<?  ab -- a
c1	|>?  ab -- a
c1	|<=? ab -- a
c1	|>=? ab -- a
c1	|<>? ab -- a
c1	|AND?  ab -- a
c1	|NAND? ab -- a
sdup	|DUP    a -- aa
d1 	|DROP  a --
sover 	|OVER   ab -- aba
spk2 	|PICK2  abc -- abca
spk3 	|PICK3  abcd -- abcda
spk4 	|PICK4  abcde -- abcdea
vswap 	|SWAP   ab -- ba
vnip	|NIP   ab -- b
vrot	|ROT	abc -- bca
s2dup	|2DUP   ab -- abab
d2	|2DROP ab --
d3	|3DROP abc --
d4	|4DROP abcd --
s2over	|2OVER  abcd -- abcdab
v2swap	|2SWAP  abcd -- cdab

v>R		|>R    a -- R: -- a
vR>		|R>    -- a R: a --
vr		|R      -- a R: a -- a
vr+		|R+    a -- R: b -- c
vr@+	|R@+    -- a R: b -- c
vr!+	|R!+   a -- R: b -- c
vrdrop	|RDROP	R: a --

op2a1	|53 AND	ab -- c
op2a1	|OR    ab -- c
op2a1	|XOR   ab -- c
op1a1	|NOT    a -- b
op2a1	|+		ab -- c
op2a1	|-     ab -- c
op2a1	|*     ab -- c
op2a1	|/     ab -- c		usa eax,edx
op3a1	|*/    abc -- d     usa eax,edx
op3a1	|*>>   abc -- d     usa eax,edx, ecx
op2a2	|/MOD   ab -- cd    usa eax,edx
op2a1	|MOD    ab -- c     usa eax,edx
op1a1	|ABS    a -- b      usa eax,edx
op1a1	|SQRT	a -- b
op1a1	|CLZ	a -- b     usa eax,edx
op3a1	|<</	abc -- d   usa eax,edx, ecx
op1a1	|NEG    a -- b
op1a1	|1+     a -- b
op1a1	|4+     a -- b
op1a1	|1-     a -- b
op1a1	|2/     a -- b
op1a1	|2*     a -- b
op2a1	|<<    ab -- c     usa ecx
op2a1	|76 >>    ab -- c  usa ecx
1@	|@      a -- b     tos es ddat
1@	|C@     a -- b		tos es ddat
1@	|W@     a -- b      tos es ddat
1!	|!     ab --        tos es ddat
1!	|C!    ab --        tos es ddat
1!	|W!    ab --        tos es ddat
2+!	|+!    ab --        tos es ddat
2+!	|C+!   ab --        tos es ddat
2+!	|W+!   ab --        tos es ddat
2@	|@+     a -- bc     tos es ddat
2!	|!+    ab -- c      tos es ddat
2@	|C@+    a -- bc     tos es ddat
2!	|C!+   ab -- c      tos es ddat
2@	|W@+    a -- bc     tos es ddat
2!	|W!+   ab -- c      tos es ddat

v3drop	|MOVE  abc --       a,b es ddat
v3drop	|MOVE> abc --		a,b es ddat
v3drop	|CMOVE abc --		a,b es ddat
v3drop	|CMOVE> abc --		a,b es ddat

+mem |MEM	-- a		a es ddat
vdrop	|DIR    a --
0	|FILE   a -- b
0	|FSIZE  a -- b
0	|VOL    a -- b
vdrop	|LOAD   ab -- c
v3drop	|SAVE   abc --

0	|UPDATE  a -- a
v2v	|XYMOUSE -- ab
v1v	|BMOUSE  -- a
vdrop	|IKEY!  a --
v1v	|KEY     -- a
v1v	|CNTJOY  -- a
v1v	|GETJOY  -- a

v1v	|MSEC    -- a
v3v	|TIME    -- abc
v3v	|DATE    -- abc
0	|END     --
vdrop	|RUN    a --
v1v	|SW      -- a
v1v	|SH      -- a
0	|CLS     --
0	|REDRAW  --
v1v	|FRAMEV  -- a
v2drop	|SETXY  ab --
vdrop	|PX+!   a --
vdrop	|PX!+   a --
v1v	|PX@     -- a

v1v	|XFB     -- a
0	|>XFB    --
0	|XFB>    --

vdrop	|PAPER  a --
vdrop	|INK    a --
v1v		|INK@    -- a
vdrop	|ALPHA  a --
v2drop	|OP     ab --
v2drop	|CP     ab --
v2drop	|LINE   ab --
v2drop	|CURVE  ab --
v2drop	|PLINE  ab --
v2drop	|PCURVE ab --
0		|POLI    --
v2drop	|FCOL   ab --
v2drop	|FCEN   ab --
v2drop	|FMAT   ab --
0	|SFILL   --
0	|LFILL   --
0	|RFILL   --
vdrop	|TFILL  a --

0	|SLOAD   a -- a
vdrop	|SPLAY  a --
0	|MLOAD   a -- a
vdrop	|MPLAY  a --

|---- falta
0	|OPENURL

0	|DOCINI
0	|DOCEND
0	|DOCAT
0	|DOCLINE
0	|DOCTEXT
0	|DOCFONT
0	|DOCBIT
0	|DOCRES
0	|DOCSIZE
0	|SYSTEM



:vtini
	'tostr 'tostr> !
	'memp 'memp> !
	'sst 'sst> !
	0 'nroi !
	0 'cntregs !
	'dpila 'dpila> !
	'rpila 'rpila> !
	;

::sregtok | adr -- adr+
	@+ $ff and 2 << 'acctoken + @ exec
	stacks>str
	1 'nroi +! ;

:vtend
	;

|-------- analizadores
::vtstacknro | nro --
	vtini
	dup nro>udr 2drop
	neg ( 1? )( 0 0 d.pushNew 1- ) drop
	stacks>str

	nro>toklen ( 1? )( 1- swap sregtok swap )
	2drop
	vtend
	;

::vtstack | fin ini used --
	vtini
	( 1? )( 0 0 d.pushNew 1- ) drop
	stacks>str
	( over <? )( sregtok ) 2drop
	vtend
	;


|-------- asignadores
::mapregs | exe --
	'regs 0 ( cntregs <? )(
		swap
		@+ pick3 exec
		swap 1+ ) 3drop ;

|--------- dump
::sregdump
	'tostr ( tostr> <? )(
		@+ sp print cr
		) drop
	;

::sregdumpi | nro --
	1+ 2 << 'tostr + ( tostr> <? )(
		@+ sp print cr
		) drop
	;

::dumpregs | --
	| ctes
	azul
	[ $ff00 nand? ( pick2 65 + "%k %h |" allowcr print )( drop ) ; ] mapregs
	cyan cr
	[ $ff00 and? ( pick2 65 + "%k %h |" allowcr print )( drop ) ; ] mapregs
	;

|--- dword
:mcte "$%h" mprint ;
:mstr "s%h" mprint ;
:mvar "dword [w%h]" mprint ;
:mdvar "w%h" mprint ;
:mdcod "w%h" mprint ;
:mmem ;
:morig ;

#accnreg 0 mcte mstr mvar mdvar mdcod mmem morig

:,nreg | nro -- ""
	2 << dup 'regv + @
	swap 'regs + @
	$7 and 2 << 'accnreg + @ exec ;

|--- byte
:mcteb "$%h" mprint ;
:mstrb "s%h" mprint ;
:mvarb "byte [w%h]" mprint ;
:mdvarb "w%h" mprint ;
:mdcodb "w%h" mprint ;
:mmemb ;
:morigb ;

#accnregb 0 mcteb mstrb mvarb mdvarb mdcodb mmemb morigb

:,nregb | nro -- ""
	2 << dup 'regv + @
	swap 'regs + @
	$7 and 2 << 'accnregb + @ exec ;

|--- word
:mctew "$%h" mprint ;
:mstrw "s%h" mprint ;
:mvarw "word [w%h]" mprint ;
:mdvarw "w%h" mprint ;
:mdcodw "w%h" mprint ;
:mmemw ;
:morigw ;

#accnregw 0 mctew mstrw mvarw mdvarw mdcodw mmemw morigw

:,nregw | nro -- ""
	2 << dup 'regv + @
	swap 'regs + @
	$7 and 2 << 'accnregw + @ exec ;


|-----
::,TOS
	dup 24 >> $ff and ,nreg ;
::,TOSb
	dup 24 >> $ff and ,nregb ;
::,NOS
	dup 16 >> $ff and ,nreg ;
::,NOS2
	dup 8 >> $ff and ,nreg ;

|--------------------------------------------
#RegCount 5
#ra "eax" #rb "ebx" #rc "ecx" #rd "edx" #re "edi"
#reg 'ra 'rb 'rc 'rd 're

#RegMCount 8
#rm0 "mm0" #rm1 "mm1" #rm2 "mm2" #rm3 "mm3" #rm4 "mm4" #rm5 "mm5" #rm6 "mm6" #rm7 "mm7"
#regmmx rm0 rm1 rm2 rm3 rm4 rm5 rm6 rm7

:,Reg	RegCount <? ( 2 << 'reg + @ ; ) RegCount - 	| eax ebx ecx edx
		RegMCount <? ( 	2 << 'regmmx + @ ; ) RegMCount -
		1+ neg
:,Esi	0? ( "dword [esi]" ,s drop ; )
		-? ( neg "dword [esi-4*%d]" )( "dword [esi+4*%d]" )
		mprint ;
:,Esp	0? ( "dword [esp]" ,s drop ; )
		-? ( neg "dword [esp-4*%d]" )( "dword [esp+4*%d]" )
		mprint ;
:,Var	"[w%h]" mprint ;
:,Icod  "i%h" mprint ;
:,Dcod
:,Dvar	"w%h" mprint ;
:,Str	"s%h" mprint ;
:,Cte	"%d" mprint ;

#tipopila ,Reg ,Esi ,Esp ,Var ,Icod ,Dcod ,Dvar ,Str ,Cte

:,vstack | nro --
	1+ 3 << dpila> swap -
	@+ swap @ swap 2 << 'tipopila + @ exec ,s ;

:,nreg ,reg ,s ;

#rab "al" #rbb "bl" #rcb "cl" #rdb "dl"
#regb 'rab 'rbb 'rcb 'rdb

:,regB	2 << 'regb + @ ; | no esta edi!!
:,esiB  0? ( "byte [esi]" ,s drop ; )
		-? ( neg "byte [esi-4*%d]" )( "byte [esi+4*%d]" )
		mprint ;
:,EspB	0? ( "byte [esp]" ,s drop ; )
		-? ( neg "byte [esp-4*%d]" )( "byte [esp+4*%d]" )
		mprint ;
:,VarB	"byte [w%h]" mprint ;

#tipopilaB ,RegB ,EsiB ,EspB ,VarB

:,vstackbyte | nro --
	1+ 3 << dpila> swap -
	@+ swap @ swap 2 << 'tipopilaB + @ exec ,s ;

#raw "ax" #rbw "bx" #rcw "cx" #rdw "dx" #rew "di"
#regw 'raw 'rbw 'rcw 'rdw 'rdw

:,regW	2 << 'regw + @ ;
:,esiW  0? ( "word [esi]" ,s drop ; )
		-? ( neg "word [esi-4*%d]" )( "word [esi+4*%d]" )
		mprint ;
:,EspW	0? ( "word [esp]" ,s drop ; )
		-? ( neg "word [esp-4*%d]" )( "word [esp+4*%d]" )
		mprint ;
:,VarW	"word [w%h]" mprint ;

#tipopilaW ,RegW ,EsiW ,EspW ,VarW

:,vstackword | nro --
	1+ 3 << dpila> swap -
	@+ swap @ swap 2 << 'tipopilaW + @ exec ,s ;

:d.resortstack | --  convierto to eax [esi] ..
 	trace
|	d.cnt
	'dpila >r
	1- 0 ( over <? )(
|		"mov [esi-" ,s uquieto ,d "]," ,s
     	r@+ r@+ swap 2 << 'tipopilaW + @ exec ,s ,cr
		1+ ) drop
	1+ "mov eax," ,s
	r@+ r@+ swap 2 << 'tipopilaW + @ exec ,s cr
	rdrop
|	"lea esi,[esi" ,s d.f -? ( neg "-" )( "+" ) ,s 2 << ,d "]" ,ln
	;

|----------- tipo de pila por registro
|:d.pushReg	0 d.push ; | eax ebx ecx edx edi mm0 mm1 mm2 mm3 mm4 mm5 mm6 mm7
|:d.pushEsi  1 d.push ; | dword [esi+4*] ..
|:d.pushEsp	2 d.push ; | dword	[esp+4*] ..
|:d.pushVar	3 d.push ; | var	[w1]
|:d.pushIcod	4 d.push ; | dcod	'w2
|:d.pushDcod	5 d.push ; | dcod	'w2
|:d.pushDvar	6 d.push ; | dvar	w1
|:d.pushStr	7 d.push ; | str    "hola"
|:d.pushCte	8 d.push ; | cte	23
|----------- uso de registro
#regused 0  0  0  0  0  0   0   0   0   0   0   0   0
#regname ra rb rc rd re rm0 rm1 rm2 rm3 rm4 rm5 rm6 rm7

:reg.free | -- nro
	'regused
	5 ( 1? )( swap @+
		0? ( drop 'regused - 2 >> 1- nip ; )
		drop swap ) 2drop
	| si no hay uno, libera y asigna
	4 ;
|	-1 ;

:reg.set | nro --
	2 << 'regused + 1 swap ! ;

:reg.refresh
	0 0 0 0 0 'regused !+ !+ !+ !+ !
	'dpila
	( dpila> <? )(
		@+ 0? ( over @ reg.set )
		drop 4+ ) drop
	;
