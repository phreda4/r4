| pilas virtuale (datos y retorno)
| para emulador y compilador
| PHREDA 2011
|------------------------------------
^r4/system/r4token.txt

#cntregs 1

|--- registros
| |par|costo|flags|Tipo|
|   8    8    12    4
| tipo
|	0 nro
|	1 str
|	2 var
|	3 dir var
|	4 dir cod
|	5 copy
|	6 mem??
|	7 reg??
| flags
|	$20 | es dir codigo
|	$40 | temino uso
|	$80 | es dir dato (indirecciona)
|  $100 | usa eax,edx (si no son ctes)
|  $200 | usa ecx (si no es cte)
| $8000 | es cte optimizable
| $4000 | es reg asignado???
| costo: cantidad de operaciones(lecturas no se cuentan)
| par: cuando es copia, accede al registro origen
|-----------

#regs )( 1024	| info de registros
#regv )( 1024	| valor de registro

:regFlag | nro -- tieneflagcte
	2 << 'regs + @ 15 >> 1 and ;

|------------------------------
#registros )( 4096
#:buffinf )( 4096 | informacion de registro
#tostr )( 4096	| indice de dib pilas
#tostr> 'tostr
:cntinstr tostr> 'tostr - 2 >> ;

|---- string de pilas
#memp )( 4096
#memp> 'memp

:+memp | c --
	memp> c!+ 'memp> ! ;

#sst )( 1024 | pila de pilas
#sst> 'sst

:sst!	sst> !+ 'sst> ! ;
:sst@   -4 'sst> +! sst> @ ;

|--- Pila DATOS
#:dpila )( 1024 | 8bits
#:dpila> 'dpila
|----- PILA R
#:rpila )( 1048
#:rpila> 'rpila

::d.cnt dpila dpila> - 2 >> ;
::d.pop -4 'dpila> +! dpila> @ ;
::d.pop2 -8 'dpila> +! dpila> @+ swap @ ;
::d.pop3 -12 'dpila> +! dpila> @+ swap @+ swap @ ;
::d.push dpila> !+ 'dpila> ! ;
::d.TOS dpila> 4 - @ ;
::d.NOS dpila> 8 - @ ;
::d.PK2 dpila> 12 - @ ;
::d.PK3 dpila> 16 - @ ;
::d.PK4 dpila> 20 - @ ;
::d.PK5 dpila> 24 - @ ;

:d.pushNew | valor tipo --
	cntregs dup d.push
	2 << dup >r
	'regs + !
	r> 'regv + !
	1 'cntregs +! ;

::d.pushDec	0 d.pushNew ;
::d.pushHex	0 d.pushNew ;
::d.pushBin	0 d.pushNew ;
::d.pushFix	0 d.pushNew ;
::d.pushStr	1 d.pushNew ;
::d.pushVar	2 d.pushNew ;
::d.pushDVar 3 d.pushNew ;
::d.pushDCod 4 d.pushNew ;

:d.pushCopy 5 d.pushNew ;
:d.pushMem 6 d.pushNew ;
:d.pushReg 7 d.pushNew ;

|--- pila de direccion
::r.pop	-4 'rpila> +! rpila> @ ;
::r.push rpila> !+ 'rpila> ! ;
::r.cnt	rpila> 'rpila - 2 >> ;
::r.tos rpila> 4 - @ ;

:r.pushNew | valor tipo --
	cntregs dup r.push
	2 << dup >r
	'regs + !
	r> 'regv + !
	1 'cntregs +! ;

|--- buffinf
| | TOS | NOS | NOS2 | Tipo | Compila |
|    8     8     8      4       4
| tipo
|	1 usa tos
|	2 usa tos+nos
|	3 usa tos+nos+nos2
|	4 usa tos+pk2
|	5 usa tos+pk3
|	6 usa tos+pk4
|	7 usa tos+pk5
|	8 usa tos+rtos
|	e call
| 	f lit, lits
| compila
| 	f NO GENERA CODIGO
|	7 tos+nos+nos2 se optimiza
| 	3 tos+nos se optimiza
|	1 tos se optimiza
|	0 NO OPTIMIZADO

|--- llena buffinf
:inf! tostr> 4096 - ! ;

:usot	d.tos 24 << $10 or inf! ;
:usotn  d.tos 24 << d.nos 16 << or $20 or inf! ;
:usotn2 d.tos 24 << d.nos 16 << or d.pk2 8 << or $30 or inf! ;
:uso2   d.tos 24 << d.pk2 8 << or $40 or inf! ;
:uso3   d.tos 24 << d.pk3 8 << or $50 or inf! ;
:uso4   d.tos 24 << d.pk4 8 << or $60 or inf! ;
:uso5   d.tos 24 << d.pk5 8 << or $70 or inf! ;
:usort  d.tos 24 << r.tos 8 << or $80 or inf! ;
:usorv	r.tos 8 << $90 or inf! ;
:optwor 8 << $e0 or inf! ;
:opti	d.tos 24 << $f0 or inf! ;

|---- marcas de registros
:reg+1 | --
	d.TOS 2 << 'regs + dup
	@ dup $ff00ffff and swap
	$ff0000 and $10000 + or
	swap ! ;

:memreg | es dir dato
	d.TOS 2 << 'regs + dup @ $80 or swap ! ;
:endreg | temino uso
	d.TOS 2 << 'regs + dup @ $40 or swap ! ;
:codreg | es dir codigo
	d.TOS 2 << 'regs + dup @ $20 or swap ! ;
:usoadx | usa eax,edx
	d.TOS 2 << 'regs + dup @ $100 or swap ! ;
:usoecx | usa ecx
	d.TOS 2 << 'regs + dup @ $200 or swap ! ;

|-------- operaciones de pila
:vDrop	endreg -4 'dpila> +! ;

:v4Drop vdrop
:v3Drop vdrop
:v2Drop vdrop vdrop ;

:vSWAP
	usotn
	dpila> 8 - >r
	r@+ r@+ r> 8 -
	!+ ! ;
:vNIP
	vswap vdrop ;

:vROT
	usotn2
	dpila> 12 - >r
	r@+ r@+ r@+
	swap r> 12 - !+ !+ ! ;
:v2SWAP
	dpila> 16 - >r
	r@+ r@+ swap r@+ r@+ swap
	r> 32 - !+ !+ !+ ! ;

:vDup | dup
	d.TOS d.pushCopy usotn ;
:vOver | over
	d.NOS d.pushCopy uso2 ;
:vpk2 	|PICK2  abc -- abca
	d.PK2 d.pushCopy uso3 ;
:vpk3 	|PICK3  abcd -- abcda
	d.PK3 d.pushCopy uso4 ;
:vpk4 	|PICK4  abcde -- abcdea
	d.PK4 d.pushCopy uso5 ;
:v2Dup	|2DUP   ab -- abab
	vOver vOver ;
:v2Over |2OVER  abcd -- abcdab
	vpk3 vpk3 ;

|--- aritmeticas y logica

:op1a1	| neg not 1+ 4+ 1- 2/ ..
	usot reg+1 ;

:vop1a1	| abs  clz  ..
	usot reg+1 usoadx ;

:op2a1	| + - * and or xor ..
	usotn vdrop reg+1 ;

:vop2a1	| / mod
	usotn vdrop reg+1 usoadx ;

:xop2a1 | << >>
	usotn usoecx vdrop reg+1 ;

:op3a1	| */
	usotn2 v2drop reg+1 usoadx ;

:vop3a1	| *>> /<<
	usotn2 v2drop reg+1 usoadx usoecx ;

:op2a2	| mod/
	usotn reg+1 vswap reg+1 vswap usoadx ;


:v>R	d.pop r.push usorv ;
:vR>	usorv r.pop d.push ;

:vr		|R      -- a R: a -- a
	r.tos d.pushCopy usort ;
:vr+	|R+    a -- R: b -- c
	usort vr> reg+1 v>r vdrop ;
:vr@+	|R@+    -- a R: b -- c
	vr> memreg reg+1 dup v>r d.pushVar usort ;
:vr!+	|R!+   a -- R: b -- c
	usort vr> memreg reg+1 v>r vdrop ;
:vrdrop
	vr> vdrop ;

|-------------------------------
::mappila | exe --
	'dpila ( dpila> <? )( @+ pick2 exec ) 2drop ;

::mappilar | exe --
	'rpila ( rpila> <? )( @+ pick2 exec ) 2drop ;

:stacks>str | --
	memp> tostr> !+ 'tostr> !
	[ +memp ; ] mappila 0 +memp
	[ +memp ; ] mappilar 0 +memp
	;

:str>stacks | "" --
	'dpila 'dpila> !
	( c@+ 1? )( d.push ) drop
	'rpila 'rpila> !
	( c@+ 1? )( r.push ) 2drop
	;

:stacknow | -- now
	tostr> 4 - @ ; | stack actual

|----------------------------
:value
	dup 4 - @ 8 >> ;

:litN	| 12
	value cte + @ d.pushDec opti ;
:litS	| "kk"
	value d.pushStr opti ;
:litV	| vv
	value d.pushVar opti ;
:litAV	| 'v
	value d.pushDVar opti ;
:litAW	| 'w
	value d.pushDCod opti ;

:callW	| ww
	dup 4 - @ 8 >> nro>mov @

|
|	dup 24 >> | no se propaga es flujo de ejecucion
|	-? ( ( 1? )( 1+ vrdrop ) drop )( ( 1? )( 1- newRegR ) drop ) 	|	'deltaR +!
|

	8 << 24 >>
	dup 28 << drop | set en info
	dup optwor
	0? ( drop ; )
	| control de tipos
	-? ( ( 1? )( 1+ vdrop ) drop )( ( 1? )( 1- 0 d.pushDec ) drop ) 	|'deltaD +!
	;

:1dw 	| exec
	usot codreg vdrop
	| modifica pila segun codigo *****
	;
:c0 | 0? 1? ..
	usot ;
:c1 | =? <? ..
	usotn vdrop reg+1 ;
:1@	| @ c@ w@
	usot memreg reg+1 ;
:1!	| ! c! w!
	usotn memreg v2drop ;
:2@	| @+ c@+ w@+
	memreg reg+1
	d.tos d.pushMem usotn ;
:2!	| !+ c!+ w!+
	usotn memreg reg+1 vnip ;
:2+! | +! c+! w+!
	usotn memreg v2drop ;

:+mem 	0 d.pushMem ;

:v3v 0 0 d.pushNew
:v2v 0 0 d.pushNew
:v1v 0 0 d.pushNew  ;

|--- condicionales
:salto? | -- 1/0
	dup 8 - @ $ff and
	18 >? ( 31 <? ( drop 1 ; ) )
	drop 0 ;

:;?
	dup 8 - @ $ff and
	12 =? ( drop 1 ; )
	drop 0 ;

:es(	|(
	stacknow sst!
	salto? sst!
	;

:es)(	|)(
	salto? 1? ( sst@ 2drop stacknow sst! 3 sst! ; ) | while
	sst@ 2drop
	sst@ dup sst!
	stacknow sst! 2 sst!
	str>stacks
	;

:tipo0 | (  ? ) o (    )
	sst@ drop ;

:tipo1 | ?( )
	;? 1? ( sst@ str>stacks drop ; )
	sst@ 2drop ;

:tipo2 | ?( )( )
	;? 1? ( sst@ sst@ str>stacks 2drop ; )
	sst@ str>stacks sst@ 2drop ;

:es)	|)
	sst@ 0? ( drop tipo0 ; )
	1- 0? ( drop tipo1 ; )
	1- 0? ( drop tipo2 ; )
	sst@ str>stacks	| ( ? )(  )
	sst@ 2drop
	;

|--- anonimas
:es[	|[
	stacknow sst! ;

:es]	|]
	sst@ str>stacks
	0 d.pushDCod ;

#acctoken
0 0 0	|0 1 :,,defc 2 :,,defv
litN	|3 :,,litd | --	n numero decimal
litN	|4 :,,lith | --	n numero hexa
litN	|5 :,,litb | -- n numero binario
litN	|6 :,,litf | --	n numero punto fijo
litS	|7 :,,lits | --	s string
callW	|8 :,,word 	| ..--..  word <---- debe ser calculado
litV	|9 :,,var 	| -- v var
litAW	|10:,,dword | -- dw dir word
litAV	|11:,,dvar 	| -- dv dir var
0		|; | fin de palabra (12)
es(		|(
es)(	|)(
es)		|)
es[		|[
es]		|]
1dw		|EXEC  x/0 --    TOS es dcod
c0		|0? a -- a
c0		|+? a -- a
c0		|-? a -- a
c0		|1? a -- a
c1		|=?  ab -- a
c1		|<?  ab -- a
c1		|>?  ab -- a
c1		|<=? ab -- a
c1		|>=? ab -- a
c1		|<>? ab -- a
c1		|AND?  ab -- a
c1		|NAND? ab -- a
vdup	|DUP    a -- aa
vdrop 	|DROP  a --
vover 	|OVER   ab -- aba
vpk2 	|PICK2  abc -- abca
vpk3 	|PICK3  abcd -- abcda
vpk4 	|PICK4  abcde -- abcdea
vswap 	|SWAP   ab -- ba
vnip	|NIP   ab -- b
vrot	|ROT	abc -- bca
v2dup	|2DUP   ab -- abab
v2drop	|2DROP ab --
v3drop	|3DROP abc --
v4drop	|4DROP abcd --
v2over	|2OVER  abcd -- abcdab
v2swap	|2SWAP  abcd -- cdab

v>R		|>R    a -- R: -- a
vR>		|R>    -- a R: a --
vr		|R      -- a R: a -- a
vr+		|R+    a -- R: b -- c
vr@+	|R@+    -- a R: b -- c
vr!+	|R!+   a -- R: b -- c
vrdrop	|RDROP	R: a --

op2a1	|53 AND	ab -- c
op2a1	|OR    ab -- c
op2a1	|XOR   ab -- c
op1a1	|NOT    a -- b
op2a1	|+		ab -- c
op2a1	|-     ab -- c
op2a1	|*     ab -- c
vop2a1	|/     ab -- c		usa eax,edx
op3a1	|*/    abc -- d     usa eax,edx
vop3a1	|*>>   abc -- d     usa eax,edx, ecx
op2a2	|/MOD   ab -- cd    usa eax,edx
vop2a1	|MOD    ab -- c     usa eax,edx
vop1a1	|ABS    a -- b      usa eax,edx
op1a1	|SQRT	a -- b
vop1a1	|CLZ	a -- b     usa eax,edx
vop3a1	|<</	abc -- d   usa eax,edx, ecx
op1a1	|NEG    a -- b
op1a1	|1+     a -- b
op1a1	|4+     a -- b
op1a1	|1-     a -- b
op1a1	|2/     a -- b
op1a1	|2*     a -- b
xop2a1	|<<    ab -- c     usa ecx
xop2a1	|76 >>    ab -- c  usa ecx
1@	|@      a -- b     tos es ddat
1@	|C@     a -- b		tos es ddat
1@	|W@     a -- b      tos es ddat
1!	|!     ab --        tos es ddat
1!	|C!    ab --        tos es ddat
1!	|W!    ab --        tos es ddat
2+!	|+!    ab --        tos es ddat
2+!	|C+!   ab --        tos es ddat
2+!	|W+!   ab --        tos es ddat
2@	|@+     a -- bc     tos es ddat
2!	|!+    ab -- c      tos es ddat
2@	|C@+    a -- bc     tos es ddat
2!	|C!+   ab -- c      tos es ddat
2@	|W@+    a -- bc     tos es ddat
2!	|W!+   ab -- c      tos es ddat

v3drop	|MOVE  abc --       a,b es ddat
v3drop	|MOVE> abc --		a,b es ddat
v3drop	|CMOVE abc --		a,b es ddat
v3drop	|CMOVE> abc --		a,b es ddat

+mem |MEM	-- a		a es ddat
vdrop	|DIR    a --
0	|FILE   a -- b
0	|FSIZE  a -- b
0	|VOL    a -- b
vdrop	|LOAD   ab -- c
v3drop	|SAVE   abc --
v3drop	|APPEND   abc --

0	|UPDATE  a -- a
v2v	|XYMOUSE -- ab
v1v	|BMOUSE  -- a
vdrop	|IKEY!  a --
v1v	|KEY     -- a
v1v	|CNTJOY  -- a
v1v	|GETJOY  -- a

v1v	|MSEC    -- a
v3v	|TIME    -- abc
v3v	|DATE    -- abc
0	|END     --
vdrop	|RUN    a --
v1v	|SW      -- a
v1v	|SH      -- a
0	|CLS     --
0	|REDRAW  --
v1v	|FRAMEV  -- a
v2drop	|SETXY  ab --
vdrop	|PX+!   a --
vdrop	|PX!+   a --
v1v	|PX@     -- a

v1v	|XFB     -- a
0	|>XFB    --
0	|XFB>    --

vdrop	|PAPER  a --
vdrop	|INK    a --
v1v		|INK@    -- a
vdrop	|ALPHA  a --
v2drop	|OP     ab --
v2drop	|CP     ab --
v2drop	|LINE   ab --
v2drop	|CURVE  ab --
v2drop	|PLINE  ab --
v2drop	|PCURVE ab --
0		|POLI    --
v2drop	|FCOL   ab --
v2drop	|FCEN   ab --
v2drop	|FMAT   ab --
0	|SFILL   --
0	|LFILL   --
0	|RFILL   --
vdrop	|TFILL  a --

0	|SLOAD   a -- a
vdrop	|SPLAY  a --
0	|MLOAD   a -- a
vdrop	|MPLAY  a --

|---- falta
0	|OPENURL

0	|DOCINI
0	|DOCEND
0	|DOCAT
0	|DOCLINE
0	|DOCTEXT
0	|DOCFONT
0	|DOCBIT
0	|DOCRES
0	|DOCSIZE
0	|SYSTEM

:vtini
	'tostr 'tostr> !
	'memp 'memp> !
	'sst 'sst> !
	1 'cntregs !
	'dpila 'dpila> !
	'rpila 'rpila> !
	;

::sregtok | adr -- adr+
	0 inf! | limpia info
	@+ $ff and |trace
	3 <? ( drop ; )	| quita :#
	2 << 'acctoken + @ exec
	stacks>str ;


|---------- imprime pilas y registros
#tipocolor $ffff00 $ffff00 $ff00ff  $7777 $770000 $ffff $ffff00 $ffffff

:printstackolor | "" --
	( c@+ 1? )(
		dup 2 << 'regs + @ | info reg
|		$7 and 2 << 'tipocolor + @ ink
		$8000 and? ( verde )( rojo )
		$4000 and? ( blanco ) drop
		64 + emit
		) drop
	c@+ 0? ( 2drop ; )
	blanco ":" print
	( 	dup 2 << 'regs + @ | info reg
|		$7 and 2 << 'tipocolor + @ ink
		$8000 and? ( verde )( rojo ) 
		$4000 and? ( blanco ) drop
		64 + emit
		c@+ 0? )
	2drop
	;

::sregdumpi | nro --
	1+ 2 << 'tostr +
	( tostr> <? )(
		@+ sp printstackolor sp
		cr )
	drop ;

::oregdumpi | nro --
	1+ 2 <<
	dup 'buffinf +
	swap 'tostr +
	( tostr> <? )(
		4+ swap @+ "%h " print swap
		cr )
	2drop ;

::rregdumpi | nro --
	1+ 2 <<
	dup 'registros +
	swap 'tostr +
	( tostr> <? )(
		4+ swap @+ "%h " print swap
		cr )
	2drop ;

|----------------- para generar codigo
:value	over 1024 + @ ;

:mt0 value 9 >? ( "$%h" )( "%d" )  mprint ;
:mt1 value cte + "s%h" mprint ;
:mt2 value "[w%h]" mprint ;
:mt3 value "w%h" mprint ;
:mt4 value "w%h" mprint ;

:mt5 value "CC %d" mprint ;
:mt6 value "EE %d" mprint ;

#ra "eax" #rb "ebx" #rc "ecx" #rd "edx" #re "edi" #rf "ebp"
#reg 'ra 'rb 'rc 'rd 're 'rf

:espila
	neg 1- "[esi+%d*4]" mprint ;
:mt7 | Reg
	value -? ( espila ; )
	2 << 'reg + @ ;

#tiposrm mt0 mt1 mt2 mt3 mt4 mt5 mt6 mt7

::reg>str | nro -- ""
	2 << 'regs + dup @
	dup $7 and 2 << 'tiposrm + @ exec
	nip nip ;

#tiposrb mt0 mt1 mt2 mt3 mt4 mt5 mt6 mt7

::reg>strb | nro -- ""
	2 << 'regs + dup @
	dup $7 and 2 << 'tiposrb + @ exec
	nip nip ;

|--------- registros
:mapregs | 'v --
	'regs 4+ 1 ( cntregs <? )(
		swap
		@+ pick3 exec
		swap 1+ )
	3drop ;

:value	over 1020 + @ ;

:mapregs.next | -- regsig
	over @ ;

:t0 amarillo "Cte " print ;
:t1 azul "Str " print value cte + "%s" print ;
:t2 violeta "Var " print value nro>nom "%w" print ;
:t3 cyan oscuro "'Va " print value nro>nom "'%w" print ;
:t4 rojo oscuro "'Co " print value nro>nom "'%w" print ;
:t5 cyan "Cpy " print ; |value 64 + "%k" print ;
:t6 amarillo "Ext " print value "%d" print ;
:t7 blanco "Reg " print value "%d" print ;

#tiposr t0 t1 t2 t3 t4 t5 t6 t7

:cadaregistro
	blanco
	pick2 dup 64 + swap "%d.%k=" print
	dup $7 and 2 << 'tiposr + @ exec
|	dup " %h " print
	sp
	$8000 and? ( "**" print ) | flag cte
	$4000 and? ( "RR" print ) | flag cte

	$80 and? ( "M" print ) | como memoria
	$40 nand? ( "S" print ) | no endreg (es salida)
	$20 and? ( "C" print ) | codreg
	$100 and? ( "a" print ) | usoadx
	$200 and? ( "c" print ) | usoecx | si no es cte

	dup 16 >> $ff and 1? ( "<%d>" print )( drop )

|	24 >> " %h" print
	drop

	gris
|	over reg>str sp print
	cr
	allowchome ;

::dumpregs | --
	'cadaregistro mapregs ;

|---- flags
:ctessincosto | nro reg -- nro
	dup 16 >> $ff and
	1? ( 2drop ; ) | tiene costo
	drop
	dup $f and
|	5 =? ( 2drop ; ) | cpy
	7 =? ( 2drop ; )  | reg
	drop
	$40 nand? ( drop ; ) | no termino
	$8000 or over 4 - ! | marca como cte
	;

:call2jump | nro reg -- nro
	mapregs.next $ff and
	drop
	;

:AsignoReg
	'ctessincosto mapregs | marco constantes

	| busco lugar a optimizar
	| busco registro libre
	| recalculo estado
	| si ya se puede compilar salgo
	| si me quede sin registro ajusto
	;

|--- genera info
:t0
	drop 0 ;
:t1 |:usot
	24 >> $ff and RegFlag ;
:t2 |:usotn | :+ nos tos -- nos
	dup 24 >> $ff and regFlag
	swap 16 >> $ff and regFlag 2*
	or ;
:t3 |:usotn2
	dup 24 >> $ff and regFlag
	swap dup 16 >> $ff and regFlag 2*
	swap 8 >> $ff and regFlag 2 <<
	or or ;
:t4 |:uso2
:t5 |:uso3
:t6 |:uso4
:t7 |:uso5
:t8 |:usort
	dup 24 >> $ff and regFlag
	swap 8 >> $ff and regFlag 2*
	or ;

:t9
:ta
:tb
:tc
:td drop 0 ;
:te | word
	drop 0 ;

:tf | lit, vars ,dvar, dcod
	24 >> $ff and
	regFlag 1? ( drop $f ; )
	;

#tipoi t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 ta tb tc td te tf

:anteriorescall=>jump
	dup 8 - @ $ff and
	8 <>? ( drop ; )
	drop
	dup 8 -
	;

:marcatoken | 'info -- 'info+
	@+ dup
	4 >> $f and 2 << 'tipoi + @ exec | info val -- info val
	0? ( drop anteriorescall=>jump ; )
	$f and
	over 4 - @ $fffffff0 and or
	over 4 - !
	;

|-------- analizadores
::vtstacknro | nro --
	vtini
	dup nro>udr 2drop |usadas
	neg ( 1? )( 1- dup neg d.pushDec ) drop | como inicio
	stacks>str
| PARTE 1 - Crea registros
	dup nro>toklen
	( 1? )( 1- swap
		sregtok swap ) 2drop
| PARTE 2 - Asignacion de registros
	AsignoReg
| PARTE 3 - Marca
	'buffinf cntinstr
	( 1? )( 1- >r
		marcatoken
		r> )
	3drop
	;

::vtstack | fin ini used --
	vtini
	( 1? )( 1- dup neg d.pushDec ) drop |usadas
	stacks>str
| PARTE 1 - Crea registros
	( over <? )( sregtok ) 2drop
| PARTE 2 - Asignacion de registros
	AsignoReg
| PARTE 3 - Marca
	'buffinf cntinstr
	( 1? )( 1- >r
		marcatoken
		r> )
	2drop
	;
