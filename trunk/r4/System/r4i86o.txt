| R4i86o.txt - PHREDA 2010
| Generacion de codigo para i86-FASM
|
| .. [esp] - pila R
| .. [esi] eax - pila D
|
| ebx edi - Libres
| ecx - libre | sar sal
| edx - libre | * /
|
| ebp - VFRAME pointer
| MMX - auxiliares de almacenamiento
|
| nivel 0 -- solo macros,variable y direcciones
| nivel 1 -- llamada a palabras de nivel 0
| nivel 2 -- llamada a palabras de nivel 1 y 0
|--------------------------------------------
^r4/lib/gui.txt
^r4/lib/parse.txt
^r4/system/vstack2.txt

^r4/lib/trace.txt

|----- nro de str y label
#nstr | nro de string
#nlabel | nro de etiqueta

::ini.compila
	0 'nstr ! 0 'nlabel ! ;

|----- pila de compilador
#pilac )( 256	#pilac> 'pilac

:>pilac pilac> ! 4 'pilac> +! ;
:<pilac -4 'pilac> +! pilac> @ ;
:-pilac 'pilac 'pilac> ! ;

|-------------------------------------
#regact

|--- para registros de vpila vstack2
:freeEAX | libero EAX
	0 reg!! ;

:needEAX | cell --
	dup cellREG? 0? ( 2drop ; ) drop

	| si es registro a o numero salir
	| liberar y ocupar a ( puede ser xchg eax,.. )
	drop ;

:needREG | cell --
	dup cellREG? 0 >=? ( 2drop ; ) drop	| ya es registro salir
	newReg dup reg! 	| buscar registro libre
	5 rot cell! ;

:resolveCLON | cell -- cell
	dup cellCLON? 0? ( drop ; ) drop
	dup cellCLONTO | clon origen
	over cellREG? over cellREG? - 0? ( 2drop ; ) drop
	"mov " ,s dup ,CELL "," ,s swap dup ,CELL ,cr
	over swap cell2cell!
	;

:needWrite | cell -- ; pone en registro si no esta
	resolveCLON
	dup cellREG? 0 >=? ( 2drop ; ) drop | ya esta en registro
	newREG | cell reg
	over cell0? 0? ( drop
		"mov " ,s dup ,REG "," ,s over ,CELL
		)( drop
		"xor " ,s dup ,REG "," ,s dup ,REG
		)
	,cr
	dup reg! 5 rot cell!	;

:needWriteM | cell -- ; registro o direccion cte
	dup cellADR? 1? ( drop needWrite ; )
	2drop ;

:resolveCPY | cell --
	( dup cellNEED? 0? )( drop
		cellCPYTO
		dup cellCPY? 0? ( drop needWrite ; )
		drop ) drop
	needWrite ;

|--- va a leer, no puede []
:needReadM | cell --
	dup cellADR? 1? ( drop needWrite ; ) drop
	dup cellCPY? 1? ( drop resolveCPY ; )
	2drop ;

:needRead | cell --
	drop ;
:needReadW | cell --
	drop ;
:needReadB | cell --
	drop ;

:needREGorMEM | cell --
	dup cellREG? 0 >=? ( 2drop ; ) drop
	dup cellADR? 1? ( 2drop ; ) drop
	newREG | cell reg
	over cell0? 0? ( drop
		"mov " ,s dup ,REG "," ,s over ,CELL
		)( drop
		"xor " ,s dup ,REG "," ,s dup ,REG
		)
	,cr
	dup reg! 5 rot cell! ;

:cteorECX | cell --
	drop ;

:setEAX | cell --
	0 dup reg! 5 rot cell! ;

:setEDX | cell --
	3 dup reg! 5 rot cell! ;

|------ acceso a celdas
:,TOS	d.tos ,cell ;
:,TOSb	d.tos ,cellb ;

:,NOS	d.nos ,cell ;
:,NOSb	d.nos ,cellb ;
:,NOSw	d.nos ,cellw ;

:,NOS2	d.pk2 ,cell ;
:,RTOS	r.tos ,cell ;

|------------ compila CODIGO

|:nro>dicn2   8 >> 5 << 'indicepal + @ ; | nombre
:nro>dicn   8 >> "w%h" mprint ;			| numero de palabra

:label	"_" ,s ,h ;
:jmp,	"jmp " ,s label ,cr ;

:toknow		dup 4 - @ ;

:,defw :,defv ; | no hay definiciones en optimizado (investigar como)
:,[ :,] ; | no hay anonimas en optimizado

:,lit	toknow tok>cte pushNRO ;
:,lits  
		toknow 8 >> cte + strusestack 
		( 1? )( 1- |cellR1 cellST
			| cargar en pila directo
			d.drop ) 2drop | correccion por "%d"
		nstr pushSTR ;
:,dwo	toknow 8 >> pushCOD ;
:,dva   toknow 8 >> pushDAT ;
:,var	toknow 8 >> pushVAR ;

:,worjmp
	vpila2normal
	"jmp " ,s toknow nro>dicn ,s ,cr ;

:,wor
	dup @ $ff and | word ;
	12 =? ( drop ,worjmp ; ) drop

|	vpila2normal

 	toknow 8 >> nro>mov @ 24 << 24 >> neg |duso
	vpilaPreUso
	"call " ,s toknow nro>dicn ,s ,cr
	vpilaPostUso
	;

:,callsys
	vpila2normal
	dup @ $ff and | word ;
	12 =? ( "jmp " )( "call " )
	,s drop ;

:,END		"jmp SYSEND" ,ln ;
:,DIR		,callsys "SYSDIR" ,ln ;
:,FILE  	,callsys "SYSFILE" ,ln ;
:,FSIZE		,callsys "SYSFSIZE" ,ln ;
:,VOL		,callsys "SYSVOL" ,ln ;
:,LOAD		,callsys "SYSLOAD" ,ln ;
:,SAVE		,callsys "SYSSAVE" ,ln ;
:,APPEND	,callsys "SYSAPPEND" ,ln ;
:,UPDATE	,callsys "SYSUPDATE" ,ln ;
:,MSEC		,callsys "SYSMSEC" ,ln ;
:,TIME		,callsys "SYSTIME" ,ln ;
:,DATE		,callsys "SYSDATE" ,ln ;
:,RUN		,callsys "SYSRUN" ,ln ;
:,CLS		,callsys "SYSCLS" ,ln ;
:,REDRAW	,callsys "SYSREDRAW" ,ln ;
:,>XFB  	,callsys "SYSTOXFB" ,ln ;
:,XFB>  	,callsys "SYSXFBTO" ,ln ;

:,;
	dup 8 - @ $ff and | word ;
	8 =? ( drop ; ) drop
	vpila2normal
	"ret" ,ln ;


|----- auxiliares bloques
:+etiqueta	| -- nueva   // y agrega a pila
	nlabel 1+ dup 'nlabel ! dup >pilac ;

:salto? | adr++ xx -- adr++ xx 0/1
	over 8 - @ $ff and
	18 >? ( 31 <? ( 1 nip ; ) ) 0 nip ;
|   18 31 in? ( 1 nip ; ) 0 nip ; | futura palabra??


|--- asigna celdas que no estan en registros
:areg | cell
	dup cellREG? 0 >=? ( 2drop ; ) drop
	newREG | cell reg
	over cell0? 0? ( drop
		"mov " ,s dup ,REG "," ,s over ,CELL
		)( drop
		"xor " ,s dup ,REG "," ,s dup ,REG
		)
	,cr
	dup reg!
	5 rot cell!	;

:asignacell
	d.cnt ( 1? )( 1- dup d.rel areg ) drop ;

|--- asigna celdas que necesitan registros
:aregw | cell
	dup cellNEED? 0? ( 2drop ; ) drop
	dup cellREG? 0 >=? ( 2drop ; ) drop
	newREG | cell reg
	over cell0? 0? ( drop
		"mov " ,s dup ,REG "," ,s over ,CELL
		)( drop
		"xor " ,s dup ,REG "," ,s dup ,REG
		)
	,cr
	dup reg!
	5 rot cell!	;


:asignacellw | asigna celdas si es write
	d.cnt ( 1? )( 1- dup d.rel aregw ) drop ;

|----------------------
:blIN
	asignacellw
|	celdasque necesitan registros
|	copia a registros asignados
|	libera registros necesarios
	;

:blOUT
|	copia a pila los marcados
|	reasigna registros con nueva denominacion
	;

|-------------------------------------
:,(
	block.new

	| reajusta pila entrada
|	block.now "; block %d" ,print
|    block.now dumpblock,
	vpPush

	blockt
	0 =? ( +etiqueta label ,cr )		| IF
	1 =? ( +etiqueta label ,cr )		| ELSE
	2 =? ( blIN +etiqueta label ":" ,ln )	| WHILE
	3 =? ( blIN +etiqueta label ":" ,ln )	| UNTIL
	4 =? ( blIN +etiqueta label ":" ,ln )	| REPEAT
	drop ;


:,)(
	blockt
	1 =? ( asignacell vpPop vpPush <pilac +etiqueta jmp, label ":" ,ln )	| ELSE
	2 =? ( vpDrop vpPush <pilac +etiqueta label ,cr >pilac )		| WHILE
	drop ;

:,)
	blockt
	0 =? ( <pilac label ":" ,ln )				| IF
	1 =? ( <pilac label ":" ,ln )				| ELSE
	2 =? ( blOUT <pilac jmp, <pilac label ":" ,ln )	| WHILE
	3 =? ( <pilac label ,cr )					| UNTIL
	4 =? ( blOUT <pilac jmp, )						| REPEAT
	drop
|	block.now "; block %d" ,print ,cr
|   block.now dumpblock,
	vpPop
	block.end ;

|--------------------- Exec
:,EXEC | v --
	d.tos needREG
	"or " ,s ,TOS "," ,s ,TOS ,cr
	"jz @f" ,ln

|	lastdircode nro>mov @
	"call " ,s ,TOS ,cr
|	postexec

	"@@:" ,ln ;

|------- PILAR
:,>R	d.pop r.push ;
:,R>    r.pop d.push ;
:,R		r.tos d.push ;
:,RDROP r.drop ;

:,R+
	d.tos needRead
	r.tos needWrite
	"add " ,s ,RTOS "," ,s ,TOS ,cr
|	d.tos Cellval+ r.tos Cell+ |
	d.drop ;

:,R!+
	d.tos needRead
	r.tos needWriteM
	"mov [" ,s ,RTOS "]," ,s ,TOS ,cr
	"add " ,s ,RTOS ",4" ,ln
|	4 r.tos Cell+ | add 4
	d.drop ;

:,R@+
	d.dup d.tos needReg
	r.tos needReadM
	"mov " ,s ,TOS ",[" ,s ,RTOS "]" ,ln
	"add " ,s ,RTOS ",4" ,ln
|	4 r.tos Cell+ | add 4
	;

|------- ARITMETICAS LOGICAS
:,AND
	d.tos needRead
	d.nos needWrite
	"and " ,s ,NOS "," ,s ,TOS ,cr
	d.drop ;
:,OR
	d.tos needRead
	d.nos needWrite
	"or " ,s ,NOS "," ,s ,TOS ,cr
	d.drop ;
:,XOR
	d.tos needRead
	d.nos needWrite
	"xor " ,s ,NOS "," ,s ,TOS ,cr
	d.drop ;
:,+
	d.tos needRead
	d.nos needWrite
	"add " ,s ,NOS "," ,s ,TOS ,cr
|	d.tos Cell.value d.nos Cell+ | add 4
	d.drop ;
:,-
	d.tos needRead
	d.nos needWrite
	"sub " ,s ,NOS "," ,s ,TOS ,cr
	d.drop ;
:,*
	d.tos needRead
	d.nos needWrite
	"imul " ,s ,NOS "," ,s ,TOS ,cr
	d.drop ;
:,/
	d.tos needRead
	d.nos needWrite
	"idiv " ,s ,NOS "," ,s ,TOS ,cr
	d.drop ;
:,*/
	useEDX
	d.pk2 needEAX
	d.nos needREGorMEM
	d.tos needREGorMEM
	"cdq" ,ln
	"imul " ,s ,NOS ,cr
	"idiv " ,s ,TOS ,cr
	d.2DROP
	d.tos setEAX
	backEDX ;

:,*>>
	useEDX
	d.pk2 needEAX
	d.nos needREGorMEM
	d.tos cteorECX
	"cdq" ,ln
	"imul " ,s ,NOS2 ,cr
	"shrd eax,edx," ,s ,TOSb ,cr
|	"shr edx," ,s ,TOSb ,cr | no hace falta!!
	d.2DROP
	d.tos setEAX
	backEDX ;

:,<</
	useEDX
	d.pk2 needEAX
	d.nos needREGorMEM
	d.tos cteorECX
	"cdq" ,ln
    "shld edx,eax," ,s ,TOSb ,cr
	"shl eax," ,s ,TOSb ,cr
	"idiv " ,s ,NOS ,cr
	d.2DROP
	d.tos setEAX
	backEDX ;

:,/MOD
	useEDX
	d.nos needEAX
	d.tos needREGorMEM
	"cdq" ,ln
	"idiv " ,s ,TOS ,cr
	d.nos setEAX
	d.tos setEDX ;

:,MOD
	useEDX
	d.nos needEAX
	d.tos needREGorMEM
	"cdq" ,ln
	"idiv " ,s ,TOS ,cr
	d.drop
	d.tos setEDX
	freeEAX ;

:,<<
	d.tos cteorECX
	d.nos needWrite
	"sal " ,s ,NOS "," ,s ,TOSb ,cr
	d.drop ;

:,>>
	d.tos cteorECX
	d.nos needWrite
	"sar " ,s ,NOS "," ,s ,TOSb ,cr
	d.drop ;

:,ABS
	useEDX
	d.tos needREG
	d.tos cellREG? 0? ( | EAX
		"cdq" ,ln
		)(
		"mov edx," ,s ,TOS ,cr
		"sar edx,31" ,ln
		) drop
	"add " ,s ,TOS ",edx" ,ln
	"xor " ,s ,TOS ",edx" ,ln
	backEDX ;

:,CLZ
	d.tos needREG
	"bsr " ,s ,TOS  "," ,s ,TOS ,cr
	"xor " ,s ,TOS ",31" ,ln ;

:,NOT
	d.tos needWrite
	"not " ,s ,TOS ,cr ;

:,NEG
	d.tos needWrite
	"neg " ,s ,TOS ,cr ;

:,1+
	"add " ,s ,TOS ",1" ,ln
|	1 d.tos Cell+
	;
:,4+
	"add " ,s ,TOS ",4" ,ln
|	4 d.tos Cell+
	;
:,1-
	"sub " ,s ,TOS ",1" ,ln
|	-1 d.tos Cell+
	;
:,2/
	d.tos needWrite
	"sar " ,s ,TOS ",1" ,ln ;
:,2*
	d.tos needWrite
	"sal " ,s ,TOS ",1" ,ln ;

|------ MEMORIA
:,@
	d.tos needReadM
	"mov " ,s ,TOS ",dword [" ,s ,TOS "]" ,ln ;

:,C@
	d.tos needReadM
	"movsx " ,s ,TOS ",byte [" ,s ,TOS "]" ,ln ;

:,W@
	d.tos needReadM
	"movsx " ,s ,TOS ",word [" ,s ,TOS "]" ,ln ;

:,!
	d.tos needReadM
	d.nos needReadM
	"mov dword [" ,s ,TOS "]," ,s ,NOS ,cr
	d.2DROP ;
:,C!
	d.tos needReadM
	d.nos needReadB
	"mov byte [" ,s ,TOS "]," ,s ,NOSb ,cr
	d.2DROP ;
:,W!
	d.tos needReadM
	d.nos needReadW
	"mov word [" ,s ,TOS "]," ,s ,NOSw ,cr
	d.2DROP ;

:,+!
	d.nos needReadM
	d.tos needWriteM
	"add dword [" ,s ,TOS "]," ,s ,NOS ,cr
	d.2DROP ;

:,W+!
	d.nos needReadM
	d.tos needWriteM
	"add word [" ,s ,TOS "]," ,s ,NOSw ,cr
	d.2DROP ;

:,C+!
	d.nos needReadM
	d.tos needWriteM
	"add byte [" ,s ,TOS "]," ,s ,NOSb ,cr
	d.2DROP ;

:,!+
    d.nos needReadM
	d.tos needWrite
	"mov dword [" ,s ,TOS "]," ,s ,NOS ,cr
	"add " ,s ,TOS ",4" ,ln
|	4 d.tos Cell+
	d.NIP ;

:,W!+
    d.nos needReadM
	d.tos needWrite
	"mov word [" ,s ,TOS "]," ,s ,NOSw ,cr
	"add " ,s ,TOS ",2" ,ln
|	2 d.tos Cell+
	d.NIP ;
:,C!+
    d.nos needReadM
	d.tos needWrite
	"mov byte [" ,s ,TOS "]," ,s ,NOSb ,cr
	"add " ,s ,TOS ",1" ,ln
|	1 d.tos Cell+
	d.NIP ;

:,@+
	d.tos needReadM
	d.dup d.tos needReg
	"mov " ,s ,TOS ",dword [" ,s ,NOS "]" ,ln
	"add " ,s ,NOS ",4" ,ln ;
:,W@+
	d.tos needReadM
	d.dup d.tos needReg
	"movsx " ,s ,TOS ",word [" ,s ,NOS "]" ,ln
	"add " ,s ,NOS ",2" ,ln ;
:,C@+
	d.tos needReadM
	d.dup d.tos needReg
	"movsx " ,s ,TOS ",byte [" ,s ,NOS "]" ,ln
	"add " ,s ,NOS ",1" ,ln ;

|-------- CONDICIONALES
:,simple?
	d.tos needWrite
	d.tos cellADR? 1? ( drop
		"cmp " ,s ,TOS ",0" ,ln ; ) drop
	"or " ,s ,TOS "," ,s ,TOS ,cr
	;

:,0? ,simple?	"jnz " ,s ;
:,+? ,simple?	"js " ,s ;
:,-? ,simple?	"jns " ,s ;
:,1? ,simple?	"jz " ,s ;

:,doble?
	d.tos needRead
	d.nos needWrite
	d.tos cellADR? 1? ( drop
		d.nos cellADR? 1? ( drop
			d.dup d.tos needREG
			"mov " ,s ,TOS "," ,s ,NOS ,cr
			"cmp " ,s ,NOS2 "," ,s ,TOS ,cr
			d.2DROP ;
			)( drop ) )( drop )
    "cmp " ,s ,NOS "," ,s ,TOS ,cr
	d.drop ;

:,=? ,doble?	"jnz " ,s ;
:,<? ,doble?	"jge " ,s ;
:,>? ,doble?	"jle " ,s ;
:,<=? ,doble?	"jg " ,s ;
:,>=? ,doble?	"jl " ,s ;
:,<>? ,doble?	"jz " ,s ;

:,bit?
	d.tos needRead
	d.nos needWrite
	d.tos cellADR? 1? ( drop
		d.nos cellADR? 1? ( drop
			d.dup d.tos needREG
			"mov " ,s ,TOS "," ,s ,NOS ,cr
			"test " ,s ,NOS2 "," ,s ,TOS ,cr
			d.2DROP ;
			) )( drop )
    "test " ,s ,NOS "," ,s ,TOS ,cr
	d.drop ;

:,and?  ,bit?	"jz " ,s ;
:,nand? ,bit?	"jnz " ,s ;

|--------- Sistema
|#syscons "XRES" "YRES" "FREE_MEM" "SYSFRAME" "XFB" | [] | "SYSPAPER" "SYSXYM" "SYSBM" "SYSKEY"

:,SW 		0 pushCTE ;
:,SH		1 pushCTE ;
:,MEM		2 pushCTE ;
:,FRAMEV	3 pushCTE ;
:,XFB		4 pushCTE ;

:,BMOUSE | -- c
	7 pushCTE d.tos cellMEM! ;

:,KEY	| -- c
	8 pushCTE d.tos cellMEM! ;

:,PAPER | n --
	d.tos needReadM | no memoria []
	"mov [SYSPAPER]," ,s ,TOS ,cr
	d.drop ;

:,KEY! | v --
	d.tos needReadM | no memoria []
	"mov [SYSKEY]," ,s ,TOS ,cr
	d.drop ;

:setxyNOS
	d.nos needWrite | x
|	"imul " ,s ,NOS ",XRES" ,ln	| cualquier ancho
	"shl " ,s ,NOS  ",10" ,ln	| 1024 de ancho
	"lea ebp,[SYSFRAME+" ,s ,TOS "+" ,s ,NOS "*4]" ,ln ;


:,SETXY | x y --
	d.tos needRead
	d.tos cellNRO? 1? ( drop
		d.nos needRead
		d.nos cellNRO? 1? ( drop
			"lea ebp,[SYSFRAME+(" ,s ,TOS "*XRES+" ,s ,NOS ")*4]" ,ln
			)( drop
			setxyNOS )
		)( drop
		d.nos needWrite | x
|		"imul " ,s ,NOS ",XRES" ,ln	| cualquier ancho
		"shl " ,s ,NOS ",10" ,ln	| 1024 de ancho

		"add " ,s ,NOS "," ,s ,TOS ,cr
		"lea ebp,[SYSFRAME+" ,s ,NOS "*4]" ,ln
		)
	d.2DROP ;

:,PX+!	| s --
	d.tos needRead
	"lea ebp,[ebp+" ,s ,TOS "*4]" ,ln
	d.drop ;

:,PX!+	| rgb --
	d.tos needRead
	"mov dword [ebp]," ,s ,TOS ,cr
	"add ebp,4" ,ln
	d.drop ;

:,PX@	| -- rgb
	d.dup d.tos needREG
	"mov " ,s ,TOS ",dword [ebp]" ,ln ;

:,XYMOUSE | -- x y
	d.dup d.tos needREG
	d.dup d.tos needREG
	"mov " ,s ,TOS ",[SYSXYM]" ,ln
	"mov " ,s ,NOS "," ,s ,TOS ,cr
	"and " ,s ,NOS ",$ffff" ,ln
	"shr " ,s ,TOS ",16" ,ln
	;

:,CNTJOY
	d.DUP "xor eax,eax" ,ln ;
:,GETJOY ;
:,SLOAD ;
:,SPLAY  d.DROP ;
:,MLOAD ;
:,MPLAY  d.DROP ;

|----------- en asmbase.txt
:,SQRT
:,MOVE :,MOVE> :,CMOVE :,CMOVE>
:,INK :,INK@ :,ALPHA
:,OP :,CP :,LINE :,CURVE :,PLINE :,PCURVE :,POLI
:,FCOL :,FCEN :,FMAT :,SFILL :,LFILL :,RFILL :,TFILL
:,OPENURL
:,DOCINI :,DOCEND :,DOCAT :,DOCLINE :,DOCTEXT :,DOCFONT :,DOCBIT :,DOCRES :,DOCSIZE
:,SYSTEM
	;

#nivel1 0
,defw ,defv ,lit ,lit ,lit ,lit ,lits ,wor ,var ,dwo ,dva | 11
,; ,( ,)( ,) ,[ ,] ,EXEC	| 18
,0? ,+? ,-? ,1? ,=? ,<? ,>? ,<=? ,>=? ,<>? ,AND? ,NAND? | 30

d.DUP d.DROP d.OVER d.PICK2 d.PICK3 d.PICK4 d.SWAP d.NIP	|--- pila 38
d.ROT d.2DUP d.2DROP d.3DROP d.4DROP d.2OVER d.2SWAP	| 45

,>R ,R> ,R ,R+ ,R@+ ,R!+ ,RDROP					|--- pila direcciones 52
,AND ,OR ,XOR ,NOT  								|--- logicas        56
,+ ,- ,* ,/ ,*/ ,*>> ,/MOD ,MOD ,ABS  			|--- aritmeticas | 65
,SQRT ,CLZ ,<</ ,NEG ,1+ ,4+ ,1- ,2/ ,2* ,<< ,>> | 76
,@ ,C@ ,W@ ,! ,C! ,W! ,+! ,C+! ,W+!  			|--- memoria 85
,@+ ,!+ ,C@+ ,C!+ ,W@+ ,W!+	| 91
,MOVE ,MOVE> ,CMOVE ,CMOVE> | 95
,MEM ,DIR ,FILE ,FSIZE ,VOL ,LOAD ,SAVE ,APPEND		|--- memoria bloques 102
,UPDATE
,XYMOUSE ,BMOUSE
,KEY! ,KEY
,CNTJOY ,GETJOY 							| 109
,MSEC ,TIME ,DATE ,END ,RUN 				|--- sistema 114
,SW ,SH ,CLS ,REDRAW ,FRAMEV  						|--- pantalla
,SETXY ,PX+! ,PX!+ ,PX@
,XFB ,>XFB ,XFB>
,PAPER ,INK ,INK@ ,ALPHA							|--- color
,OP ,CP ,LINE ,CURVE ,PLINE ,PCURVE ,POLI		|--- dibujo
,FCOL ,FCEN ,FMAT ,SFILL ,LFILL ,RFILL ,TFILL
,SLOAD ,SPLAY ,MLOAD ,MPLAY					|--- Sonido
,OPENURL
,DOCINI ,DOCEND ,DOCAT ,DOCLINE ,DOCTEXT ,DOCFONT ,DOCBIT ,DOCRES ,DOCSIZE  |-- impresora
,SYSTEM

|------------------------------
#bufprim 0 | para salto?
#bufftok )( 4096
#buff> 'bufftok

:+buff | tok --
	buff> !+ 'buff> ! ;
:-buff | --
	0 'bufprim !
	'bufftok 'buff> ! ;


#registeruse

::,compwordopt | nro --
|---- carga en buffer
	-buff
	dup nro>toklen
	( 1? )( 1- swap
		@+ +buff
		swap ) 2drop

	buff> 'bufftok pick2 nro>mov @ 24 << 24 >> neg | finbuff buff use
	calccell

|**** debug
|	dumpcells,
|	"r4asm/cod.asm" savemem
|**** debug

	dup nro>mov @ 24 << 24 >> neg inivpila
	0 'registeruse !
	'bufftok ( buff> <? )(
		@+

| ****debug
|		dup tokenstr "; " ,s ,s 10 ,c | palabra que compila
| ****debug

		$ff and 2 << 'nivel1 + @ exec
		registros registeruse or 'registeruse !
| ****debug
|		"; " ,s printddvtack			| pila actual
|		"r4asm/cod.asm" savemem
| ****debug
		) drop
	registeruse swap nro>mem!
	;
