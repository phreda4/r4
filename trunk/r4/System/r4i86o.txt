| R4i86o.txt - PHREDA 2010
| Generacion de codigo para i86-FASM
|
| .. [esp] - pila R
| .. [esi] eax - pila D
|
| ebx edi - Libres
| ecx - libre | sar sal
| edx - libre | * /
|
| ebp - VFRAME pointer
| MMX - auxiliares de almacenamiento
|
| nivel 0 -- solo macros,variable y direcciones
| nivel 1 -- llamada a palabras de nivel 0
| nivel 2 -- llamada a palabras de nivel 1 y 0
|--------------------------------------------
^r4/lib/gui.txt
^r4/lib/parse.txt

^r4/system/r4code.txt
^r4/system/pilaestatica.txt
^r4/system/vstack2.txt

^r4/lib/trace.txt

|----- nro de str y label
#nstr | nro de string
#nlabel | nro de etiqueta

::ini.compila
	0 'nstr ! 0 'nlabel ! ;

|----- pila de compilador
#pilac )( 256	#pilac> 'pilac

:>pilac pilac> ! 4 'pilac> +! ;
:<pilac -4 'pilac> +! pilac> @ ;
:-pilac 'pilac 'pilac> ! ;



|-------------------------------------
#regact
#regval )( 32

:regTOS		regact 24 >> $ff and ;
:regNOS		regact 16 >> $ff and ;
:regNOS2	regact 8 >> $ff and ;

:cte1? | reg -- 1/0
	reg.t@
	$8000 nand? ( drop 0 ; )
	24 >> 1 >? ( drop 0 ; )
	drop 1 ;

:reg? | reg -- 1/0
	reg.t@
	$4000 nand? ( drop 0 ; )
	drop 1 ;

:mem? | reg -- 1/0
	reg.t@
	$80 and? ( drop 1 ; )
	drop 0 ;

:ctelit? |
	reg.t@
	$f and 0? ( drop 1 ; )
	drop 0 ;

|--- para registros de vpila vstack2
:REG? | nro -- valor
	;
:useREG | nro --
	;
:freeREG | nro --
	;

:useEDX ;
:freeEDX  ;

:needEAX | cell --
	drop
	;
:needREG | cell --
	drop
	;
:needReadM | cell --
	drop
	;
:needRead | cell --
	drop
	;
:needReadW | cell --
	drop
	;
:needReadB | cell --
	drop
	;

:needWrite | cell
	drop
	;
:needWriteN | cell -- ; no puede ser []
	drop
	;

:cteorECX | cell --
	drop
	;

:setEAX | cell --
	;

|------
:,TOS
	regTOS reg>str ,s ;

:,NOS
	regNOS reg>str ,s ;

|------ asignacion de registros

|------------ compila CODIGO

|:nro>dicn2   8 >> 5 << 'indicepal + @ ; | nombre
:nro>dicn   8 >> "w%h" mprint ;			| numero de palabra

:label	"_" ,s ,h 	;
:jmp,	"jmp " ,s label ,cr ;

:toknow
	dup 4 - @ ;

:,defw :,defv ; | no hay definiciones en optimizado (investigar como)
:,[ :,] ; | no hay anonimas en optimizado

:,lit	toknow tok>cte pushNRO ;
:,lits  nstr pushSTR ;
:,dwo	toknow nro>dicn pushDCO ;
:,dva   toknow nro>dicn pushDDA ;
:,var	toknow nro>dicn pushDAT ;

:,wor
	vpila2normal
	dup @ $ff and | word ;
	12 =? ( "jmp " )( "call " )
	,s drop
	toknow nro>dicn ,s ,cr ;

:,callsys
	vpila2normal
	dup @ $ff and | word ;
	12 =? ( "jmp " )( "call " )
	,s drop ;

:,END		"jmp SYSEND" ,ln ;
:,DIR		,callsys "SYSDIR" ,ln ;
:,FILE  	,callsys "SYSFILE" ,ln ;
:,FSIZE		,callsys "SYSFSIZE" ,ln ;
:,VOL		,callsys "SYSVOL" ,ln ;
:,LOAD		,callsys "SYSLOAD" ,ln ;
:,SAVE		,callsys "SYSSAVE" ,ln ;
:,APPEND	,callsys "SYSAPPEND" ,ln ;
:,UPDATE	,callsys "SYSUPDATE" ,ln ;
:,MSEC		,callsys "SYSMSEC" ,ln ;
:,TIME		,callsys "SYSTIME" ,ln ;
:,DATE		,callsys "SYSDATE" ,ln ;
:,RUN		,callsys "SYSRUN" ,ln ;
:,CLS		,callsys "SYSCLS" ,ln ;
:,REDRAW	,callsys "SYSREDRAW" ,ln ;
:,>XFB  	,callsys "SYSTOXFB" ,ln ;
:,XFB>  	,callsys "SYSXFBTO" ,ln ;

:,;
	vpila2normal
	dup 8 - @ $ff and | word ;
	8 =? ( drop ; ) drop
	"ret" ,ln ;

|----- auxiliares bloques
:+etiqueta	| -- nueva   // y agrega a pila
	nlabel 1+ dup 'nlabel ! dup >pilac ;

:salto? | adr++ xx -- adr++ xx 0/1
	over 8 - @ $ff and
	18 >? ( 31 <? ( 1 nip ; ) ) 0 nip ;

|----------------------
:,(
	| reajusta pila
	+etiqueta salto? 1? ( swap label ,cr 1 )( swap label ":" ,ln 2 ) >pilac drop ;
:,)(
	| reajusta pila
	<pilac salto? 0? ( drop
			1 =? ( <pilac +etiqueta jmp, label ":" ,ln 1 >pilac drop ; )
			)( drop
			2 =? ( <pilac +etiqueta label ,cr >pilac 3 >pilac drop ; ) )
	drop ;
:,)
	| reajusta pila
	<pilac salto? 0? ( drop
			1 =? ( <pilac label ":" ,ln drop ; )
			2 =? ( <pilac jmp, drop ; )
			3 =? ( <pilac jmp, <pilac label ":" ,ln drop ; )
		)( drop
			2 =? ( <pilac label ,cr drop ; ) )
	drop ;


|--------- PILA
:,DUP	
	d.dup ;
:,DROP
	d.drop ;
:,NIP
	d.nip ;
:,2DROP
	,NIP ,DROP ;
:,3DROP
	,NIP ,2DROP ;
:,4DROP
	,NIP ,3DROP ;

:,OVER
	d.over ;
:,PICK2
:,PICK3
:,PICK4
:,SWAP
:,ROT
:,2DUP
:,2OVER
:,2SWAP

|--------------------- Exec
:,EXEC
|	,TOS "mov ecx,%w" ,ln
	"mov ecx,eax" ,ln
	,DROP
	"or ecx,ecx" ,ln
	"jz @f" ,ln
	"call ecx" ,ln
	"@@:" ,ln ;

:,EXECx1 | 2 >> + @ exec
	"mov ecx,[eax*4+ebx]" ,ln
	"or ecx,ecx" ,ln
	"jz @f" ,ln
	"call ecx" ,ln
	"@@:" ,ln ;


|------- PILAR
:,>R	d.pop r.push ;
:,R>    r.pop d.push ;
:,R		r.tos d.push ;

:,RDROP r.drop ;

:,R+
	,TOS ,RTOS "add %w,%w" ,ln ;
	;

:,R!+
	d.tos needRead
	r.tos needWriteM
	,TOS ,RTOS "mov [%w],%w" ,ln
	| add 4
	d.drop
	;

:,R@+
|	d.pushCPY
	r.tos needReadM
	,RTOS ,NTOS "mov %w,[%w]" ,ln
	| add 4
	;

|------- ARITMETICAS LOGICAS
:,AND
	d.nos needRead
	d.tos needWrite
	,TOS ,NOS "and %w,%w" ,ln
	d.drop ;
:,OR
	d.nos needRead
	d.tos needWrite
	,TOS ,NOS "or %w,%w" ,ln
	d.drop ;
:,XOR
	d.nos needRead
	d.tos needWrite
	,TOS ,NOS "xor %w,%w" ,ln
	d.drop ;
:,+
	d.nos needRead
	d.tos needWrite
	,TOS ,NOS "add %w,%w" ,ln
	d.drop ;
:,-
	d.nos needRead
	d.tos needWrite
	,TOS ,NOS "sub %w,%w" ,ln
	d.drop ;
:,*
	d.nos needRead
	d.tos needWrite
	,TOS ,NOS "imul %w,%w" ,ln
	d.drop ;
:,/
	d.nos needRead
	d.tos needWrite
	,TOS ,NOS "idiv %w,%w" ,ln
	d.drop ;
:,*/
	useEDX
	d.nos2 needEAX
	d.nos needRead
	d.tos needWrite
	"cdq" ,ln
	,NOS "imul %w" ,ln
	,TOS "idiv %w" ,ln
	d.2drop
	d.tos setEAX
	freeEDX ;

:,*>>
	useEDX
	d.nos2 needEAX
	d.nos needRead
	d.tos cteorECX
	"cdq" ,ln
	,NOS2 "imul %w" ,ln
	,TOSb "shrd eax,edx,%w" ,ln
	,TOSb "shr edx,%w" ,ln
	d.2drop
	d.tos setEAX
	freeEDX
	;

:,<</
	useEDX
	d.nos2 needEAX
	d.nos needRead
	d.tos cteorECX
	"cdq" ,ln
    ,TOSb "shld edx,eax,%w" ,ln
	,TOSb "shl eax,%w" ,ln
	,NOS "idiv %w" ,ln
	d.2drop
	d.tos setEAX
	freeEDX
	;

:,/MOD
	useEDX
	d.nos needEAX
	d.tos needRead
	"cdq" ,ln
	,TOS "idiv %w" ,ln
	d.nos setEAX
	d.tos setEDX
	;

:,MOD
	useEDX
	d.nos needEAX
	d.tos needRead
	"cdq" ,ln
	,TOS "idiv %w" ,ln
	d.drop
	d.tos setEDX
	freeEAX ;

:,<<
	d.tos cteorECX
	d.nos needWrite
	,TOSb ,NOS "sal %w,%w" ,ln
	d.drop	;

:,>>
	d.tos cteorECX
	d.nos needWrite
	,TOSb ,NOS "sar %w,%w" ,ln
	d.drop	;

:,ABS
	useEDX
	d.tos needEAX
	"cdq" ,ln
	"add eax,edx" ,ln
	"xor eax,edx" ,ln
	freeEDX ;

:,CLZ
	d.tos needREG
	,TOS dup "bsr %w,%w" ,ln
	,TOS "xor %w,31" ,ln ;

:,NOT
	d.tos needWrite
	,TOS "not %w" ,ln ;

:,NEG
	d.tos needWrite
	,TOS "neg %w" ,ln ;

:,1+
	1 d.tos addCell ;
:,4+
	4 d.tos addCell ;
:,1-
	-1 d.tos addCell ;
:,2/
	d.tos needWrite
 	,TOS "sar %w,1" ,ln ;
:,2*
	d.tos needWrite
 	,TOS "sal %w,1" ,ln ;

|------ MEMORIA
:,@
	d.tos needReadM
	,NTOS ,TOS "mov %w,dword [%w]" ,ln ;
:,C@
	d.tos needReadM
	,NTOS ,TOS "movsx %w,byte [%w]" ,ln ;
:,W@
	d.tos needReadM
	,NTOS ,TOS "movsx %w,word [%w]" ,ln ;

:,!
	d.tos needWriteM
	d.nos needRead
	,NOS ,TOS "mov [%w],%w" ,ln
	d.2drop ;

:,C!
	d.tos needWriteM
	d.nos needReadB
	,NOSb ,TOS "mov byte [%w],%w" ,ln
	d.2drop ;
:,W!
	d.tos needWriteM
	d.nos needReadW
	,NOSw ,TOS "mov word [%w],%w" ,ln
	d.2drop ;

:,+!
	d.nos needRead
	d.tos needWriteN
	,NOS ,TOS "add [%w],%w" ,ln
	d.2drop ;

:,W+!
	d.nos needRead
	d.tos needWriteN
	,NOS ,TOSw "add word [%w],%w" ,ln
	d.2drop ;

:,C+!
	d.nos needRead
	d.tos needWriteN
	,NOS ,TOSb "add byte [%w],%w" ,ln
	d.2drop ;

:,!+
	,NOS ,TOS "mov [%w],%w" ,ln ,TOS "add %w,4" ,ln ;
:,W!+
	,NOSw ,TOS "mov word [%w],%w" ,ln ,TOS "add %w,2" ,ln ;
:,C!+
	,NOSb ,TOS "mov byte [%w],%w" ,ln ,TOS "add %w,1" ,ln ;

:,@+
	,TOS ,NOS "mov %w,[%w]" ,ln ,TOS "add %w,4" ,ln ;
:,W@+
	,TOS ,NOS "movsx %w,word [%w]" ,ln ,TOS "add %w,2" ,ln ;
:,C@+
	,TOS ,NOS "movsx %w,byte [%w]" ,ln ,TOS "add %w,1" ,ln ;


|:,@x1	"lea %w,[%w+%w]" ,ln ;
|:,@x2	"lea %w,[%w+%w*%w]" ,ln ;
|:,@x3	"lea %w,[%w+%w+%w*%w]" ,ln ;

|:,!ex	"mov [%w+%w*%w],%w" ,ln ;

|-------- CONDICIONALES
:,condicion
	regTOS mem? 1? ( drop
		"cmp " ,s ,TOS ",0" ,ln ; ) drop
	"or eax,eax" ,ln
	;
:,0? ,condicion "jnz " ,s ;
:,+? ,condicion "js " ,s ;
:,-? ,condicion "jns " ,s ;
:,1? ,condicion "jz " ,s ;

:,condicion2
	regTOS cte1? 1? ( drop
    	"cmp " ,s ,NOS "," ,s ,TOS ,cr ; ) drop
	"mov ecx,eax" ,ln ,DROP
	"cmp eax,ecx" ,ln ;

:,=? ,condicion2	"jnz " ,s ;
:,<? ,condicion2	"jge " ,s ;
:,>? ,condicion2	"jle " ,s ;
:,<=? ,condicion2	"jg " ,s ;
:,>=? ,condicion2	"jl " ,s ;
:,<>? ,condicion2	"jz " ,s ;

:,condicion3
	regTOS cte1? 1? ( drop
    	"test " ,s ,NOS "," ,s ,TOS ,cr ; ) drop
	"mov ecx,eax" ,ln ,DROP
	"test eax,ecx" ,ln ;

:,and?  ,condicion3	"jz " ,s ;
:,nand? ,condicion3	"jnz " ,s ;

|--------- Sistema
|#syscons "XRES" "YRES" "FREE_MEM" "SYSFRAME" "XFB" | [] | "SYSPAPER" "SYSXYM" "SYSBM" "SYSKEY"

:,SW 		0 pushCTE ;
:,SH		1 pushCTE ;
:,MEM		2 pushCTE ;
:,FRAMEV	3 pushCTE ;
:,XFB		4 pushCTE

:,BMOUSE | -- c
	7 pushCTE d.tos setMEM ;

:,KEY	| -- c
	8 pushCTE d.tos setMEM ;

:,PAPER | n --
	d.tos needReadN | no memoria []
	,TOS "mov [SYSPAPER],%w" ,ln
	d.drop ;

:,KEY! | v --
	d.tos needReadN | no memoria []
	,TOS "mov [SYSKEY],%w" ,ln
	d.drop ;

:,setxyopt
	3 =? ( drop
		"lea ebp,[SYSFRAME+((" ,s ,TOS "*XRES+" ,s ,NOS ")*4)]" ,ln ; )
	2 =? ( drop | TOS=cte =Y
		"mov edx," ,s ,TOS "*YRES" ,ln
		"add edx," ,s ,NOS ,cr
		"lea ebp,[SYSFRAME+edx*4]" ,ln
		; )
	drop | NOS=cte =X
	"mov edx," ,s ,TOS ,cr
	"shl edx,10" ,ln
	"add edx," ,s ,NOS ,cr
	"lea ebp,[SYSFRAME+" ,s ,NOS "+eax*4]" ,ln
	;

:,SETXY | x y --
	regTOS cte1? 2* regNOS cte1? +
	1? ( ,setxyopt ; )
	drop
	"shl eax,10" ,ln
	"add eax,[esi]" ,ln
	"lea ebp,[SYSFRAME+eax*4]" ,ln
|	"imul eax,XRES" ,ln
|	"add eax,[esi]" ,ln
|	"lea ebp,[SYSFRAME+eax*4]" ,ln
	,2DROP ;

:,PX+!	| s --
	"lea ebp,[ebp+eax*4]" ,ln
	,DROP ;
:,PX!+	| rgb --
	"mov [ebp],eax" ,ln
	"add ebp,4" ,ln
	,DROP ;
:,PX@	| -- rgb
	,DUP "mov eax,[ebp]" ,ln ;

:,XYMOUSE | -- x y
	,DUP
	"lea esi,[esi-4]" ,ln
	"mov eax,[SYSXYM]" ,ln
	"mov ecx,eax" ,ln
	"and ecx,$ffff" ,ln
	"shr eax,16" ,ln
	"mov [esi],ecx" ,ln ;

:,CNTJOY
	,DUP "xor eax,eax" ,ln ;
:,GETJOY ;
:,SLOAD ;
:,SPLAY  ,DROP ;
:,MLOAD ;
:,MPLAY  ,DROP ;

|----------- en asmbase.txt
:,SQRT
:,MOVE :,MOVE> :,CMOVE :,CMOVE>
:,INK :,INK@ :,ALPHA
:,OP :,CP :,LINE :,CURVE :,PLINE :,PCURVE :,POLI
:,FCOL :,FCEN :,FMAT :,SFILL :,LFILL :,RFILL :,TFILL
:,OPENURL
:,DOCINI :,DOCEND :,DOCAT :,DOCLINE :,DOCTEXT :,DOCFONT :,DOCBIT :,DOCRES :,DOCSIZE
:,SYSTEM
	;

|---- nivel 1 - usando registros
| info adr+ valor -- adr+
#nivel1 0
,defw ,defv ,lit ,lit ,lit ,lit ,lits ,wor ,var ,dwo ,dva | 11
,; ,( ,)( ,) ,[ ,] ,EXEC	| 18
,0? ,+? ,-? ,1? ,=? ,<? ,>? ,<=? ,>=? ,<>? ,AND? ,NAND? | 30
,DUP ,DROP ,OVER ,PICK2 ,PICK3 ,PICK4 ,SWAP ,NIP	|--- pila 38
,ROT ,2DUP ,2DROP ,3DROP ,4DROP ,2OVER ,2SWAP	| 45
,>R ,R> ,R ,R+ ,R@+ ,R!+ ,RDROP					|--- pila direcciones 52
,AND ,OR ,XOR ,NOT  								|--- logicas        56
,+ ,- ,* ,/ ,*/ ,*>> ,/MOD ,MOD ,ABS  			|--- aritmeticas | 65
,SQRT ,CLZ ,<</ ,NEG ,1+ ,4+ ,1- ,2/ ,2* ,<< ,>> | 76
,@ ,C@ ,W@ ,! ,C! ,W! ,+! ,C+! ,W+!  			|--- memoria 85
,@+ ,!+ ,C@+ ,C!+ ,W@+ ,W!+	| 91
,MOVE ,MOVE> ,CMOVE ,CMOVE> | 95
,MEM ,DIR ,FILE ,FSIZE ,VOL ,LOAD ,SAVE ,APPEND		|--- memoria bloques 102
,UPDATE
,XYMOUSE ,BMOUSE
,KEY! ,KEY
,CNTJOY ,GETJOY 							| 109
,MSEC ,TIME ,DATE ,END ,RUN 				|--- sistema 114
,SW ,SH ,CLS ,REDRAW ,FRAMEV  						|--- pantalla
,SETXY ,PX+! ,PX!+ ,PX@
,XFB ,>XFB ,XFB>
,PAPER ,INK ,INK@ ,ALPHA							|--- color
,OP ,CP ,LINE ,CURVE ,PLINE ,PCURVE ,POLI		|--- dibujo
,FCOL ,FCEN ,FMAT ,SFILL ,LFILL ,RFILL ,TFILL
,SLOAD ,SPLAY ,MLOAD ,MPLAY					|--- Sonido
,OPENURL
,DOCINI ,DOCEND ,DOCAT ,DOCLINE ,DOCTEXT ,DOCFONT ,DOCBIT ,DOCRES ,DOCSIZE  |-- impresora
,SYSTEM

|------------------------------
#bufprim 0 | para salto?
#bufftok )( 4096
#buff> 'bufftok

:+buff | tok --
	buff> !+ 'buff> ! ;
:-buff | --
	0 'bufprim !
	'bufftok 'buff> ! ;

|--------- nivel de pila
:gencode | adr adri+ -- adri+ adr+
	swap @+

|dup tokenstr "; " ,s ,s 10 ,c | ** debug

	$ff and	2 << 'nivel1 + @ exec | adri+ adr+
	;

::,compwordopt | nro --
|---- carga en buffer
	-buff
	dup nro>toklen
	( 1? )( 1- swap
		@+ +buff
		swap ) 2drop
|---- optimiza
	nro>mov @ 24 << 24 >> neg | uso
	buff> 'bufftok rot analisabuf
|---- genera codigo

	nro>mov @ 24 << 24 >> neg
	inivpila
	'buffinf 4+
	'bufftok ( buff> <? )(
		swap @+ 'regact !
		gencode

|"r4asm/cod.asm" savemem | ****debug

		) 2drop
	;
