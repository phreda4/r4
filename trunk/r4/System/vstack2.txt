| pilas virtuales (datos y retorno)
| para compilador
| PHREDA 2012
|------------------------------------

|-------- Registros del CPU
#registros 0

#sysregs "EAX" "EBX" "ECX" "EDX" "EDI" "ESI" "EBP"
"XMM0" "XMM1" "XMM2" "XMM3" "XMM4" "XMM5" "XMM6" "XMM7"
#sysregw "AX" "BX" "CX" "DX" "DI" "SI" "BP"
"*" "*" "*" "*" "*" "*" "*" "*"
#sysregb "AL" "BL" "CL" "DL" "*" "*" "*"
"*" "*" "*" "*" "*" "*" "*" "*"

#sysregsc  15

| para x64
|#sysregs "RAX" "RBX" "RCX" "RDX" "RDI" "RSI" "RBP" "R8" "R9" "R10" "R11" "R12" "R13" "R14" "R15"
|"XMM0" "XMM1" "XMM2" "XMM3" "XMM4" "XMM5" "XMM6" "XMM7" "XMM8" "XMM9" "XMM10" "XMM11" "XMM12" "XMM13" "XMM14" "XMM15"
|#sysregsc 31

:emptyreg
	%1100001 | eax y esi,ebp siempre ocupados
	'registros ! ;

::reg! | nro --
	1 swap << registros or 'registros ! ;

::reg!! | nro --
	1 swap << not registros and 'registros ! ;

|:reg? | nro -- 1/0
|	registros 1 rot << and ;

::newReg | -- reg | busca un registro libre
	0 registros
	( 1? )( 1 nand? ( drop ; ) | libre?
		2/ $7fffffff and
		swap 1+ swap )
	drop ;

::useEDX
	registros %1000 nand? ( drop ; ) drop
	"movd XMM7,EDX" ,ln ;

::backEDX
	registros %1000 nand? ( drop ; ) drop
	"movd EDX,XMM7" ,ln ;

::useECX
	registros %100 nand? ( drop ; ) drop
	"movd XMM6,ECX" ,ln ;

::backECX
	registros %100 nand? ( drop ; ) drop
	"movd ECX,XMM6" ,ln ;

|-------- constantes del sistema
#syscons "XRES" "YRES" "FREE_MEM" "SYSFRAME" "XFB"
"SYSPAPER" "SYSXYM" "SYSBM" "SYSKEY" | []

|------ Celda de la pila
#celln 0
#cellt )( 1024	| tipo
#cellv )( 1024	| valor
#cella )( 1024  | suma
#cells )( 1024  | shift
#celli )( 1024 	| info de celda

|------ bloques de codigo
#blockn 0
#block )( 1024	| tipo+info

:newcell | valor tipo -- nro
	celln 2 <<
	'cellt + !+
	1020 + !+
	0 swap 1020 + !+ | suma
	0 swap 1020 + ! | shift
	celln
	1 'celln +!
	;

:cellneedM | nro -- nro
	dup 2 <<
	dup 'cellt + @ $10 nand? ( 2drop ; ) | si no es [] seguir
	drop
|	d.tos needReg
|	"lea " ,s ,TOS "," ,s

	;

::cell+ | add nro --
	| si hay mem resolver
	2 << 'cella + ! ;

::cell>> | shi nro --
	| si hay mem resolver
	2 << 'cells + ! ;

::cell! | valor tipo nro --
	2 <<
	'cellt + !+
	1020 + !+
	0 swap 1020 + !+ | suma
	0 swap 1020 + ! | shift
	;

:movestack | dd --
	celln ( 1? )( 1-
		dup 2 << dup
		'cellt + @ 	5 =? ( drop
			dup 'cellv + @ 5 =? (

				pick3 pick3
				) )
		2drop ) drop ;

|-------- tipos de celdas
| T Tipo (NUMERO CONSTANTE 'STRING CODIGO DATO REGISTRO COPIA)
	| M Indireccion de memoria
| ...MTTTT
|----- tipos de celdas

::cellNRO? | nro -- 1/0
	2 << 'cellt + @ $1f and
	0? ( 1 )( 0 ) nip ;

::cellREG? | nro -- nroreg
	2 << dup 'cellt + @ $1f and
	5 <>? ( 2drop -1 ; ) drop
	'cellv + @ ;

::cellADR? | nro -- 0/1
	2 << 'cellt + @
	$10 and? ( drop 1 ; )
	drop 0 ;

::cellMEM! | nro --
	2 << 'cellt + dup @ $10 or swap ! ;

::cellMEM? | nro -- 1/0
	2 << 'cellt + @ $10 and? ( 1 )( 0 ) nip ;

|---- imprime celda
:list2str swap ( 1? )( 1- swap >>0 swap ) drop ;

:value	over 1024 + @ ;
:suma	over 2048 + @ ;
:shift	over 3072 + @ ;

:mt0 value "$%h" ,print ;			|--	0 nro 	33
:mt1 value 'syscons list2str ,s ;	|--	1 cte	XRES
:mt2 value "s%h" ,print ;			|--	2 str   "hola"
:mt3 value "w%h" ,print ;			|--	3 cod  'func
:mt4 value "w%h" ,print ;			|--	4 dat  'var
:mt5 value 'sysregs list2str ,s ;	|-- 8 reg 	eax

#tiposrm mt0 mt1 mt2 mt3 mt4 mt5 0 0 0

:mt5b value 'sysregb list2str ,s ;

#tiposrmb mt0 mt1 mt2 mt3 mt4 mt5b 0 0 0

:mt5w value 'sysregw list2str ,s ;

#tiposrmw mt0 mt1 mt2 mt3 mt4 mt5w 0 0 0

:cellCOPYN | nro -- adr t T
	( 2 << 'cellt + dup @
		dup $f and
		6 =? )( drop value nip nip ) ;

::,REG | nro
	'sysregs list2str ,s ;

::cell2str, | nro --
	cellCOPYN
	swap
	$10 and? ( "[" ,s )
	swap
	2 << 'tiposrm + @ exec
	shift 1? ( "*" ,s dup ,d ) drop
	suma 1? ( +? ( "+" ,s ) dup ,d ) drop
	$10 and? ( "]" ,s )
	2drop ;

::cell2strb, | nro --
	cellCOPYN
	swap
	$10 and? ( "[" ,s )
	swap
	2 << 'tiposrmb + @ exec
	shift 1? ( "*" ,s dup ,d ) drop
	suma 1? ( +? ( "+" ,s ) dup ,d ) drop
	$10 and? ( "]" ,s )
	2drop ;

::cell2strw, | nro --
	cellCOPYN
	swap
	$10 and? ( "[" ,s )
	swap
	2 << 'tiposrmw + @ exec
	shift 1? ( "*" ,s dup ,d ) drop
	suma 1? ( +? ( "+" ,s ) dup ,d ) drop
	$10 and? ( "]" ,s )
	2drop ;

::,CELL | cell --
	cellCOPYN
	swap
	$10 and? ( "[" ,s )
	swap
	2 << 'tiposrm + @ exec
	shift 1? ( "*" ,s dup ,d ) drop
	suma 1? ( +? ( "+" ,s ) dup ,d ) drop
	$10 and? ( "]" ,s )
	2drop ;


|---- celda a registro
::cell2reg, | reg cell --
	"lea " ,s
	swap 'sysregs list2str ,s
	"," ,s
	cell2str,
|	dup cellreset
|	dup cellreg
	;

|--- PILA DATO
#dpila )( 1024
#dpila> 'dpila

|--- PILA RETORNO
#rpila )( 1024
#rpila> 'rpila

:inivstack
	0 'celln !
	0 'blockn !
	'dpila 'dpila> !
	'rpila 'rpila> !
	;

::d.nro 	2 << 'dpila + @ ;
::d.cnt		dpila> 'dpila - 2 >> ;
::d.pop		-4 'dpila> +! dpila> @ ;
::d.push 	dpila> !+ 'dpila> ! ;
::d.TOS		dpila> 4 - @ ;
::d.NOS 	dpila> 8 - @ ;
::d.PK2 	dpila> 12 - @ ;
::d.PK3 	dpila> 16 - @ ;
::d.PK4 	dpila> 20 - @ ;
::d.PK5 	dpila> 24 - @ ;

::d.drop	d.tos cellREG? 0 >=? ( dup reg!! ) drop | si es registro limpia
			-4 'dpila> +! ;
::d.swap	dpila> 8 - >r r@+ r@+ r> 8 - !+ ! ;
::d.rot		dpila> 12 - >r r@+ r@+ r@+ swap r> 12 - !+ !+ ! ;
::d.2swap	dpila> 16 - >r r@+ r@+ swap r@+ r@+ swap r> 32 - !+ !+ !+ ! ;

::pushNRO	0 newcell d.push ;
::pushCTE	1 newcell d.push ;
::pushSTR	2 newcell d.push ;
::pushCOD	3 newcell d.push ;
::pushDAT	4 newcell d.push ;
::pushVAR	4 $10 or newcell d.push ;
::pushREG	5 newcell d.push ;
::pushCPY 	6 newcell d.push ;

::d.dup		d.TOS pushCPY ;
::d.over	d.NOS pushCPY ;
::d.pick2	d.PK2 pushCPY ; |PICK2  abc -- abca
::d.pick3	d.PK3 pushCPY ; |PICK3  abcd -- abcda
::d.pick4	d.PK4 pushCPY ; |PICK4  abcde -- abcdea
::d.2dup	d.over d.over ;	|2DUP   ab -- abab
::d.2over	d.pk3 d.pk3 ; |2OVER  abcd -- abcdab
::d.nip		d.swap d.drop ;
::d.4DROP	d.drop
::d.3DROP	d.drop
::d.2DROP	d.drop d.drop ;

::r.cnt		rpila> 'rpila - 2 >> ;
::r.pop		-4 'rpila> +! rpila> @ ;
::r.drop	-4 'rpila> +! ;
::r.push	rpila> !+ 'rpila> ! ;
::r.tos		rpila> 4 - @ ;

|--- pila de estado de pila y registros para bloques
#vpmem )( $3fff
#vpmem> 'vpmem
#vpst )( 1024
#vpst> 'vpst

:,vp vpmem> !+ 'vpmem> ! ;
:vp@ vpmem> @+ swap 'vpmem> ! ;

::vpini 'vpmem 'vpmem> ! 'vpst 'vpst> ! ;

:,cpcell | nro --
	2 <<
	dup 'cellt + @ ,vp
	dup 'cellv + @ ,vp
	dup 'cella + @ ,vp
	'cells + @ ,vp
	;

:cpcell@ | nro --
	2 <<
	vp@ over 'cellt + !
	vp@ over 'cellv + !
	vp@ over 'cella + !
	vp@ swap 'cells + !
	;

::vpPush | --
	vpmem> vpst> !+ 'vpst> !
	dpila> 'dpila - 2 >> ,vp
	'dpila ( dpila> <? )(
		@+ dup ,vp ,cpcell
		) drop
	rpila> 'rpila - 2 >> ,vp
	'rpila ( rpila> <? )(
		@+ dup ,vp ,cpcell
		) drop
	registros ,vp
	;

::vpPop |
	-4 'vpst> +!
	vpst> @ 'vpmem> !
	'dpila 'dpila> !
	vp@ ( 1? )( 1-
		vp@ dup d.push
		cpcell@
		) drop
	'rpila 'rpila> !
	vp@ ( 1? )( 1-
		vp@ dup r.push
		cpcell@
		) drop
	vp@ 'registros !
	;

::vpDrop
	-4 'vpst> +!
	vpst> @ 'vpmem> ! ;

::vpEqual | reacomoda los registro en los lugares
	vpst> 4 - @ | pila objetivo
	;

|------------------------------------------
#registrosusados
#inivpcnt

|------------------------------------------
| inicia vpila como normal con USADO celdas
| de forma normal, guarda nivel en INIVPCNT
| [esi+4] [esi] eax -- para usado=3
|------------------------------------------
::inivpila  | usado --
	inivstack
	0? ( drop emptyreg ; )
	dup 'inivpcnt !
	1- ( 1? )( 1-
		5 $15 newcell
		over 2 << over cell+
		d.push | [esi+..|
		) drop
	0 5 newcell d.push | eax
	emptyreg ;

|-------------------------------------------
| Transforma pila virtual a real
|-------------------------------------------
:cellESI | cell deltasi --
	over cellREG? 5 <>? ( 3drop ; ) drop | si es ESI
	swap Cell+ | ***??
	;

:correESI | deltaesi --
	0? ( drop ; )
	"lea esi,[esi" ,s +? ( "+" ,s ) dup 2 << ,d "]" ,ln
	'dpila ( dpila> <? )(
		@+ pick2 cellESI
		) drop
	'rpila ( rpila> <? )(
		@+ pick2 cellESI
		) drop
	drop ;

:resolveADR | nro xx cell yy -- nro xx cell yy
	newReg | nro xx cell yy reg
	"mov " ,s dup ,REG "," ,s
	pick2 ,CELL ,cr
|	dup reg!
	5 pick3 cell!
	;

:genRST | nro XX cell -- nro XX
|	dup cellREG? 5 =? ( ) drop | si esta en el lugar no generar
	dup cellADR? 1? ( resolveADR ) drop
	"mov dword [esi+" ,s pick2 2 << ,d "]," ,s ,CELL ,cr
	;

:genEAX | cell --
	dup cellREG? 0? ( 2drop ; ) drop
	"mov eax," ,s ,CELL ,cr
	;

::vpila2normal | --  ;transforma la pila actual a normal
	inivpcnt d.cnt
	- | actual-origen
	correESI
	'dpila d.cnt
	0? ( 2drop ; ) | ****reacomodar EAX!!!
	1- ( 1? )( 1-
		swap @+ genRST
		swap ) drop
	@ genEAX ;

|-------------------------------------------
| DEBUG: imprime pila virtual
|-------------------------------------------
::printddvtack
|	dpila> 'dpila - 2 >> ,d ":" ,s
	d.cnt ,d ":" ,s
	'dpila ( dpila> <? )(
		@+ cell2str, ,sp ) drop
	":" ,s registros ,b ,cr
	;

|-------------------------------------------
|  preasigna registros para bloques
|-------------------------------------------
::vpilaprereg

	;


|-------------------------------------------
| calcula comportamiento de celdas
|-------------------------------------------
:cellW1	| celda+1W
	d.TOS 2 << 'celli + dup
	@ dup $ff00ffff and swap
	$ff0000 and $10000 + or
	swap ! ;

:cellR1 | celda+1R
	d.TOS 2 << 'celli + dup
	@ dup $ffffff and swap
	$ff000000 and $1000000 + or
	swap ! ;

:cellST | celda es stack
	;
:cellMem | celda que es direccion de memoria
	;

:toknow	dup 4 - @ ;
:valnow	dup 4 - @ 8 >> ;

|--- condicionales
:salto? | -- 1/0
	dup 8 - @ $ff and
	18 >? ( 31 <? ( drop 1 ; ) )
	drop 0 ;

:;?
	dup 8 - @ $ff and
	12 =? ( drop 1 ; )
	drop 0 ;

:es(	|(
	;

:es)(	|)(
	;

:es)	|)
	;

|---	 anonimas
:es[	|[
	;

:es]	|]
	;

:es;
	 ;

#lastdircode

:litN	toknow tok>cte pushNRO ;
:litS
|	valnow cte + strusestack ( 1? )( 1- cellR1 cellST d.drop ) 2drop | correccion por "%d"
	0 pushSTR ;
:litAW	valnow dup 'lastdircode ! pushCOD ;
:litAV	valnow dup 'lastdircode ! pushDAT ;
:litV	valnow dup 'lastdircode ! pushVAR ;

:callW	| ww
	valnow nro>mov @
	dup 24 << 24 >> |duso
	dup ( 1? )( 1+ cellR1 d.drop ) drop
	swap 8 << 24 >>
	- abs
	( 1? )( 1- 0 d.pushREG ) drop
	;

:exexec 	| exec
    cellR1 d.drop
	lastdircode nro>mov @
	dup 24 << 24 >> |duso
	dup ( 1? )( 1+ cellR1 d.drop ) drop
	swap 8 << 24 >>
	- abs
	( 1? )( 1- 0 d.pushREG ) drop
	;

:c0 | 0? 1? ..
	cellR1 ;
:c1 | =? <? ..
	cellR1 d.drop cellR1 ;

|++++++++ 
:usoadx ;
:usoecx ;

:op1a1	cellW1 ; | neg not 1+ 4+ 1- 2/ ..
:vop1a1 cellW1 usoadx ; | abs  clz  ..
:op2a1	cellR1 d.drop cellW1 ; | + - * and or xor ..
:vop2a1 cellR1 d.drop cellW1 usoadx ; | / mod
:xop2a1	usoecx cellR1 d.drop cellW1 ; | << >>
:op3a1	cellR1 d.drop cellR1 d.drop cellW1 usoadx ; | */
:vop3a1	cellR1 d.drop cellR1 d.drop cellW1 usoadx usoecx ; | *>> /<<

:op2a2	cellW1 d.swap cellW1 usoadx ; | mod/

:1@	| @ c@ w@
	cellMem cellW1 ;
:1!	| ! c! w!
	cellMem cellR1 d.drop cellR1 d.drop ;
:2@	| @+ c@+ w@+
	cellMem cellW1
	d.tos d.pushREG  ;
:2!	| !+ c!+ w!+
	d.swap cellR1 d.swap cellMem cellW1 d.nip ;
:2+! | +! c+! w+!
	cellMem cellR1 d.drop cellR1 d.drop ;

:vuso3 cellR1 d.drop
:vuso2 cellR1 d.drop
:vuso1 cellR1 d.drop ;

:vuso11 cellR1 ;
:vuso21 cellR1 d.drop cellR1 ;

:v1cte	0 pushCTE ;
:v3v	0 pushREG
:v2v	0 pushREG
:v1v	0 pushREG ;

#usocelda 0
#acctoken
0 0 0	|0 1 :,,defc 2 :,,defv
litN	|3 :,,litd | --	n numero decimal
litN	|4 :,,lith | --	n numero hexa
litN	|5 :,,litb | -- n numero binario
litN	|6 :,,litf | --	n numero punto fijo
litS	|7 :,,lits | --	s string
callW	|8 :,,word 	| ..--..  word <---- debe ser calculado
litV	|9 :,,var 	| -- v var
litAW	|10:,,dword | -- dw dir word
litAV	|11:,,dvar 	| -- dv dir var
es;		|; | fin de palabra (12)
es(		|(
es)(	|)(
es)		|)
es[		|[
es]		|]
exexec	|EXEC  x/0 --    TOS es dcod (18)
c0		|0? a -- a
c0		|+? a -- a
c0		|-? a -- a
c0		|1? a -- a
c1		|=?  ab -- a
c1		|<?  ab -- a
c1		|>?  ab -- a
c1		|<=? ab -- a
c1		|>=? ab -- a
c1		|<>? ab -- a
c1		|AND?  ab -- a
c1		|NAND? ab -- a

d.dup	|DUP    a -- aa
d.drop 	|DROP  a --
d.over 	|OVER   ab -- aba
d.pick2 	|PICK2  abc -- abca
d.pick3 	|PICK3  abcd -- abcda
d.pick4 	|PICK4  abcde -- abcdea
d.swap 	|SWAP   ab -- ba
d.nip	|NIP   ab -- b
d.rot	|ROT	abc -- bca
d.2dup	|2DUP   ab -- abab
d.2drop	|2DROP ab --
d.3drop	|3DROP abc --
d.4drop	|4DROP abcd --
d.2over	|2OVER  abcd -- abcdab
d.2swap	|2SWAP  abcd -- cdab

v>R		|>R    a -- R: -- a
vR>		|R>    -- a R: a --
vr		|R      -- a R: a -- a
vr+		|R+    a -- R: b -- c
vr@+	|R@+    -- a R: b -- c
vr!+	|R!+   a -- R: b -- c
vrdrop	|RDROP	R: a --

op2a1	|53 AND	ab -- c
op2a1	|OR    ab -- c
op2a1	|XOR   ab -- c
op1a1	|NOT    a -- b
op2a1	|+		ab -- c
op2a1	|-     ab -- c
op2a1	|*     ab -- c
vop2a1	|/     ab -- c		usa eax,edx
op3a1	|*/    abc -- d     usa eax,edx
vop3a1	|*>>   abc -- d     usa eax,edx, ecx
op2a2	|/MOD   ab -- cd    usa eax,edx
vop2a1	|MOD    ab -- c     usa eax,edx
vop1a1	|ABS    a -- b      usa eax,edx
op1a1	|SQRT	a -- b
vop1a1	|CLZ	a -- b     usa eax,edx
vop3a1	|<</	abc -- d   usa eax,edx, ecx
op1a1	|NEG    a -- b
op1a1	|1+     a -- b
op1a1	|4+     a -- b
op1a1	|1-     a -- b
op1a1	|2/     a -- b
op1a1	|2*     a -- b
xop2a1	|<<    ab -- c     usa ecx
xop2a1	|76 >>    ab -- c  usa ecx
1@	|@      a -- b     tos es ddat
1@	|C@     a -- b		tos es ddat
1@	|W@     a -- b      tos es ddat
1!	|!     ab --        tos es ddat
1!	|C!    ab --        tos es ddat
1!	|W!    ab --        tos es ddat
2+!	|+!    ab --        tos es ddat
2+!	|C+!   ab --        tos es ddat
2+!	|W+!   ab --        tos es ddat
2@	|@+     a -- bc     tos es ddat
2!	|!+    ab -- c      tos es ddat
2@	|C@+    a -- bc     tos es ddat
2!	|C!+   ab -- c      tos es ddat
2@	|W@+    a -- bc     tos es ddat
2!	|W!+   ab -- c      tos es ddat

vuso3	|MOVE  abc --       a,b es ddat
vuso3	|MOVE> abc --		a,b es ddat
vuso3	|CMOVE abc --		a,b es ddat
vuso3	|CMOVE> abc --		a,b es ddat

v1cte |MEM	-- a		a es ddat
vuso1	|DIR    a --
vuso11	|FILE   a -- b
vuso11	|FSIZE  a -- b
vuso11	|VOL    a -- b
vuso21	|LOAD   ab -- c
vuso3	|SAVE   abc --
vuso3	|APPEND   abc --

vuso11	|UPDATE  a -- a
v2v	|XYMOUSE -- ab
v1v	|BMOUSE  -- a
vuso1	|IKEY!  a --
v1v	|KEY     -- a
v1v	|CNTJOY  -- a
v1v	|GETJOY  -- a

v1v	|MSEC    -- a
v3v	|TIME    -- abc
v3v	|DATE    -- abc
0	|END     --
vuso1	|RUN    a --
v1cte	|SW      -- a
v1cte	|SH      -- a
0	|CLS     --
0	|REDRAW  --
v1v	|FRAMEV  -- a
vuso2	|SETXY  ab --
vuso1	|PX+!   a --
vuso1	|PX!+   a --
v1v	|PX@     -- a

v1cte	|XFB     -- a
0	|>XFB    --
0	|XFB>    --

vuso1	|PAPER  a --
vuso1	|INK    a --
v1v		|INK@    -- a
vuso1	|ALPHA  a --
vuso2	|OP     ab --
vuso2	|CP     ab --
vuso2	|LINE   ab --
vuso2	|CURVE  ab --
vuso2	|PLINE  ab --
vuso2	|PCURVE ab --
0		|POLI    --
vuso2	|FCOL   ab --
vuso2	|FCEN   ab --
vuso2	|FMAT   ab --
0	|SFILL   --
0	|LFILL   --
0	|RFILL   --
vuso1	|TFILL  a --

vuso11	|SLOAD   a -- a
vuso1	|SPLAY  a --
vuso11	|MLOAD   a -- a
vuso1	|MPLAY  a --

|---- falta
0	|OPENURL

0	|DOCINI
0	|DOCEND
0	|DOCAT
0	|DOCLINE
0	|DOCTEXT
0	|DOCFONT
0	|DOCBIT
0	|DOCRES
0	|DOCSIZE
0	|SYSTEM

:iniregi
	'celli 1024 ( 0 rot !+ swap 1- 0? ) 2drop ;

::calccell | fin buff use
	inivpila
	iniregi
	( over <? )(
		@+ $ff and 2 << 'usocelda + @ exec | adri+ adr+
		) 2drop ;
