| pilas virtuales (datos y retorno)
| para compilador
| PHREDA 2012
|------------------------------------

|-------- Registros del CPU
#registros 0

#sysregs "EAX" "EBX" "ECX" "EDX" "EDI" "ESI" "EBP"
"XMM0" "XMM1" "XMM2" "XMM3" "XMM4" "XMM5" "XMM6" "XMM7"
#sysregsc  15

| para x64
|#sysregs "RAX" "RBX" "RCX" "RDX" "RDI" "RSI" "RBP" "R8" "R9" "R10" "R11" "R12" "R13" "R14" "R15"
|"XMM0" "XMM1" "XMM2" "XMM3" "XMM4" "XMM5" "XMM6" "XMM7" "XMM8" "XMM9" "XMM10" "XMM11" "XMM12" "XMM13" "XMM14" "XMM15"
|#sysregsc 31

:emptyreg
	0 'registros ! ;

:reg! | nro --
	1 swap << registros or 'registros ! ;

|:reg? | nro -- 1/0
|	registros 1 rot << and ;

|-------- constantes del sistema
#syscons "XRES" "YRES" "FREE_MEM" "SYSFRAME" "XFB"
"SYSPAPER" "SYSXYM" "SYSBM" "SYSKEY" | []

|------ Celda de la pila
#celln 0
#cellt )( 1024	| tipo
#cellv )( 1024	| valor
#cella )( 1024  | suma
#cells )( 1024  | shift

:inivstack
	0 'celln !
	'dpila 'dpila> !
	'rpila 'rpila> !
	;

:newcell | valor tipo -- nro
	celln 2 <<
	'cellt + !+
	1020 + !+
	0 swap 1020 + !+ | suma
	0 swap 1020 + !+ | shift
	1 'celln +!
	;

:resolversihaymemroia | nro -- nro
	dup 2 <<
	dup 'cellt + @ $10 nand? ( 2drop ; ) | si no es [] seguir
	drop
|	d.tos needReg
|	"lea " ,s ,TOS "," ,s

	;

::cell+ | add nro --
	| si hay mem resolver
	2 << 'cella + ! ;

::cell>> | shi nro --
	| si hay mem resolver
	2 << 'cells + ! ;

:movestack | dd --
	celln ( 1? )( 1-
		dup 2 << dup
		'cellt + @ 	5 =? ( drop
			dup 'cellv + @ 5 =? (
				pick3 pick3
				) )
		2drop ) drop ;

|-------- tipos de celdas
| T Tipo (NUMERO CONSTANTE 'STRING CODIGO DATO REGISTRO COPIA)
| M Indireccion de memoria
| ...MTTTT
|----- tipos de celdas

::pushNRO	0 newcell d.push ;
::pushCTE	1 newcell d.push ;
::pushSTR	2 newcell d.push ;
::pushCOD	3 newcell d.push ;
::pushDAT	4 newcell d.push ;
::pushVAR	4 $10 or newcell d.push ;
::pushREG	5 newcell d.push ;
::pushCPY 	6 newcell d.push ;

::cellNRO? | nro -- 1/0
	2 << 'cellt + @ $1f and
	0? ( 1 )( 0 ) nip ;

::cellREG? | nro -- nroreg
	2 << dup 'cellt + @ $1f and
	5 <>? ( 2drop -1 ; ) drop
	'cellv + @ ;

::cellMEM! | nro --
	2 << 'cellt + dup @ $10 or swap ! ;

::cellMEM? | nro --
	2 << 'cellt + @ $10 and? ( 1 )( 0 ) drop ;

|------------------------------------------
#registrosusados
#inivpcnt

|------------------------------------------
| inicia vpila como normal con USADO celdas
| de forma normal
| [esi+4] [esi] eax -- para usado=3
|------------------------------------------
::inivpila  | usado --
	inivstack
	0? ( drop ; )
	dup 'inivpcnt !
	1-
	( 1? )( 1-
		5 5 $10 or newcell
		over 2 << cell+
		d.push | [esi
		) drop
	0 5 newcell d.push | eax
	emptyreg
	5 reg! 0 reg!
	;


:cambiareg | deltaesi --

	;

::vpila2normal | --  ;transforma la pila actual a normal
	d.cnt 0? ( drop ; )
	inivpcnt over - | actual-origen
	1? ( "lea esi,[esi" ,s dup +? ( "+" ,s ) 2 << ,d "]" ,ln ) drop | corre esi

	( 1? )( 1-
|		dup d.nro
		) drop ;


|---- imprime celda
:list2str swap ( 1? )( 1- swap >>0 swap ) drop ;

:value	over 1024 + @ ;
:suma	over 2048 + @ ;
:shift	over 3072 + @ ;

:mt0 value "$%h" ,print ;			|--	0 nro 	33
:mt1 value 'syscons list2str ,s ;	|--	1 cte	XRES
:mt2 value cte + "s%h" ,print ;		|--	2 str   "hola"
:mt3 value "w%h" ,print ;			|--	3 cod  'func
:mt4 value "w%h" ,print ;			|--	4 dat  'var
:mt5 value 'sysregs list2str ,s ;	|-- 8 reg 	eax

#tiposrm mt0 mt1 mt2 mt3 mt4 mt5 0 0 0

::cell2str, | nro --
	( 2 << 'cellt + dup @
		dup $f and
		6 =? )( value nip nip nip )
	swap
	$10 and? ( "[" ,s )
	swap
	2 << 'tiposrm + @ exec
	shift 1? ( dup "*%d" ,print ) drop
	suma 1? ( dup +? ( "+" ,s ) ,d ) drop
	$10 and? ( "]" ,s )
	2drop ;


|---- celda a registro
::cell2reg, | reg cell --
	"lea " ,s
	swap 'sysregs list2str ,s
	"," ,s
	cell2str,
|	dup cellreset
|	dup cellreg
	;

|--- PILA DATO
#dpila )( 1024
#dpila> 'dpila

|--- PILA RETORNO
#rpila )( 1024
#rpila> 'rpila

::d.nro 	2 << 'dpila + @ ;
::d.cnt		dpila dpila> - 2 >> ;
::d.pop		-4 'dpila> +! dpila> @ ;
::d.pop2 	-8 'dpila> +! dpila> @+ swap @ ;
::d.pop3 	-12 'dpila> +! dpila> @+ swap @+ swap @ ;
::d.push 	dpila> !+ 'dpila> ! ;
::d.TOS		dpila> 4 - @ ;
::d.NOS 	dpila> 8 - @ ;
::d.PK2 	dpila> 12 - @ ;
::d.PK3 	dpila> 16 - @ ;
::d.PK4 	dpila> 20 - @ ;
::d.PK5 	dpila> 24 - @ ;

::d.drop	-4 'dpila> +! ;
::d.swap	dpila> 8 - >r r@+ r@+ r> 8 - !+ ! ;
::d.rot		dpila> 12 - >r r@+ r@+ r@+ swap r> 12 - !+ !+ ! ;
::d.2swap	dpila> 16 - >r r@+ r@+ swap r@+ r@+ swap r> 32 - !+ !+ !+ ! ;

::d.dup		d.TOS pushCPY ;
::d.over	d.NOS pushCPY ;
::d.pk2		d.PK2 pushCPY ; |PICK2  abc -- abca
::d.pk3		d.PK3 pushCPY ; |PICK3  abcd -- abcda
::d.pk4		d.PK4 pushCPY ; |PICK4  abcde -- abcdea
::d.2dup	d.over d.over ;	|2DUP   ab -- abab
::d.2over	d.pk3 d.pk3 ; |2OVER  abcd -- abcdab

::r.cnt		rpila> 'rpila - 2 >> ;
::r.pop		-4 'rpila> +! rpila> @ ;
::r.drop	-4 'rpila> +! ;
::r.push	rpila> !+ 'rpila> ! ;
::r.tos		rpila> 4 - @ ;

