| pilas virtuales (datos y retorno)
| para compilador
| PHREDA 2015
|------------------------------------
|^r4/dev/ide/r4-token.txt
^r4/dev/ide/r4-post.txt
^r4/lib/trace.txt

#:inivpcnt		| nivel de inicio de pila D

|-------- constantes del sistema
#syscons "XRES" "YRES" "FREE_MEM" "SYSFRAME" "XFB"
"SYSPAPER" "SYSXYM" "SYSBM" "SYSKEY" | []

|-------- Registros del CPU
#sysregs "eax" "ebx" "ecx" "edx" "edi" "esi" "ebp"
#sysregx "xmm1" "xmm2" "xmm3" "xmm4" "xmm5" "xmm6" "xmm7" "xmm8"
#sysregw "ax" "bx" "cx" "dx" "di" "si" "bp" "
#sysregb "al" "bl" "cl" "dl" "*" "*" "*"

|------ Celda de la pila
| T Tipo (NUMERO CONSTANTE 'STRING CODIGO DATO REGISTRO)
| M Indireccion de memoria
| S tiene escalaysuma***
| ..SMTTTT
|-------- tipos de celdas
#celln 0
#cellt )( 1024	| tipo
#cellv )( 1024	| valor
#cella )( 1024  | suma
#cells )( 1024  | shift
#celli )( 1024 	| info de celda

:value	over 1024 + @ ;
:suma	over 2048 + @ ;
:shift	over 3072 + @ ;

|--- PILA DATO
#dpila )( 1024
#dpila> 'dpila

|--- PILA RETORNO
#rpila )( 1024
#rpila> 'rpila

|---- pila para celdas en bloques
#vpst )( 1024
#vpst> 'vpst
#vpmem )( $3fff
#vpmem> 'vpmem

|----------------------------------------
::cellNRO? | nro -- 1/0
	2 << 'cellt + @ $1f and
	0? ( 1 )( 0 ) nip ;

::cell0? | nro -- 1/0 (1 si es 0 literal)
	2 << dup 'cellt + @ $1f and
	1? ( 2drop 0 ; ) drop
	'cellv + @ 1? ( drop 0 ; ) drop
	1 ;

::cellVal | nro -- valor
	2 << 'cellv + @ ;

::cellREG? | nro -- nroreg
	2 << dup 'cellt + @ $1f and
	5 <>? ( 2drop -1 ; ) drop
	'cellv + @ ;

::cellREGM?
	2 << dup 'cellt + @ $f and
	5 <>? ( 2drop -1 ; ) drop
	'cellv + @ ;

::cellSUM | nro -- sum
	2 << 'cella + @ ;

::cellADR? | nro -- 0/1
	2 << 'cellt + @ $10 and ;

::cellSUM? | nro -- 0/1
	2 << 'cellt + @ $20 and ;

::cellMEM! | nro --
	2 << 'cellt + dup @ $10 or swap ! ;

::cellVAR | cell -- cell -1/nrovar
	dup 2 << 'cellt + @ $1f and
	$14 <>? ( -1 nip ; ) drop
	dup 2 << 'cellv + @ ;

::cellDVAR | cell -- cell -1/nrovar
	dup 2 << 'cellt + @ $1f and
	$4 <>? ( -1 nip ; ) drop
	dup 2 << 'cellv + @ ;

::cellSTACK | cell -- -1/esi+?
	2 << dup 'cellt + @ $1f and
	$15 <>? ( 2drop -1 ; ) drop
	'cella + @ ;

|----- dpila
::d.rel		1+ 2 << dpila> swap - @ ;
::d.cnt		dpila> 'dpila - 2 >> ;
::d.pop		-4 'dpila> +! dpila> @ ;
::d.push 	dpila> !+ 'dpila> ! ;
::d.TOS		dpila> 4 - @ ;
::d.NOS 	dpila> 8 - @ ;
::d.PK2 	dpila> 12 - @ ;
::d.PK3 	dpila> 16 - @ ;
::d.PK4 	dpila> 20 - @ ;

::d.drop	d.pop drop ;

::d.swap	dpila> 8 - >r r@+ r@+ r> 8 - !+ ! ;
::d.rot		dpila> 12 - >r r@+ r@+ r@+ swap r> 12 - !+ !+ ! ;
::d.2swap	dpila> 16 - >r r@+ r@+ swap r@+ r@+ swap r> 16 - !+ !+ !+ ! ;

:newcell | valor tipo -- nro
	celln 2 << 'cellt +
	!+
	1020 + !+
	0 swap 1020 + !+ | suma
	0 swap 1020 + ! | shift
	celln
	1 'celln +!
	;

::pushNRO	0 newcell d.push ;
::pushCTE	1 newcell d.push ;
::pushSTR	2 newcell d.push ;
::pushCOD	3 newcell d.push ;
::pushDAT	4 newcell d.push ;
::pushVAR	4 $10 or newcell d.push ;
::pushREG	5 newcell d.push ;

::pushCPY | celda --
	celln 2 << 'cellt +
	swap 2 << 'cellt +
	@+ rot !+
	swap 1020 + @+ rot 1020 + !+
	swap 1020 + @+ rot 1020 + !+
	swap 1020 + @ swap 1020 + !
	celln d.push
	1 'celln +!
	;

::d.dup		d.TOS pushCPY ;
::d.over	d.NOS pushCPY ;
::d.pick2	d.PK2 pushCPY ; |PICK2  abc -- abca
::d.pick3	d.PK3 pushCPY ; |PICK3  abcd -- abcda
::d.pick4	d.PK4 pushCPY ; |PICK4  abcde -- abcdea
::d.2dup	d.over d.over ;	|2DUP   ab -- abab
::d.2over	d.pick3 d.pick3 ; |2OVER  abcd -- abcdab
::d.nip		d.swap d.drop ;
::d.4DROP	d.drop
::d.3DROP	d.drop
::d.2DROP	d.drop d.drop ;

::r.cnt		rpila> 'rpila - 2 >> ;
::r.pop		-4 'rpila> +! rpila> @ ;
::r.push	rpila> !+ 'rpila> ! ;
::r.tos		rpila> 4 - @ ;
::r.drop	r.pop d.push d.drop ;

:r.rel		1+ 2 << rpila> swap - @ ;
:r.ini 		'rpila 'rpila> ! ;

|---- imprime celda
:list2str swap ( 1? )( 1- swap >>0 swap ) drop ;

:mt0 value -? ( "(%d)" ,print ; ) "$%h" ,print ;			|--	0 nro 	33
:mt1 value 'syscons list2str ,s ;	|--	1 cte	XRES
:mt2 value "str%h" ,print ;			|--	2 str   "hola"
:mt3 value "w%h" ,print ;			|--	3 cod  'func
:mt4 value "w%h" ,print ;			|--	4 dat  'var
:mt5 value 'sysregs list2str ,s ;	|-- 8 reg 	eax
#tiposrm mt0 mt1 mt2 mt3 mt4 mt5 0 0 0

:mt5b value 'sysregb list2str ,s ;
#tiposrmb mt0 mt1 mt2 mt3 mt4 mt5b 0 0 0

:mt5w value 'sysregw list2str ,s ;
#tiposrmw mt0 mt1 mt2 mt3 mt4 mt5w 0 0 0

::,REG | nro --
	'sysregs list2str ,s ;

::,cell | nro --
	2 << 'cellt + dup @ dup $f and
	swap $10 and? ( "dword [" ,s )
	swap 2 << 'tiposrm + @ exec
	shift 1? ( "*" ,s dup ,d ) drop
	suma 1? ( +? ( "+" ,s ) dup ,d ) drop
	$10 and? ( "]" ,s )
	2drop ;

:,cellb | nro --
	2 << 'cellt + dup @ dup $f and
	swap $10 and? ( "byte [" ,s )
	swap 2 << 'tiposrmb + @ exec
	shift 1? ( "*" ,s dup ,d ) drop
	suma 1? ( +? ( "+" ,s ) dup ,d ) drop
	$10 and? ( "]" ,s )
	2drop ;

:,cellw | nro --
	2 << 'cellt + dup @ dup $f and
	swap $10 and? ( "word [" ,s )
	swap 2 << 'tiposrmw + @ exec
	shift 1? ( "*" ,s dup ,d ) drop
	suma 1? ( +? ( "+" ,s ) dup ,d ) drop
	$10 and? ( "]" ,s )
	2drop ;

:,cell2REG | cell reg --
	over cell0?
	1? ( drop nip "xor " ,s dup ,REG "," ,s ,REG ,cr ; ) drop
	"mov " ,s ,REG "," ,s ,CELL ,cr ;


::cell+ | add nro --
	| si hay mem resolver
	2 << 'cella + ! ;

::cell+! | add nro --
	| si hay mem resolver
	2 << 'cella + +! ;

::cell<< | shi nro --
	| si hay mem resolver
	| si hay suma resolver
	2 << 'cells + ! ;

::cell[] | nro --
	| si hay mem resolver
	cellMEM! ;

::cell! | valor tipo nro --
	2 <<
	'cellt + !+
	1020 + !+
	0 swap 1020 + !+ | suma
	0 swap 1020 + ! | shift
	;

|------------------
:estareg | val reg dir cell -- val reg dir
	cellREG? pick2 <>? ( drop ; ) drop
	rot drop
	dup 4 - @
	rot rot ;

| en que celda esta el registro
:REGcell | reg -- cell/-1
	5 =? ( drop $ff ; )	| esi ocupado
	6 =? ( drop $ff ; )	| ebp ocupado
	-1 swap
	'dpila ( dpila> <? )( @+ estareg ) drop
	'rpila ( rpila> <? )( @+ estareg ) drop
	drop ;

::newreg | -- reg
	0 ( dup REGcell -1 <>? )( drop 1+ ) drop
	| !!!! falta manegar cuando no hay mas registros
	;

::newRegX | -- reg ; no ecx ni edx ni eax
	1 regcell -1 =? ( drop 1 ; ) drop | ebx
	4 regcell -1 =? ( drop 4 ; ) drop | edi
	7 ( dup REGcell -1 <>? )( drop 1+ ) drop ;


|-------------------------------------------
| DEBUG: imprime pila virtual
|-------------------------------------------
:,cellp | nro --
	2 << 'cellt + dup @ dup $f and
	swap $10 and? ( "[" ,s )
	swap 2 << 'tiposrm + @ exec
	shift 1? ( "*" ,s dup ,d ) drop
	suma 1? ( +? ( "+" ,s ) dup ,d ) drop
	$10 and? ( "]" ,s )
	2drop ;

::printddvtack
	'dpila
	( dpila> <? )( @+ ,cellp ,sp ) drop
	'rpila
	rpila> <>? ( " :R " ,s )
	( rpila> <? )( @+ ,cellp ,sp ) drop
	,cr ;

::dumpcells, | -- ; imprime info celdas
|	"Nro:Read:Write:T" ,print ,cr
	0 ( celln <? )(
		dup ,cell
		dup " ; %h:" ,print
		dup 2 << 'celli + @
		dup 24 >> $ff and "%d:" ,print
		dup 16 >> $ff and "%d:" ,print
		dup 8 >> $ff and "%d:" ,print
		$ff and  "%h" ,print ,cr
		1+ ) drop
	;

|---- corre esi
:cellESI | cell deltasi --
	over cellREGM? 5 <>? ( 3drop ; ) drop | si es ESI
	neg 2 << swap Cell+! ;

:correESI | deltaesi --
	0? ( drop ; )
	"lea esi,[esi" ,s dup +? ( "+" ,s ) 2 << ,d "]" ,ln
	'dpila ( dpila> <? )( @+ pick2 cellESI ) drop
	'rpila ( rpila> <? )( @+ pick2 cellESI ) drop
	drop ;

|---------------------------
#stackuse )( 256

:printstate
	";* " ,s
	'stackuse 0 ( 8 <? )( swap
     	c@+ 1? ( pick2 2 << "[esi+%d] " ,print )
		drop swap 1+ ) 2drop
	,cr ;

|--- cambia registros en pila
:inchange | reg dest cnt 'dpila cell sum
	drop pick4 5 rot cell! 2dup ;

:changeREG | dest cell reg -- dest cell
	pick2 d.cnt 1- 'dpila | dest cell reg dest cnt 'dpila
	( dpila> <? )( swap 1- swap @+
		dup cellSTACK
		-? ( 2drop )( pick3 2 << <>? ( pick4 2 << =? ( inchange ) ) 2drop )
		) 4drop ;

:chg2stack | dest cell --
	"xchg dword [esi" ,s
	over 2 << 1? ( +? ( "+" ,s ) ,d )( drop )
	"]," ,s dup ,CELL ,cr
	dup cellREG? changeREG | dest cell reg

	5 $15 pick2 cell! swap 2 << swap cell+! ;

:mov2stack | dest cell --
	over 'stackuse + c@ 1? ( drop chg2stack ; ) drop
	"mov dword [esi" ,s
	over 2 << 1? ( +? ( "+" ,s ) ,d )( drop )
	"]," ,s dup ,CELL ,cr

	5 $15 pick2 cell! swap 2 << swap cell+! ;

|--- mueve los que son registros
:movereg
	d.cnt 1- 'dpila
	( dpila> 4 - <? )( swap 1- swap @+
		dup cellREG? 0 >=? ( drop nip mov2stack 1 ; ) 2drop
		) 2drop 0 ;

|--- mueve constantes iguales !!!! optimizacion !!!!
:movecte
	'dpila
	( dpila> <? )(
		@+ cellNRO? drop |*******
		) drop ;

|--- mueve los que quedan
:resolveADR | cnt adr cell xx -- cnt adr cell xx
	newReg pick2 over ,cell2REG
	|--- cnt adr cell xx reg
	pick2 cellSTACK 2 >> pick3 pick2 changeREG | dest cell reg
	2drop
	5 pick3 cell!
	;

:realmove | cnt adr cell -- cnt adr x x
	dup cellADR? 1? ( resolveADR ) drop
	| cnt adr cell
	pick2 swap mov2stack | dest cell
	2dup
	;

:movecell
	d.cnt 1- 'dpila
	( dpila> 4 - <? )( swap 1- swap @+
		dup cellSTACK pick3 2 <<
		<>? ( drop realmove ) 2drop
		) 2drop ;

|----
:usado | nro XX cell -- nro XX
	dup cellREGM? 5 =? ( drop
		dup cellSUM pick3 2 <<
		<>? ( 1 swap 2 >> 'stackuse + c! drop ; )
		) 2drop ;

:fillstackuse
	'stackuse d.cnt
	( 1? )( 1- 0 rot c!+ swap ) 2drop
	d.cnt 1- 'dpila
	( dpila> <? )( swap 1- swap @+
		usado ) 2drop ;

:vplast
	inivpcnt 0? ( drop ; ) drop
	"mov eax,dword [esi-4]" ,s ,cr
	0 5 d.tos cell! ;

:vpcopia2
	d.cnt 0? ( drop vplast ; ) drop
	fillstackuse
	( movereg 1? )( drop ) drop
	movecte
	movecell
	d.tos
	dup cellREG? 0? ( 2drop ; ) drop	| ya es eax!
	dup 0 ,cell2REG
	0 5 rot cell! ;


|------------------------------------------
| inicia vpila como normal con USADO celdas
| de forma normal, guarda nivel en INIVPCNT
| [esi+4] [esi] eax -- para usado=3
|------------------------------------------
:inivstack
	0 'celln !
	'dpila 'dpila> !
	'rpila 'rpila> !
	'vpst 'vpst> !
	'vpmem 'vpmem> !
	;

::inivpila | deep --
	0? ( 1 nip )
	dup 'inivpcnt !
	inivstack
	1- ( 1? )( 1-
		5 $15 newcell
		over 2 << over
		cell+ d.push 	| [esi+..
		) drop
	0 5 newcell d.push	| eax
	;

|---- transforma la pila actual a normal
::vpila2normal | --
	inivpcnt d.cnt -
	correESI			| corre esi a nuevo lugar
	vpcopia2			| copia los registros/ctes en pila
	d.cnt 'inivpcnt !	| ahora vpila tiene...
	;


|---- acomoda pila actual
::vpila2v | deep --
	1? ( -? ( ( 1? )( 1+ d.drop ) )( ( 1? )( 1- d.dup ) ) )
	drop
	d.cnt dup 'inivpcnt ! | ahora vpila tiene...
	0? ( drop ; )
	1- ( 1? )( 1-
		dup 1+ d.rel
		5 $15 pick2 cell!
		over 2 << swap cell+!
		)
	d.rel 0 5 rot cell! ;

::vpila2callV | nro --
	dic>mov @ 16 << 24 >> neg vpila2v ;

|------ acceso a celdas
::,TOS	d.tos ,cell ;
::,TOSb	d.tos ,cellb ;

::,NOS	d.nos ,cell ;
::,NOSb	d.nos ,cellb ;
::,NOSw	d.nos ,cellw ;

::,NOS2	d.pk2 ,cell ;
::,RTOS	r.tos ,cell ;

::cell2cell! | origen destino --
	2 << 'cellt +
	swap 2 << 'cellt +
	@+ rot !+
	swap 1020 + @+ rot 1020 + !+
	swap 1020 + @+ rot 1020 + !+
	swap 1020 + @ swap 1020 + ! ;

:cell2newReg
	newREG
	over cell0? 0? ( drop
		"mov " ,s dup ,REG "," ,s over ,CELL
		)( drop
		"xor " ,s dup ,REG "," ,s dup ,REG
		)
	,cr
	5 rot cell! ;

::cell2REG | cell --
	dup cellREG? 0 >=? ( 2drop ; ) drop
    cell2newReg ;

::cell2NMEM | cell --
	dup cellADR? 0? ( 2drop ; ) drop
    cell2newReg ;

::cell2REGorMEM | cell --
	dup cellREG? 0 >=? ( 2drop ; ) drop
	dup cellADR? 1? ( 2drop ; ) drop
	cell2newReg ;

::cell2REGorCTE | cell --
	dup cellNRO? 1? ( 2drop ; ) drop
	dup cellREG? 0 >=? ( 2drop ; ) drop
	cell2newReg ;


::setEAX | cell --
	0 5 rot cell! ;

::setEDX | cell --
	3 5 rot cell! ;

:noregdesde | reg --
	'dpila
	( dpila> 16 - <? )( swap 1- swap @+
		dup cellREG? 0 >=? ( drop nip mov2stack 1 ; ) 2drop
		) 2drop 0 ;

:pk2EAX | -- ; anterior a pk2 sin eax, no usar edx
	0 'dpila ( dpila> 12 - <? )(
		@+ cellREG? 0? ( rot 1+ rot rot ) drop ) drop
	0? ( drop ; ) drop | no hay eax abajo de pk2
	newRegX
	"mov " ,s dup ,REG ",eax" ,s ,nl
	'dpila ( dpila> 12 - <? )(
		@+ dup cellREG? 0? ( drop pick2 5 rot cell! )( 2drop ) ) 2drop
	"; " ,s printddvtack
	;

:nosEAX | anterior a nos sin eax, no usar edx
	0 'dpila ( dpila> 8 - <? )(
		@+ cellREG? 0? ( rot 1+ rot rot ) drop ) drop
	0? ( drop ; ) drop | no hay eax abajo de nos
	newRegX
	"mov " ,s dup ,REG ",eax" ,s ,nl
	'dpila ( dpila> 8 - <? )(
		@+ dup cellREG? 0? ( drop pick2 5 rot cell! )( 2drop ) ) 2drop
	"; " ,s printddvtack
	;

|--- ECX o constante
::cteorECX | cell --
	dup cellNRO? 1? ( 2drop ; ) drop
	dup cellREG? 2 =? ( 2drop ; ) drop
	"mov ecx," ,s dup ,CELL ,cr
	2 5 rot cell! ;

::needREGorMEM | cell --
	dup cellREG? 0 >=? ( 2drop ; ) drop
	dup cellADR? 1? ( 2drop ; ) drop
	cell2newReg ;

:needREGorCTE | cell --
	dup cellNRO? 1? ( 2drop ; ) drop
	dup cellREG? 0 >=? ( 2drop ; ) drop
	cell2newReg ;

:inverteaxreg
	d.tos d.nos "xchg " ,s ,CELL "," ,s ,CELL ,cr
	;

::nosEAXtosREGMEMfreeEDX
	d.tos cellREG? 0? ( d.nos cellREG? +? ( 2drop inverteaxreg ; ) drop ) drop
	nosEAX
	d.tos needREGorMEM
	;

:inv1eaxreg
	d.pk2 d.nos
	2dup "xchg " ,s ,CELL "," ,s ,CELL ,cr
	cell2cell! ;

:inv2eaxreg
	d.pk2 d.tos
	2dup "xchg " ,s ,CELL "," ,s ,CELL ,cr
	cell2cell! ;

::pk2EAXtosnosREGMEMfreeEDX
	d.nos cellREG? 0? ( d.pk2 cellREG? +? ( 2drop inv1eaxreg ; ) drop ) drop
	d.tos cellREG? 0? ( d.pk2 cellREG? +? ( 2drop inv2eaxreg ; ) drop ) drop
	pk2EAX
	d.nos needREGorMEM
	d.tos needREGorMEM ;

::pk2EAXnosREGMEMtosECXfreeEDX
	d.nos cellREG? 0? ( d.pk2 cellREG? +? ( 2drop inv1eaxreg ; ) drop ) drop
	d.tos cellREG? 0? ( d.pk2 cellREG? +? ( 2drop inv2eaxreg ; ) drop ) drop
	pk2EAX
	d.nos needREGorMEM
	d.tos cteorECX ;


|--- pila de estado de pila y registros para bloques

:,vp vpmem> !+ 'vpmem> ! ;
:vp@ vpmem> @+ swap 'vpmem> ! ;

:,cpcell | nro --
	2 <<
	dup 'cellt + @ ,vp
	dup 'cellv + @ ,vp
	dup 'cella + @ ,vp
	'cells + @ ,vp
	;

:cpcell@ | nro --
	2 <<
	vp@ over 'cellt + !
	vp@ over 'cellv + !
	vp@ over 'cella + !
	vp@ swap 'cells + !
	;

::vpPush | --
	vpmem> vpst> !+ 'vpst> !
	dpila> 'dpila - 2 >>
	,vp
	'dpila ( dpila> <? )(
		@+ dup ,vp ,cpcell
		) drop
	rpila> 'rpila - 2 >>
	,vp
	'rpila ( rpila> <? )(
		@+ dup ,vp ,cpcell
		) drop
	inivpcnt ,vp
	;

::vpPop | --
	-4 'vpst> +!
	vpst> @ 'vpmem> !
	'dpila 'dpila> !
	vp@
	( 1? )( 1-
		vp@ dup d.push cpcell@
		) drop
	'rpila 'rpila> !
	vp@
	( 1? )( 1-
		vp@ dup r.push cpcell@
		) drop
	vp@ 'inivpcnt !
	;

::vpPick | -- ; pop del segundo
	vpst> 8 - @ >r
	'dpila 'dpila> !
	r@+
	( 1? )( 1-
		r@+ dup d.push 2 <<
		r@+ over 'cellt + !
		r@+ over 'cellv + !
		r@+ over 'cella + !
		r@+ swap 'cells + !
		) drop
	'rpila 'rpila> !
	r@+
	( 1? )( 1-
		r@+ dup r.push 2 <<
		r@+ over 'cellt + !
		r@+ over 'cellv + !
		r@+ over 'cella + !
		r@+ swap 'cells + !
		) drop
	r@+ 'inivpcnt !
    rdrop
	;

::vpDrop | --
	-4 'vpst> +!
	vpst> @ 'vpmem> ! ;

::vpNip | --
	-4  'vpst> +!
	vpst> dup @ swap 4 - !
	;

::vpFitAll
	;