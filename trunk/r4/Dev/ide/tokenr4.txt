| token r4
| PHREDA 2013
|----------------------------------
| 0
| 1 :
| 2 ::
| 3 #
| 4 #:
| 5 |
| 6 ^
| 7 dec
| 8 hex
| 9 bin
| A fix
| B str
| C wor
| D var
| E dwor
| F dvar
| 10.. macro ; ..
|----------------------------------
^r4/lib/macrosr4.txt
^r4/dev/ide/diccr4.txt
^r4/dev/ide/tokenrun.txt
^r4/dev/ide/tokenprint.txt

#nroerror 0
#poserror 0

|---- Compila programa
:,, | n --
	tokencod> !+ 'tokencod> ! ;

:,ctesimilar | n -- d  ; buscar iguales. muy lento si son muchos!!
	'tokencte ( tokencte> <? )( @+
		pick2 =? ( drop nip 'tokencte 4+ - ; )
		drop ) drop
:,cte | n -- d
	tokencte> swap over !+ 'tokencte> ! 'tokencte - ;

:rstr | c --
	tokenmem> c!+ 'tokenmem> ! ;

:realstr | cad -- cad'
	( 1+ dup c@ 1? )(
		34 =? ( drop 1+ dup c@ 34 <>? ( drop 0 rstr ; ) )
		rstr ) rstr ;

:,str | a -- a' d
	tokenmem> swap realstr swap 'tokenmem - ;

:realcom
	( 1+ dup c@ 1? )(
		32 <? ( drop 0 rstr ; )
		rstr ) rstr ;
:,com | a -- a' d
	tokenmem> swap realcom swap 'tokenmem - ;

:realtok
	( 1+ dup c@ 1? )(
		33 <? ( drop 0 rstr ; )
		rstr ) rstr ;

:,word | a -- a' d
	tokenmem> swap realtok swap 'tokenmem - ;

:escom
	( c@+ 1? )( 14 <? ( drop 1- ; ) drop ) drop 1- ;
:escad
	( c@+ 1? )( 34 =? ( drop c@+ 34 <>? ( drop 1- ; ) ) drop ) drop 1- ;
:pasapal
	( c@+ 1? )( 33 <? ( drop 1- ; ) drop ) drop 1- ;

|------------------------------------------------------------
|---  includes
|------------------------------------------------------------
#auxstr )( 64

:esinc 	| a -- a' ; incluye codigo
	1+ dup ?include 1? ( drop ; ) drop
	'auxstr over copynom
	here 'auxstr load	| carga include
	here =? ( " no existe" 'auxstr strcat 'auxstr 'nroerror ! drop 0 ; )
	here pick2 indiceinc> !+ !+ 0 0 rot !+ !+ 'indiceinc> !
	0 swap c!+ 'here !
	pasapal ;

:includepal | str -- str'
	( dup c@ 33 <? )( 0? ( ; ) drop 1+ ) | quitar espacios
	$7c =? ( drop escom ; )		| $7c |	 Comentario
	$22 =? ( drop escad ; )		| $22 "	 Cadena
	$5e =? ( drop esinc ; )		| $5e ^  Include
	drop pasapal ;

:loadincludes | fuente --
	( includepal 0? ) drop 'poserror !
	nroerror 1? ( drop ; )
	( drop indiceinc>
		'indiceinc ( indiceinc> <? )(
			4+ @+
			( includepal 0? ) drop 'poserror !
			nroerror 1? ( 4drop ; ) drop
			8 + ) drop
		indiceinc>
		=? )
	drop ;

:realinc | str --
	mark
	here swap 1-
	esinc drop
	loadincludes
	| compilar los includes, luego liberar mem src
	empty
	;

|----------- genera token
:essistema	| str n -- str
	8 << ,, ;
:esdefe | str -- str
	,word 8 << 2 or ,, ;
:esdef | str -- str
	dup c@ $3A =? ( drop 1+ esdefe ; ) drop
	,word 8 << 1 or ,, ;
:esvare | str -- str
	,word 8 << 4 or ,, ;
:esvar | str -- str
	dup c@ $3A =? ( drop 1+ esvare ; ) drop
	dup c@
	,word 8 << 3 or ,, ;

:escom | str -- str
	,com 8 << 5 or ,, ;

:esinclude | str -- str
	,word dup 8 << 6 or ,,
	'tokenmem + realinc ;

:tiponro | -- tipon
	basen
	2 =? ( drop 9 ; )
	10 =? ( drop 7 ; )
	16 =? ( drop 8 ; )
	-1 =? ( drop 10 ; )
	drop ;
:esnro | val --
	,ctesimilar 8 << tiponro or ,, ;
:escadena | str -- str
	,str 8 << 11 or ,, ;

:espalabra
	8 << 12 or ,, ;

:esdir
	8 << 14 or ,, ;

|--- Compila saltos
#salto
#pilac )( 128	#pilac> 'pilac	|----- pila de compilador

:c.ini 'pilac 'pilac> ! ;
:c.push pilac> !+ 'pilac> ! ;
:c.pop -4 'pilac> +! pilac> @ ;
:c.cnt pilac> 'pilac - ;

:hole	     tokencod> 4 - c.push ;
:label	     tokencod> c.push ;
:holefix     tokencod> c.pop dup >r 4+ - 8 << r @ or r> ! ;
:labelfix    c.pop tokencod> 4 - dup @ rot tokencod> - 8 << or swap ! ;

|--- calculo de longitud
:finpalabra
	indicepal> 16 -
	( dup @ 1? ( 2drop ; ) drop | si tiene largo termina
		dup 8 - @ %1 nand?  )(  | si el anterior es dato termina ( :a #b dup no anda !!)
		drop
		tokencod> over 12 - @ - 2 >> over !
		32 - ) |---largo
	2drop ;

|---  Macros
:c;     c.cnt 0? ( finpalabra ) drop ; | dup 'estado !
:c(     salto 1? ( hole 1 )( label 2 ) c.push drop ;
:c)(    c.pop salto 0? ( drop
				1 =? ( drop hole c.pop holefix c.push 1 c.push ; )
			)( drop
				2 =? ( drop c.pop hole c.push 3 c.push ; ) ) drop
			")( error" 'nroerror ! 	0 ;
:c)     c.pop salto 0? ( drop
				1 =? ( drop holefix ; )
				2 =? ( drop labelfix ; )
				3 =? ( drop labelfix holefix ; ) drop
				"salto desconocido" 'nroerror ! 0 ;
			)( drop
				2 =? ( drop labelfix ; ) ) drop
			") error" 'nroerror ! 0 ;
:c[     hole label 4 c.push ;
:c]     | ** es ; el anterior token? NO-> error
		c.pop 4 <>? ( "] error" 'nroerror ! 0 nip ; ) drop
		c.pop holefix drop ; | agrega lit direccion

#amacro 'c; 'c( 'c)( 'c) 'c[ 'c]

:esmacro
	dup 15 + ,,
	7 <? ( dup 1- 2 << 'amacro + @ exec 0? ( nip ; ) )
	7 >? ( 20 <? ( 1 )( 0 ) )( 0 ) 'salto ! | despues del exec !!!
	drop
	pasapal ;

|--- busca palabra
:palabra | str -- str'/0
	( dup c@ 33 <? )(
		0? ( nip ; ) drop 1+ )	| quitar espacios
	$5e =? ( drop esinclude ; )	| $5e ^  Include
	$7c =? ( drop escom ; )		| $7c |	 Comentario
	$3A =? ( drop esdef ; )		| $3a :  Definicion
	$23 =? ( drop esvar ; )		| $23 #  Variable
	$22 =? ( drop escadena ; )	| $22 "	 Cadena
	$27 =? ( drop 1+ dup dup	| $27 ' Direccion
		?macro 1? ( 3drop
			'poserror ! 2 'nroerror !
			0 ; ) drop
		?palabra 1? ( nip esdir ; ) 2drop
		'poserror ! 1 'nroerror ! 0 ; )
	drop
	dup ?numero 1? ( drop rot drop esnro ; ) drop | numero
	dup ?fnumero 1? ( drop rot drop -1 'basen ! esnro ; ) drop | numero
	dup ?macro 1? ( esmacro ; ) drop				| macro
	dup ?palabra 1? ( nip espalabra ; ) drop		| palabra
	dup ?sistema 1? ( nip essistema ; ) drop        | sistema solo directo

 	'poserror ! 1 'nroerror ! 0 ;

:palabradef | str -- str'/0
	( dup c@ 33 <? )(
		0? ( nip ; ) drop 1+ )	| quitar espacios
	$7c =? ( drop escom ; )		| $7c |	 Comentario
	$3A =? ( drop esdef ; )		| $3a :  Definicion
	$23 =? ( drop esvar ; )		| $23 #  Variable
	$22 =? ( drop escadena ; )	| $22 "	 Cadena
	$27 =? ( drop 1+ dup dup	| $27 ' Direccion
		?macro 1? ( 3drop
			'poserror ! 2 'nroerror !
			0 ; ) drop
		?palabra 1? ( nip esdir ; ) 2drop
		'poserror ! 1 'nroerror ! 0 ; )
	drop
	dup ?numero 1? ( drop rot drop esnro ; ) drop | numero
	dup ?fnumero 1? ( drop rot drop -1 'basen ! esnro ; ) drop | numero
	dup ?macro 1? ( esmacro ; ) drop				| macro
	dup ?palabra 1? ( nip espalabra ; ) drop		| palabra
 	'poserror ! 1 'nroerror ! 0 ;


:esnrov
	;
:esmacrov
	;
:finnrosv
	;

:palabravar | str -- str'/0
	( dup c@ 33 <? )(
		0? ( nip ; ) drop 1+ )	| quitar espacios
	$7c =? ( drop escom ; )		| $7c |	 Comentario
	$3A =? ( drop esdef ; )		| $3a :  Definicion
	$23 =? ( drop esvar ; )		| $23 #  Variable
	$22 =? ( drop escadena ; )	| $22 "	 Cadena
	$27 =? ( drop 1+ dup dup	| $27 ' Direccion
		?macro 1? ( 3drop
			'poserror ! 2 'nroerror !
			0 ; ) drop
		?palabra 1? ( nip esdir ; ) 2drop
		'poserror ! 1 'nroerror ! 0 ; )
	drop
	dup ?numero 1? ( drop rot drop esnrov ; ) drop | numero
	dup ?fnumero 1? ( drop rot drop -1 'basen ! esnrov ; ) drop | numero
	dup ?macro 1? ( esmacrov ; ) drop				| macro
	dup ?palabra 1? ( nip espalabra ; ) drop		| palabra
 	'poserror ! 1 'nroerror ! 0 ;

#modo 'palabra

|------------------------------------------------------------
| a token
|------------------------------------------------------------
:tokenreset
	0 'poserror !
	0 'nroerror !
	'palabra 'modo !
	;

::str2token | adr -- error/0
	tokenreset
	( modo exec 0? ) drop
	nroerror ;

::tokenlast | adr ..
	modo exec ;

|----------- DEBUG ---------------
::dumptok
	'tokencod ( tokencod> <? )(
		@+ tokenstr print sp
		) drop ;
