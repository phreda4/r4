| Rutinas Graficas
| PHREDA 2013
|--------------------------
^r4/lib/gui.txt
^r4/lib/btn.txt
^r4/lib/trace.txt


#FBASE		8

#BPP        4
#TOLERANCE  24
#VALUES     $10
#QFULL      $100
#MASK       $f

#px #py

#ymax -1

|--------- segmentos
| ymin x delta1x ymax
|-----------------------
#segs )( $3fff
#segs> 'segs
|-----------------------
| Heap Implicit Tree
|-----------------------
#heapseg )( $fff
#heapcnt 0

:]heap | nro -- adrr
	2 << 'heapseg + ;

:heap! | nodo --
	heapcnt dup 1+ 'heapcnt !
	( 1? )(
		dup 1- 2/	| v j i
		dup ]heap @ | v j i vi
		pick3 <? ( 2drop ]heap ! ; )
		rot ]heap !	| v i
		) drop
	'heapseg ! ;

:moveDown | nodo pos --
	( heapcnt 2/ <? )(
		dup 2* 1+ 		| val pos ch1
		dup ]heap @	| val pos ch1 v1
		over 1+         | val pos ch1 v1 ch2
		heapcnt <? (
			]heap @	| val pos ch1 V1 V2
    		>? ( drop 1+ dup ]heap @ ) | val pos chm Vm
			)( drop )
		pick3 				| value pos chM vM va
		>=? ( 2drop ]heap ! ; )		| value pos chM vM
		rot over swap ]heap !	| value chM vM
		drop )
	]heap ! ;

:heap@ | -- nodo
	heapseg heapcnt
	1- ]heap @ 0 MoveDown
	heapcnt 1-
	0? ( -1 'heapseg ! )
	'heapcnt !
	;

|-------------------------

|************************************
::OP2
	'py ! 'px ! ;

|************************************
::PLINE2 | x y --
	py =? ( drop 'px ! ; )
	px py pick2 >? ( 2swap 2dup )( 2over ) | x2 y2 x1 y1
	'py ! 'px !
	sh BPP << >=? ( 4drop ; ) rot 0 <=? ( 4drop ; ) | x2 x1 y1 y2
	ymax >? ( dup 'ymax ! )		| comprueba el mayor
	>r >r FBASE << swap FBASE << 	| x1 x2
	over - r> r over -				| x1 (x2-x1) y1 (y2-y1)
	rot swap / swap					| x1 t y1
	-? ( neg over * rot + swap 0 )	| x1 t y1
	dup 16 << segs> 'segs - 4 >> or heap! | ubica en heap
	segs> !+ rot pick2 2/ + swap !+ !+
	r> swap !+ 'segs> !
	;


|--------------- COVERBUFFER
| dato - puntero
#coverbuff )( 4096
#coverbuff> 'coverbuff

| pos(12) | len(11) | cover(9) |
:getpos 20 >> $fff and ;
:getlen 9 >> $7ff and ;
:getval $1ff and ;
:setpos 20 << ;
:setlen 9 << ;

:inicover | --
	'coverbuff >r
	sw 1+ setlen r!+ 0 r!+
	r> 'coverbuff> ! ;

|------------------------------------------------------
:cover.busca | pos adr -- pos  adr'
	( dup 4+ @ 1? )(	| pos adr1 adr2
		dup @ getpos pick3
		>? ( 2drop ; ) drop
		nip ) drop ;

:insert1 | adr -- adr
	dup 4+ @ coverbuff> 4+ !
	coverbuff> over 4+ !
	8 'coverbuff> +! ;

:insert2 | adr -- adr
	dup 4+ @ coverbuff> 12 + !
	coverbuff> over 4+ !
	coverbuff> 4+ dup 4+ swap !
	16 'coverbuff> +! ;

:cover.insp | valor pos adr -- adr'
	>r
	r @ getlen
	1 =? ( 2drop r +! r> 4+ @ ; )
	r @ getpos | v p largo pos
	pick2 =? ( 2drop |--- inicio de segmento
		r insert1
		@ dup $fff001ff and $200 or rot drop rot + r!+
		r> @ >r
		$100000 + $200 - r !
		r> ; )
	+ 1- over =? ( 2drop |--- fin de segmento
		r insert1
		@ dup $200 - r!+ r> @ >r
		getval rot + swap setpos or 1 setlen or r!+
		r> @ ; )
	1+
	r insert2 @ | val pos posf v
	dup $fff001ff and pick3 pick2 getpos - setlen or r!+ r> @ >r
   	getval	| valor pos posf valf
	pick3 over + pick3 setpos or 1 setlen or r!+ r> @ >r
	rot 1+	| valor posf valf pos
	rot over - setlen swap setpos or | valor
	or nip r ! r> ;

:cover.insl | valor largo pos adr -- adr'
	rot 1 =? ( drop cover.insp ; )
	swap >r swap | valor largo pos
	r @ getpos over
	=? (  |--- empieza igual
		r @ getlen | valor largo pos posv largov
		pick3 >? ( |-- ocupa menos
			r> insert1 >r nip | valor largo pos largov
			pick2 - setlen
			pick2 pick2 + setpos or
			r @ getval or
			coverbuff> 8 - !	| valor largo pos
			rot r @ getval + 	| largo pos v+v
			rot setlen or swap setpos or r> !
			coverbuff> 8 - ; )
		pick3 <? ( |--- ocupa mas
			nip r @ pick4 + r!+	| valor largo pos largov
			rot over -			| valor pos lv len-lv
			rot rot +			| valor largo pos
			r> @ cover.insl ; )
    	4drop r @ + r!+ r> @ ; ) |-- ocupa igual
	|--- empieza adentro
	r @ getlen + | valor largo pos posf
	pick2 pick2 +
	>? ( |-- ocupa menos
		r insert2 @ getval
		r @ $fff001ff and pick3 r @ getpos - setlen or r!+ r> @ >r
		| valor largo pos posf vv
		pick4 over + pick4 setlen or pick3 setpos or r!+ r> @ >r
		| valor largo pos posf vv
		>r >r + r>  | valor len+pos posf
		over - setlen swap setpos or r> or r !
		drop r> ; )
	pick2 pick2 +
	<? ( |-- ocupa mas
		r insert1 @ getval | valor largo pos posf vv
		r @ $fff001ff and pick3 r @ getpos - setlen or r!+ r> @ >r
			| valor largo pos posf vv
		pick4 + over pick3 - setlen or pick2 setpos or r!+
		| valor largo pos posf
		rot rot + over -
		swap r> @
		cover.insl ; )
	|--- ocupa hasta
	r insert1 @ getval | valor largo pos posf vv
	r @ $fff001ff and pick3 r @ getpos - setlen or r!+ r> @ >r
	nip rot setlen rot setpos or >r + r> or r!+ r> @
	;

:dumpoli
	0 'segs ( segs> <? )(
		swap dup "%d) " print 1+ swap
		@+ "ymin %d " print
		@+ "x %d " print
		@+ "deltax %d " print
		@+ "ymax %d " print cr
		) 2drop
|	heapcnt ( 1? )( 1-
|		heap@ dup 16 >> swap $ffff and "%d %d-" print
|		) drop
	cr
	;

:coverpixels | xb xa adr -- adr
	>r
    over BPP >> 0 <? ( 3drop r> ; )
	over BPP >> sw >=? ( 4drop r> ; )
	r> cover.busca >r
	| xb xa x1 x0
	over =? ( nip rot MASK and rot MASK and - swap r> cover.insp ; )
	| xb xa x1 x0
	0 >=? ( rot MASK and VALUES swap - over r> cover.insp >r 1+ sw >=? ( 3drop r> ; )
		)( drop nip 0 rdrop 'coverbuff >r )
	| xb x1 x0
	swap sw >? ( sw pick2 - )( dup pick2 - ) | xb x0 x1 largo
	0 >? ( rot VALUES rot rot r> cover.insl >r )( drop nip ) | xb x1
	sw <? ( swap MASK and swap r> cover.insp ; )
	2drop >r ;


|------------------- llenadores
:solidofill
	( 1? )( 1- $ff00 px!+ ) drop ;
|	( 1? )( 1- col px!+ ) drop ;
:solidoalpha
	swap ( 1? )( 1- $ff px!+ ) 2drop ;
|	swap ( 1? )( 1- over mixcolor px!+ ) 2drop ;

:runlencover
|	'coverbuff
|	dup 4+ @ | a0 a1
|	( dup 4+ @ 1? )( rot drop ) 2drop
|	0 swap 4+ !

|	'coverbuff (
|		@+ dup getlen swap getval
|		"%d %d " print
|		@ 0? ) drop cr ;

	0 over BPP >> setxy
	'coverbuff (
		@+ dup getlen swap getval
		QFULL =? ( drop solidofill )( 1? ( solidoalpha )( drop px+! ) )
		@ 0? ) drop ;

|-----------------------
#activos )( 1024
#activos> 'activos

:dumpact
	rojo "*" print
	'activos ( activos> <? )(
		@+ 4+ @ "%d " print
		) drop cr ;

:fillcover
	'coverbuff >r
	'activos ( activos> 4 - <? )(
		@+ 4+ @ FBASE >>
		swap @+ 4+ @ FBASE >>
		rot
		r> coverpixels >r

		) drop
	rdrop ;

:-activos	| --
	'activos 'activos> ! ;

:activosort | v x t1 --
	( 'activos >? )( 4 -		| v x t1
		dup @ 				| v x t1 n1
		dup 4+ @			|  v x t1 n1 nx
		pick3 <? ( 2drop nip 4+ ! ; ) drop
		| v x t1 v1
		over 4+ ! )
	nip ! ;

:activos!+ | v --	; agrega ordenado
	dup 4+ @ 	| v x
	activos> 	| v x t1
	dup 4+ 'activos> !
	activosort ;

:activosresort | nodo seg -- nodo	; incrementa y ordena
	dup 4+ @+ swap @ +	| nodo seg newx
	dup pick2 4+ !		| nodo seg newx
	pick2				| nodo seg newx nodo
	activosort ;

:advanceline
	'activos ( activos> <? )(
		dup @ activosresort 4+ ) drop ;

:deletecopy | nodoa --
	dup 4+ 	| en desde
	( activos> <? )(
		@+ dup 12 + @	| en desde seg yfin
		pick4 >? ( drop rot !+ swap )( 2drop )
		) drop
	'activos> ! ;

:deleteline
	'activos ( activos> <? )(
		dup @ 12 + @ pick2 =? ( drop deletecopy ; ) drop
		4+ ) drop ;

|-----------------------
:endpoli
	'segs 'segs> ! -1 'ymax ! 0 'heapcnt ! ;

:newpoli
	dumpoli
	ymax -? ( drop endpoli ; ) sh BPP << >? ( sh BPP << 'ymax ! ) drop
	-activos
	heapseg 16 >> dup | newy ymin
|	0 over BPP >> setxy
	( ymax <? )(
|		trace
		inicover
|		VALUES ( 1? )( 1- >r

    	( over =? )( nip	| agrega nuevos ordenados
			heap@ $ffff and 4 << 'segs + activos!+
           	heapseg 16 >> swap )
		fillcover
        1+
		|  heapdel =? ( ( heapdel@ drop heapdel <>? ) deleteline )
		deleteline
		advanceline

|		r> ) drop

		runlencover
	dumpact

		) 2drop

	endpoli	;

:op3
	BPP << swap BPP << swap op2 ;
:pline3
	BPP << swap BPP << swap pline2 ;

:poligon
	xc w - yc h - op3
	xc w + yc h - pline3
	xc w + yc h +  pline3
	xc w - yc h + pline3
	xc w - yc h - pline3
	newpoli
	;

:main
	33
	show clrscr
		verde
		dup "%d " print cr
|		50 50 op3 xymouse pline3
|		xymouse swap pline3
|		300 90 pline3
|		rand $fff and rand $fff and pline2
|		rand $fff and rand $fff and pline2
|		50 50 pline3 newpoli
		cyan
|		50 50 op xymouse line
|		xymouse swap line
|		300 90 line 50 50 line

		verde
		xymouse pos
		40 40 dim poligon

		cflecha
		'exit >esc<
		;

: main ;

