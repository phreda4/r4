| Editor de Voxels
| PHREDA 2014
|-----------------------------
^r4/lib/gui.txt
^r4/lib/sort.txt
^r4/lib/bsearch.txt
^r4/lib/morton.txt

^r4/lib/trace.txt

#sidevox 256
#DEEPVOX 8

#paleta )( 1024

#xmin #ymin #zmin #xmax #ymax #zmax

#xcam 0 #ycam 0 #zcam 2048

#curx 0 #cury 0 #curz 0

#memvox

#memvox>

#octre
#octre>
#pixels

|---- archivo a grabar
#$octree
#$pixels
#$end

#bith	| bitmask hijos
#padre	| de que padre
#levels )( 1024
#level>

|----------------
:clearvox
	memvox 'memvox> ! ;

:vox-cnt-mem | -- cnt mem
	memvox memvox> over - 3 >> 1+ swap ;

:vox! | c x y z --
	mortonlut memvox> !+ !+ 'memvox> ! ;

:vox@ | x y z -- c
	mortonlut vox-cnt-mem binsearch
	0? ( -1 nip ; ) 4+ @ ;

:sortvox
	vox-cnt-mem shellsort ;

:dumpvox
	memvox ( memvox> <? )(
		@+ "%h " print @+ "%h" print cr
		) drop ;

|------------ construye octree

:,oc | val --
	octre> !+ 'octre> ! ;

#colores 0 0 0 0 0 0 0 0
#colores>

#sumr #sumg #sumb
:promediocol | -- rgb
	0 'sumr ! 0 'sumg ! 0 'sumb !
	'colores ( colores> <? )(
		@+
		dup $ff and 16 << 'sumb +!
		dup $ff00 and 8 << 'sumg +!
		$ff0000 and 'sumr +!
		) drop
	colores> 'colores - 2 >> 1.0 swap /
	sumr over *. $ff0000 and
	sumg pick2 *. 8 >> $ff00 and or
	sumb rot *. 16 >> $ff and or
	;

:nodecolor+ | node -- node+ color
	memvox> <? ( @+ ; ) @+ 8 >> ;

:oct2!+
	padre ,oc
	promediocol 8 << bith or ,oc ;

:level!+
	octre> level> !+ 'level> ! ;

:ininode | nodo -- nodo+			| inicio de nivel
	@+ dup 3 >> 'padre !
	$7 and place 'bith !
	nodecolor+ 'colores !+ 'colores> ! ;

:nextnode | nodo -- nodo+
	@+
	dup 3 >> padre =? ( drop $7 and place bith or 'bith ! nodecolor+ colores> !+ 'colores> ! ; )
	oct2!+
	'padre ! $7 and place 'bith !
	nodecolor+ 'colores !+ 'colores> !
	;

:collectnode | end start --
	level!+
	ininode
	( over <? )( nextnode ) 2drop
	oct2!+
	level!+ ;

:,levelnode |  hasta desde --
	( over <? )(
		4+ @+ $ff and ,oc
		) 2drop ;

:calcdir | suma adr --- suma adr+
	dup @	 		| suma adr valor
	dup popcnt >r
	pick2 8 << or swap !+
	swap r> + swap
	;

:,levelcolor |  hasta desde --
	( over <? )(
		4+ @+ 8 >> ,oc
		) 2drop ;

:buildoctree | --
	memvox> dup 'octre ! 'octre> !
	'levels 'level> !
	|--- calcula hijos
	memvox> memvox collectnode
	'levels DEEPVOX 1-
	( 1? )( 1- swap
		@+ swap @+ rot collectnode
		swap ) 2drop

	|--- graba octree real
    octre> '$octree !
	level> ( 'levels >? )( 8 -
		dup 4+ @ over @
		,levelnode
		 ) drop
	1 $octree ( octre> <? )( calcdir ) 2drop
    octre> '$pixels !
	level> ( 'levels >? )( 8 -
		dup 4+ @ over @
		,levelcolor
		 ) drop
	memvox ( memvox> <? )(
		4+ @+ ,oc ) drop
	$pixels $octree - ,oc
	octre> '$end !
	$pixels 'pixels !
	;

|----------- busca masa
#nodo

:nexto | now value -- newa
	dup rot 1- and popcnt swap 8 >> + ;

:binhit | x y z -- x y z m
	pick2 pick2 pick2 mortonlut $octree

	over 21 >> $7 and place swap @
	over nand? ( 3drop 128 ; )
	nexto 2 << $octree +
	over 18 >> $7 and place swap @
	over nand? ( 3drop 64 ; )
	nexto 2 << $octree +
	over 15 >> $7 and place swap @
	over nand? ( 3drop 32 ; )
	nexto 2 << $octree +
	over 12 >> $7 and place swap @
	over nand? ( 3drop 16 ; )
	nexto 2 << $octree +
	over 9 >> $7 and place swap @
	over nand? ( 3drop 8 ; )
	nexto 2 << $octree +
	over 6 >> $7 and place swap @
	over nand? ( 3drop 4 ; )
	nexto 2 << $octree +
	over 3 >> $7 and place swap @
	over nand? ( 3drop 2 ; )
	nexto 2 << $octree +
	swap $7 and place swap @
	over nand? ( 2drop 1 ; )
	nexto 'nodo ! 0 ;

|----------- graficacion
#rx
#ry
:freelook
	xymouse
	sh 2/ - 7 << swap
	sw 2/ - neg 7 << swap
	neg mrotx mroty ;

:drawp | x y z ---
	project3d |2dup op line ;
	-? ( 2drop ; ) sh >=? ( 2drop ; )
	swap -? ( 2drop ; ) sw >=? ( 2drop ; ) swap
	setxy ink@ px!+ ;

:3dop project3d op ;
:3dline project3d line ;

|---- dibujos de grillas
:drawboxz | z --
	-$1ff -$1ff pick2 3dop
	$1ff -$1ff pick2 3dline
	$1ff $1ff pick2 3dline
	-$1ff $1ff pick2 3dline
	-$1ff -$1ff rot 3dline ;

:drawboxy | y --
	-$1ff over -$1ff 3dop
	$1ff over -$1ff 3dline
	$1ff over $1ff 3dline
	-$1ff over $1ff 3dline
	-$1ff swap -$1ff 3dline ;

:drawboxx | x --
	dup -$1ff -$1ff 3dop
	dup $1ff -$1ff 3dline
	dup $1ff $1ff 3dline
	dup -$1ff $1ff 3dline
	-$1ff -$1ff 3dline ;

:drawlinez | x1 x2 --
	2dup -$1ff 3dop $1ff 3dline ;

:draw3dbox
	$707070 ink
	-$1ff drawboxz
	$1ff drawboxz
	-$1ff -$1ff drawlinez
	$1ff -$1ff drawlinez
	$1ff $1ff drawlinez
	-$1ff $1ff drawlinez ;


|--------------------------
:drawplanexbox | x y --
	0 ( sidevox 2/ <? )(
		pick2 pick2 setxy
		0 ( sidevox 2/ <? )(
			curx pick2 pick2
			vox@ -1 =? ( 1 px+! drop )( px!+ )
			1+ ) drop
		swap 1+ swap 1+ ) 3drop
	;
|--------- ortho vistas
:getcolor
	nodo 2 << pixels + @ ;

:rayx | xi y z -- color
	rot	| y z x
	( 256 <? )( rot rot | x y z
		binhit 0? ( 4drop getcolor ; )
		>r rot r> + )
	3drop 0 ;

:tracexplane | x y --
	0 ( sidevox <? )(
		pick2 pick2 setxy
		0 ( sidevox <? )(
			0 pick2 pick2 rayx px!+
			1+ ) drop
		swap 1+ swap 1+ ) 3drop
	;

:rayy | x yi z -- color
	swap | x z y
	( 256 <? )( swap | x y z
		binhit 0? ( 4drop getcolor ; )
		rot + )
	3drop 0 ;

:traceyplane | x y --
	0 ( sidevox <? )(
		pick2 pick2 setxy
		0 ( sidevox <? )(
			over 0 pick2 rayy px!+
			1+ ) drop
		swap 1+ swap 1+ ) 3drop
	;

:rayz | x y zi -- color
	( 256 <? )(
		binhit 0? ( 4drop getcolor ; )
		+ )
	3drop 0 ;

:tracezplane | x y --
	0 ( sidevox <? )(
		pick2 pick2 setxy
		0 ( sidevox <? )(
			over over 0 rayz px!+
			1+ ) drop
		swap 1+ swap 1+ ) 3drop
	;

:repetidos | elimina repetidos
	sortvox
	memvox >r
	r@+ 4 r+ memvox 8 +
	( memvox> <? )(	| prevval nextdir
		@+			| prevval nextdir+ nextval
		pick2 =? ( drop 4+ )(
			rot drop	| nextdir+ nextval
			dup r!+ swap
			@+ r!+ )
		) drop
	r> 'memvox> !
	;

|------------- load import
:loadmodel
	memvox
	"media/3dm/castle.3dm"
	load 'memvox> !

| escala----de 1024 a 256
	memvox ( memvox> <? )( dup @ 6 >> swap !+ 4+ ) drop

	repetidos
	;

:testmodel
	sidevox ( 1? )( 1-
		$ff 0 0 pick3 vox!
		$ff00 0 pick2 0 vox!
		$ff0000 over 0 0 vox!
		) drop
	$ffffff 0 0 0 vox!
	repetidos
	;


:randvox
|	1000 ( 1? )( 1-
|		$ff rand $ff and rand $ff and rand $ff and vox!
|		) drop
	$ff00 0 0 0 vox!
	$ff00 0 0 1 vox!
	$ff 1 0 0 vox!
	$ff 1 0 1 vox!
	$ff0000 0 1 0 vox!
	$ff0000 0 1 1 vox!
	repetidos
	;

|--------------------------
:memory
	mark
	here dup 'memvox ! 'memvox> !
	;

:main
	loadmodel
|	testmodel
|	randvox
	buildoctree

	4
	show clrscr verde
		dup ":r%d " print cr
		sidevox deepvox "profundidad:%d lado:%d " print
		memvox> memvox - 3 >> "puntos: %d " print
		octre> octre - 2 >> "nodos: %d " print
		cr

|		curz cury curx "%d %d %d" print cr
|		dumpvox


|		omode
|		freelook
|		xcam ycam zcam mtrans
|		draw3dbox

|		40 40 drawplanexbox

		40 40 traceyplane
|		290 40 tracexplane
|		530 40 tracezplane

|		[ -0.01 'zcam +! ; ] <up>
|		[ 0.01 'zcam +! ; ] <dn>

		[ 4 'curx +! ; ] <up>
		[ -4 'curx +! ; ] <dn>

		[ 1 'cury +! ; ] <le>
		[ -1 'cury +! ; ] <ri>

		[ 1 'curz +! ; ] <pgup>
		[ -1 'curz +! ; ] <pgdn>

		[ loadmodel ; ] <f1>
		'exit >esc< ;

: memory main ;
