| genera octree de lista ordenada de morton vertices
| PHREDA 2012
|-----------------------------
^r4/lib/gui.txt
^r4/lib/fontj.txt
^r4/lib/trace.txt
^r4/lib/sort.txt
^r4/lib/bsearch.txt
^r4/lib/morton.txt

#3dmfile 0 0	| 3dm file 'adr cnt

#xcam 0 #ycam 0 #zcam 2048
#xmin #ymin #zmin #xmax #ymax #zmax

:load3dm | "" 'var --
	>r here dup r !
	swap load dup 'here !
	r@+ - 3 >> r> !
	;

|----------- graficacion
:freelook
	xymouse
	sh 2/ - 7 << swap
	sw 2/ - neg 7 << swap
	neg mrotx
	mroty ;

:drawp | x y z ---
	project3d |2dup op line ;
	-? ( 2drop ; ) sh >=? ( 2drop ; )
	swap -? ( 2drop ; ) sw >=? ( 2drop ; ) swap
	setxy
	ink@ px!+
	;

#nodoa 0

:drawpc | '3do --
	@+ >r @
	( 1? )( 1-
		r nodoa =? ( blanco )( azul ) drop
		r@+ invmorton3d drawp
		4 r+ ) drop
	rdrop ;


:drawp2
	project3d
	2dup op
	over 1+ over line
	over 1+ over 1+ line
	over over 1+ line
	line ;

:drawpcf | '3do --
	@+ >r @
	200000 >? ( 200000 nip )
	( 1? )( 1-
		r@+ r@+ ink
		invmorton3d drawp
		) drop
	rdrop ;

:3dop project3d op ;
:3dline project3d line ;

|-------- dibujo octree
#xc #yc #zc
#size

:drawz | z --
	xc size - yc size - pick2 3dop
	xc size + yc size - pick2 3dline
	xc size + yc size + pick2 3dline
	xc size - yc size + pick2 3dline
	xc size - yc size - rot 3dline ;

:drawl | x1 x2 --
	2dup zc size - 3dop zc size + 3dline ;

:box3d
	zc size - drawz zc size + drawz
	xc size - yc size - drawl xc size + yc size - drawl
	xc size + yc size + drawl xc size - yc size + drawl ;

|-------------- muestra oc de 1 punto
:+movx
	1 and? ( size )( size neg ) 'xc +!
	2 and? ( size )( size neg ) 'yc +!
	4 and? ( size )( size neg ) 'zc +!
	drop ;

:drawtree | nro shift --
	size 2/ 'size !
	2dup >> $7 and | nro shift val
	+movx box3d
	3 - 0? ( 2drop ; )
	drawtree ;

:showpoint | adr --
	0? ( drop ; ) @
	0 'xc ! 0 'yc ! 0 'zc !
	$1ff 'size ! box3d
	27 drawtree ;

|------------ construye octree
#inisor | inicio de puntos ordenados
#vertices | cantida

#octre
#octre>

#arroc )( $ffffff | array de nodos
#arroc> 'arroc
#arroc< 'arroc

#indexoc | indice actual

#octomas 0 0 0 0 0 0 0 0

|---------- arreglo circular
:cntoc | -- cnt
	arroc< arroc> - ;

:pushoc | shift ini fin --
	arroc> 'arroc> 12 - >=? ( 'arroc nip )
	!+ !+ !+ 'arroc> !
	1 'indexoc +! ;

:getoc | -- fin ini ahift
	arroc< 'arroc> 12 - >=? ( 'arroc nip )
	>r r@+ r@+ r@+ r> 'arroc< ! ;

|--------------------------
:,oc | val --
	octre> !+ 'octre> ! ;

:fillmass | fin ini shift --
	0 0 0 0 0 0 0 0 'octomas
	!+ !+ !+ !+ !+ !+ !+ !
	pick2 3 << inisor +
	pick2 3 << inisor +
	( over <? )( | fin ini shift fina nowa
		@+ pick3 | mask fina nowa morton
		>> $7 and 2 << 'octomas +
		1 swap +!
		4+ )
	2drop ;

:buildbit | -- 8bitchild
	0 'octomas $1
	( $ff and 1? )(
		swap @+ 1? ( drop rot pick2 or rot rot )( drop )
		swap 2* ) 2drop ;

:buildnext
	getoc				| fin ini shift
	fillmass rot drop	| ini shift
	3 - -? ( 2drop $ff00 ,oc ; ) | grabo el color!!
	buildbit						| ini shift bitmask
	| si es 0 no lo agrego en el anterior nivel

|----	calculo de primer hijo
	indexoc 		| absoluto
	|octre> octre - 2 >> - | relativo
	8 <<
	over or
	pick2 0? ( drop $80000000 or )( drop )
	,oc		| graba nodo interno
	over 0? ( 4drop ; ) drop
	'octomas >r				| ini shift bit
	rot dup r@+ + rot 		| shift ini fin bitmask
	( 1? )(
		1 and? ( pick3 pick3 pick3 pushoc )
		rot drop
		swap dup r@+ +		| shift bitmask ini fin
		rot 2/ ) rdrop
	4drop ;

:buildoctree | 'lista --
	@+ 'inisor ! @ 'vertices !
	here 'octre !
	octre 'octre> !	| mem de nodos
	0 'indexoc !
	'arroc  dup 'arroc> ! 'arroc< !	| array de nodos
	27 0 vertices pushoc
	( cntoc 1? )( drop
		buildnext
		) drop
	octre> 'here !
	;

|---- utils
#tpopcnt (
    0 1 1 2 1 2 2 3 1 2 2 3 2 3 3 4
    1 2 2 3 2 3 3 4 2 3 3 4 3 4 4 5
    1 2 2 3 2 3 3 4 2 3 3 4 3 4 4 5
    2 3 3 4 3 4 4 5 3 4 4 5 4 5 5 6
    1 2 2 3 2 3 3 4 2 3 3 4 3 4 4 5
    2 3 3 4 3 4 4 5 3 4 4 5 4 5 5 6
    2 3 3 4 3 4 4 5 3 4 4 5 4 5 5 6
    3 4 4 5 4 5 5 6 4 5 5 6 5 6 6 7
    1 2 2 3 2 3 3 4 2 3 3 4 3 4 4 5
    2 3 3 4 3 4 4 5 3 4 4 5 4 5 5 6
    2 3 3 4 3 4 4 5 3 4 4 5 4 5 5 6
    3 4 4 5 4 5 5 6 4 5 5 6 5 6 6 7
    2 3 3 4 3 4 4 5 3 4 4 5 4 5 5 6
    3 4 4 5 4 5 5 6 4 5 5 6 5 6 6 7
    3 4 4 5 4 5 5 6 4 5 5 6 5 6 6 7
    4 5 5 6 5 6 6 7 5 6 6 7 6 7 7 8 )

:popcnt | nro -- cnt
	'tpopcnt + c@ ;

#tplace  $01 $02 $04 $08 $10 $20 $40 $80

:place | nro -- pl
	2 << 'tplace + @ ;

|---- construye octree metodo 2
| desde morton3d de 10bits por dim

#bith	| bitmask hijos
#padre	| de que padre
#levels )( 1024
#level>

:level!+	octre> level> !+ 'level> ! ;
:oct!+		padre ,oc bith dup popcnt 8 << or ,oc ;

:iniacc | nodo --			| inicio de nivel
	dup 3 >> 'padre !
	$7 and place 'bith ! ;

:nextacc | nodo --
	dup 3 >> padre =? ( drop $7 and place bith or 'bith ! ; )
	oct!+
	'padre ! $7 and place 'bith ! ;

:collect | end start --
	level!+
	@+ iniacc 4+
	( over <? )( @+ nextacc 4+ ) 2drop
	oct!+ level!+ ;	| fin de nivel

:buildoctree2 | '3dm --
	@+ 'inisor ! @ 'vertices !
	here dup 'octre ! 'octre> !
	'levels 'level> !
	inisor dup vertices 3 << + swap collect
	'levels 9
	( 1? )( 1- swap
		@+ swap @+ rot collect
		swap ) 2drop
	octre> 'here ! ;


|--------------------------------
| baja un dimension
:reducevox | 'lista --
	@+ 'inisor ! @ 'vertices !
	inisor vertices ( 1? )( 1- swap
		dup @ 3 >> swap !+ 4+
		swap ) 2drop ;

|-----------------------------
:optoctree
	;


:sumalevel | acc lev hasta desde --
	( over <? )( >r
		pick2 r!+
		rot r@+ 8 >> +
		rot rot r>
		) 2drop ;      7

:,level |  hasta desde --
|	2dup - 3 >> "%d ." print
	( over <? )(
		@+ swap @+ $ff and rot 8 << or
		,
|		"%h " print
		) 2drop
|	cr
	;

:saveoctree
	|.... acumula
	1 level> ( 'levels >? )( 8 -
		dup 4+ @ over @ sumalevel
		 ) 2drop

	mark |.... graba
	level> ( 'levels >? )( 8 -
		dup 4+ @ over @ ,level
		 ) drop

	inisor vertices ( 1? )( 1- swap
		4+ @+ , swap ) 2drop

	"media/3do/castle.3do" savemem
	empty
	;

:showoc
	show clrscr
		verde
		saveoctree
		'exit >esc< ;


|--------------------------
:main
|	"media/3dm/test.3dm"

	"media/3dm/castle.3dm"
|	"media/3dm/armadillo.3dm"
|	"media/3dm/bunny.3dm"
|	"media/3dm/xyzrgb_statuette.3dm"
|	"media/3dm/dragon.3dm"
|	"media/3dm/sib-edb7.3dm"
	'3dmfile load3dm

	4
	show clrscr verde
		dup ":r%d F1-BUILD" print cr
		vertices "Puntos: %d " print
		vertices 3 << "mem:%d " print
		cr
		octre> octre - 3 >> "Octree: %d " print
		octre> octre - 1 >> vertices 2 << + "mem:%d " print
		cr

		'levels ( level> <? )(
			@+ swap @+ rot - 3 >>
			"%h " print cr allowchome ) drop

		omode
		freelook
		xcam ycam zcam mtrans

		azul nodoa showpoint

		'3dmfile drawpcf

		[ nodoa 0? ( 3dmfile nip )( 8 + ) 'nodoa ! ; ] <le>
		[ nodoa 0? ( 3dmfile nip )( 8 + ) 'nodoa ! ; ] <ri>

		[ -0.01 'zcam +! ; ] <up>
		[ 0.01 'zcam +! ; ] <dn>

		[ '3dmfile buildoctree2 ; ] <f1>
		[ saveoctree ; ] <f2>
		[ '3dmfile reducevox ; ] <f3>
		'exit >esc< ;

: mark main ;
