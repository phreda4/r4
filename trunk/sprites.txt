| Sprites vectoriales
| PHREDA
|---------------------------------
^libgraf.txt
^libtrig.txt

#fc 
#ya #xa
#yo #xo

|---------- Sprite
:c0 drop ; | control
:c1 >xy op ;
:c2 >xy line ;
:c3 >xy fc 0? ( >r cp )( >r curve ) r> not 'fc ! ;
:pcomp
	xa xo =? ( ya yo =? ( 2drop ; ) )( ya ) op xo yo
	fc 0? ( drop pline )( drop pcurve ) ;
:fdib	pcomp poli
:cdib	0 'fc ! xo yo 'ya !+ ! ;
:c4 fdib 4 >> ink ;
:c5 pcomp >xy 2dup 'yo !+ ! op ;
:c6 >xy 2dup pline 'ya !+ ! ;
:c7 >xy fc 0? ( >r 2dup cp )( >r 2dup pcurve ) 'ya !+ ! r> not 'fc ! ;
#comand c0 c1 c2 c3 c4 c5 c6 c7
::sprite | adr --
	cdib ( @+ 1? )( dup $7 and 2 << 'comand + @ exec ) 2drop fdib ;

|--------- R sprite
#cosa #sina | para rotar
:r>xy
	d>xy over sina * over cosa * + 16 >> h * 14 >> yc + >r
	swap cosa * swap sina * - 16 >> w * 14 >> xc + r> ;
:rc1 r>xy op ;
:rc2 r>xy line ;
:rc3 r>xy fc 0? ( >r cp )( >r curve ) r> not 'fc ! ;
:rc5 pcomp r>xy 2dup 'yo !+ ! op ;
:rc6 r>xy 2dup pline 'ya !+ ! ;
:rc7 r>xy fc 0? ( >r 2dup cp )( >r 2dup pcurve ) 'ya !+ ! r> not 'fc ! ;
#rcomand c0 rc1 rc2 rc3 c4 rc5 rc6 rc7
::rsprite | adr ang --
	dup cos 'cosa ! sin 'sina !
	cdib ( @+ 1? )( dup $7 and 2 << 'rcomand + @ exec ) 2drop fdib ;

:sprang | ang --
	 dup cos 'cosa ! sin 'sina ! ;
:sprdrawr
	cdib ( @+ 1? )( dup $7 and 2 << 'rcomand + @ exec ) 2drop fdib ;


#tipoant

::spr.clear | 'spr --
	dup >r mem
	( r@+ 1? )(	| adr valor
		swap !+ ) swap !
	rdrop
	>r mem ( @+ 1? )( r!+ ) r> ! drop ;

|------ Ajuste de dimenciones
#:spr.miy #:spr.mix #:spr.may #:spr.max

::spr.stat | 'spr --
|	dup spr.clear
	dup @ d>xy 2dup 'spr.miy !+ !+ !+ !
	( @+ 1? )(
		$3 and? ( d>xy
			spr.miy <? ( dup 'spr.miy ! ) spr.may >? ( dup 'spr.may ! ) drop
			spr.mix <? ( dup 'spr.mix ! ) spr.max >? ( dup 'spr.max ! ) drop
			)( drop )
		 )
	2drop  ;

#sumax #sumay

::spr.center | adr --
	spr.miy spr.may + 2/ neg 'sumay !
	spr.mix spr.max + 2/ neg 'sumax !
	( dup @ 1? )(
		$3 and? ( dup d>xy sumay + swap sumax + swap xy>d swap $7 and or swap !+
			)( drop 4+ )
		) 2drop ;

#escala

::spr.< | adr --
	$3fff spr.may spr.miy - spr.max spr.mix - max / 'escala !
	( dup @ 1? )(
		$3 and? ( dup d>xy escala * swap escala * swap xy>d swap $7 and or swap !+ )( drop 4+ )
		) 2drop ;

::spr.> | adr --
	( dup @ 1? )(
		$3 and? ( dup d>xy 2/ swap 2/ swap xy>d swap $7 and or swap !+ )( drop 4+ )
		) 2drop ;

|----------------------------------------------------------
::spr.num | adr --
	( @+ 1? )( $3 and? ( d>xy 4 box )( drop )
		) 2drop ;


|---------------- rescatar dibujos desde el codigo
|#indice  uno dos 0
|:save-dibu
|	clear 'indice ( @+ 1? )( ( @+ 1? )( , ) , drop ) , drop
|	mem here over - "carucha" save ;

|-----------------------------------------------------------
| lista de sprites
| c/sprite tiene
| x y w h r 'adr
|-----------------------------------------------------------

::spos! | x y 'adr --
	!+ ! ;
::smove! | x y 'adr --
	>r swap r @ + r!+ r @ + r> ! ;
::srot! | a 'adr --
	16 + >r r @ + r> ! ;
::sscale! | z 'adr --
	8 + >r dup r @ + r!+ r @ + r> ! ;
::sdib! | 'n 'adr --
	20 + ! ;

::sDraw | 'adr --
	@cursor @+ sprang @ sprdrawr ;

::sDrawLayer | 'adr --
	( @+ 1? )( sdraw ) 2drop ;

:hit? | s1 s2 -- 0/s1
	over =? ( 2drop 0 ; ) | s1=s2?
	>r
	dup @+ r@+ -	| s1 s1y dx
	swap @ r@+ -	| s1 dx dy
	distfast			| s1 dist
	over 8 + @ r@+ + | s1 dist dw
	pick2 12 + @ r> @ +
	distfast 2/ -		| s1 dd
	+? ( 2drop 0 ; )
	drop ;

::sHitLayer | 'spr 'adr --  0/'otro
	( @+ 1? )( pick2  | 'spr 'adr 'nesp 'spr
		hit? 1? ( nip nip ; )
		drop ) 3drop 0 ;

::sMapLayer | 'func 'layer --
	( @+ 1? )( pick2 exec ) 3drop ;

::sDropLayer | 'spr 'layer --
	( @+ 0? ( 3drop ; ) pick2 <>? )( drop ) drop nip
	( dup @ 1? )( swap 4 - !+ 4+ ) swap 4 - !
	;

::sAddLayer | 'sprit 'layer --
	( @+ 1? )( drop )
	rot rot 4 - !+ ! ;