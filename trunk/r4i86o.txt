| R4i86o.txt - PHREDA 2010
| Generacion de codigo para i86-FASM
|
| .. [esp] - pila R
| .. [esi] eax - pila D
|
| ebx edi - Libres
| ecx - libre | sar sal
| edx - libre | * /
|
| ebp - VFRAME pointer
| MMX - auxiliares de almacenamiento
|
| nivel 0 -- solo macros,variable y direcciones
| nivel 1 -- llamada a palabras de nivel 0
| nivel 2 -- llamada a palabras de nivel 1 y 0
|--------------------------------------------
^lib/gui.txt
^lib/parse.txt
^lib/trace.txt

|----- nro de str y label
#nstr	| nro de string
#nlabel | nro de etiqueta
#nanon	| nro de def anonima

| por palabras
#niva 		| nivel de anonimo
#compara?	| 0 si no esta comparado nos con tos
#jmp?       | 1 si salto en la anterior (para no hacer ret)
#uquieto	| pila de udato

::ini.compila
	0 'nstr ! 0 'nlabel ! 0 'nanon ! ;

|----- pila de compilador
#pilac )( 256	#pilac> 'pilac

:>pilac pilac> !+ 'pilac> ! ;
:<pilac -4 'pilac> +! pilac> @ ;
:pilac! 'pilac 'pilac> ! ;

|:nro>dicn2   8 >> 5 << 'indicepal + @ ; | nombre
:nro>dicn   8 >> "w%h" mprint ;			| numero de palabra

:label	"_" ,s ,h 	;
:jmp,	"jmp " ,s label ,cr ;

|------ pila virtual
| 		valor 		tipo
| TOS = dpila>-4  dpila>-8
|.. tipo valor tipo valor
#dpila )( 2048
#dpila> 'dpila

:d.ini
	'dpila 'dpila> ! ;
:d.cnt | -- cnt
	dpila> 'dpila - 3 >> ;
:d.pop | -- nro
	dpila> 8 -
	dup 'dpila> ! 4+ @ ;
:d.pop2 | -- nos tos
	-16 'dpila> +!
	dpila> 4+ @+ swap 4+ @ ;
:d.pop3 | -- nos2 nos tos
	-24 'dpila> +!
	dpila> 4+ @+ swap 4+ @+ swap 4+ @ ;

:d.get dpila> 4 - @ ;
:d.get2 dpila> 12 - @ ;

:d.TOSt | -- tipodetos
	dpila> 8 - @ ;

:d.NOSt | -- tipodenos
	dpila> 16 - @ ;

:d.NOS2t | -- tipodenos2
	dpila> 24 - @ ;

:d.push | nro tipo --
	dpila> !+ !+ 'dpila> ! ;

:d.setReg | nro tipo lugar --
	1+ 3 << dpila> swap - !+ ! ;

:d.u
	d.cnt uquieto + ;
:d.f
	d.cnt uquieto - ;

|----------- tipo de pila
:d.pushReg	0 d.push ; | eax ebx ecx edx edi mm0 mm1 mm2 mm3 mm4 mm5 mm6 mm7
:d.pushEsi  1 d.push ; | dword [esi+4*] ..
:d.pushEsp	2 d.push ; | dword	[esp+4*] ..
:d.pushVar	3 d.push ; | var	[w1]
:d.pushIcod	4 d.push ; | dcod	'w2
:d.pushDcod	5 d.push ; | dcod	'w2
:d.pushDvar	6 d.push ; | dvar	w1
:d.pushStr	7 d.push ; | str    "hola"
:d.pushCte	8 d.push ; | cte	23

#RegCount 5
#ra "eax" #rb "ebx" #rc "ecx" #rd "edx" #re "edi"
#reg 'ra 'rb 'rc 'rd 're

#RegMCount 8
#rm0 "mm0" #rm1 "mm1" #rm2 "mm2" #rm3 "mm3" #rm4 "mm4" #rm5 "mm5" #rm6 "mm6" #rm7 "mm7"
#regmmx rm0 rm1 rm2 rm3 rm4 rm5 rm6 rm7

:,Reg	RegCount <? ( 2 << 'reg + @ ; ) RegCount - 	| eax ebx ecx edx
		RegMCount <? ( 	2 << 'regmmx + @ ; ) RegMCount -
		1+ neg
:,Esi	0? ( "dword [esi]" ,s drop ; )
		-? ( neg "dword [esi-4*%d]" )( "dword [esi+4*%d]" )
		mprint ;
:,Esp	0? ( "dword [esp]" ,s drop ; )
		-? ( neg "dword [esp-4*%d]" )( "dword [esp+4*%d]" )
		mprint ;
:,Var	"[w%h]" mprint ;
:,Icod  "i%h" mprint ;
:,Dcod
:,Dvar	"w%h" mprint ;
:,Str	"s%h" mprint ;
:,Cte	"%d" mprint ;

#tipopila ,Reg ,Esi ,Esp ,Var ,Icod ,Dcod ,Dvar ,Str ,Cte

:,vstack | nro --
	1+ 3 << dpila> swap -
	@+ swap @ swap 2 << 'tipopila + @ exec ,s ;

:,nreg ,reg ,s ;


#rab "al" #rbb "bl" #rcb "cl" #rdb "dl"
#regb 'rab 'rbb 'rcb 'rdb

:,regB	2 << 'regb + @ ; | no esta edi!!
:,esiB  0? ( "byte [esi]" ,s drop ; )
		-? ( neg "byte [esi-4*%d]" )( "byte [esi+4*%d]" )
		mprint ;
:,EspB	0? ( "byte [esp]" ,s drop ; )
		-? ( neg "byte [esp-4*%d]" )( "byte [esp+4*%d]" )
		mprint ;
:,VarB	"byte [w%h]" mprint ;

#tipopilaB ,RegB ,EsiB ,EspB ,VarB

:,vstackbyte | nro --
	1+ 3 << dpila> swap -
	@+ swap @ swap 2 << 'tipopilaB + @ exec ,s ;

#raw "ax" #rbw "bx" #rcw "cx" #rdw "dx" #rew "di"
#regw 'raw 'rbw 'rcw 'rdw 'rdw

:,regW	2 << 'regw + @ ;
:,esiW  0? ( "word [esi]" ,s drop ; )
		-? ( neg "word [esi-4*%d]" )( "word [esi+4*%d]" )
		mprint ;
:,EspW	0? ( "word [esp]" ,s drop ; )
		-? ( neg "word [esp-4*%d]" )( "word [esp+4*%d]" )
		mprint ;
:,VarW	"word [w%h]" mprint ;

#tipopilaW ,RegW ,EsiW ,EspW ,VarW

:,vstackword | nro --
	1+ 3 << dpila> swap -
	@+ swap @ swap 2 << 'tipopilaW + @ exec ,s ;

:d.resortstack | --  convierto to eax [esi] ..
 	trace
	d.cnt
	'dpila >r
	1- 0 ( over <? )(
		"mov [esi-" ,s uquieto ,d "]," ,s
     	r@+ r@+ swap 2 << 'tipopilaW + @ exec ,s ,cr
		1+ ) drop
	1+ "mov eax," ,s
	r@+ r@+ swap 2 << 'tipopilaW + @ exec ,s cr
	rdrop
	"lea esi,[esi" ,s d.f -? ( neg "-" )( "+" ) ,s 2 << ,d "]" ,ln
	;

:,TOS	0 ,vstack ;
:,NOS	1 ,vstack ;
:,NOS2	2 ,vstack ;
:,TOSbyte 0 ,vstackbyte ;
:,TOSword 0 ,vstackword ;
:,NOSbyte 1 ,vstackbyte ;
:,NOSword 1 ,vstackword ;

:,RTOS
	"edi" ;

:,,
	"," ,s ;

:1cte? | -- f
	dpila> 8 -
	@ 8 <>? ( drop 0 ; ) drop
	1 ;

:2cte? | -- f
	dpila> 16 -
	@+ 8 <>? ( 2drop 0 ; ) drop
	4+ @ 8 <>? ( drop 0 ; ) drop
	1 ;

:3cte? | -- f
	dpila> 24 -
	@+ 8 <>? ( 2drop 0 ; ) drop
	4+ @+ 8 <>? ( 2drop 0 ; ) drop
	4+ @ 8 <>? ( drop 0 ; ) drop
	1 ;

|----------- uso de registro
#regused 0  0  0  0  0  0   0   0   0   0   0   0   0
#regname ra rb rc rd re rm0 rm1 rm2 rm3 rm4 rm5 rm6 rm7

:reg.free | -- nro
	'regused
	5 ( 1? )( swap @+
		0? ( drop 'regused - 2 >> 1- nip ; )
		drop swap ) 2drop
	| si no hay uno, libera y asigna
	4 ;
|	-1 ;

:regx.free | -- nro
	reg.free 0 >=? ( ; )

	;

:reg.set | nro --
	2 << 'regused + 1 swap ! ;

:reg.refresh
	0 0 0 0 0 'regused !+ !+ !+ !+ !
	'dpila
	( dpila> <? )(
		@+ 0? ( over @ reg.set )
		drop 4+ ) drop
	;

| NOS a un registro (si no esta)
:TOSreg
	d.TOSt 0? ( drop ; ) drop
	reg.free
	"mov " ,s dup ,nReg ,, ,TOS ,cr
	0 0 d.setReg ;

:TOSmem
    d.TOSt 3 <? ( drop ; ) drop
	reg.free
	"mov " ,s dup ,nReg ,, ,TOS ,cr
	0 0 d.setReg ;

:NOSreg
	d.NOSt 0? ( drop ; ) drop
	reg.free
	"mov " ,s dup ,nReg ,, ,NOS ,cr
	0 1 d.setReg ;

:NOSmem
    d.NOSt 3 <? ( drop ; ) drop
	reg.free
	"mov " ,s dup ,nReg ,, ,NOS ,cr
	0 1 d.setReg ;

:NOSeax
	|nos es eax..salir
	|liberea eax
	"mov eax," ,s ,NOS ,cr ;

:NOS2eax
	|nos es eax..salir
	"mov eax," ,s ,NOS2 ,cr ;

:FREEedx
	|libera edx
	;

:TOSecx
	"mov ecx," ,s ,TOS
	;

:eaxNOS
	;
:edxTOS
	;
|---------------------------
:+etiqueta	| -- nueva   // y agrega a pila
	nlabel 1+ dup 'nlabel ! dup >pilac ;

:salto? | adr++ xx xx -- adr++ xx xx 0/1
	pick2 8 - @ $ff and
	18 >? ( 31 <? ( 1 nip ; ) ) 0 nip ;

:nextret? |
	pick2 @ $ff and 12 =? ( 1 )( 0 ) nip ;

:,lit
	dup tok>cte d.pushCte ; |	dup tok>cte ,DUP "mov eax," ,s ,d ,cr ;
:,lits
	nstr d.pushStr 1 'nstr +! ; |	,DUP "mov eax,s" ,s nstr ,h ,cr 1 'nstr +! ;

:,wor
	d.resortstack
	nextret? 1? ( 1 'jmp? ! "jmp " )( "call " ) nip
	,s dup nro>dicn ,ln
	;

:,var
	dup 8 >> d.pushVar ; |	dup nro>dicn ,DUP "mov eax,[" ,s ,s "]" ,s ,cr ;
:,dwo
	dup 8 >> d.pushDcod ; |	dup nro>dicn ,DUP "mov eax," ,s ,s ,cr ;
:,dva
	dup 8 >> d.pushDvar ; |	dup nro>dicn ,DUP "mov eax," ,s ,s ,cr ;


:,[
	1 'niva +!
	nanon d.pushIcod 1 'nanon +! ; |,DUP +etiqueta +etiqueta "mov eax," ,s label ,cr jmp, <pilac label ":" ,ln ;
:,]
	-1 'niva +! ; |<pilac label ":" ,ln ;

|----------------------------

:*DROP  -8 'dpila> +! ;
:*2DROP -16 'dpila> +! ;
:*3DROP -24 'dpila> +! ;
:*4DROP -32 'dpila> +! ;
:*DUP
	dpila> 8 - >r
	r@+ r@+ swap
	r!+ r!+ r> 'dpila> ! ;
:*2DUP
	dpila> 16 - >r
	r@+ r@+ swap
	r@+ r@+ swap 2swap
	r!+ r!+ r!+ r!+
	r> 'dpila> ! ;
:*OVER
	dpila> 16 - >r
	r@+ r@+ swap r> 8 + >r
	r!+ r!+ r> 'dpila> ! ;
:*PICK2
	dpila> 24 - >r
	r@+ r@+ swap r> 16 + >r
	r!+ r!+ r> 'dpila> ! ;
:*PICK3
	dpila> 32 - >r
	r@+ r@+ swap r> 24 + >r
	r!+ r!+ r> 'dpila> ! ;
:*PICK4
	dpila> 40 - >r
	r@+ r@+ swap r> 32 + >r
	r!+ r!+ r> 'dpila> ! ;
:*SWAP
	dpila> 16 - >r
	r@+ r@+ swap
	r@+ r> @ swap
	dpila> 16 -
	!+ !+ !+ ! ;
:*NIP
	dpila> 8 - >r
	r@+ r@+ swap r> 16 -
	!+ !+ 'dpila> ! ;
:*ROT
	dpila> 24 - >r
	r@+ r@+ swap
	r@+ r@+ swap
	r@+ r> @ swap 2swap
	dpila> 24 -
	!+ !+ !+ !+ !+ ! ;
:*2OVER
	dpila> 32 - >r
	r@+ r@+ swap
	r@+ r@+ swap 2swap
	r> 16 +
	!+ !+ !+ !+ 'dpila> ! ;
:*2SWAP
	dpila> 32 - >r
	r@+ r@+ swap
	r@+ r@+ swap 2swap
	r@+ r@+ swap
	r@+ r@+ swap 2swap r> 32 -
	!+ !+ !+ !+ !+ !+ !+ ! ;

:*RDROP | libera edi
	;
|----------------------------
:,DUP
	"lea esi,[esi-4]" ,ln
	"mov [esi],eax" ,ln ;
:,DROP
	"lodsd" ,ln ;
:,NIP
	"lea esi,[esi+4]" ,ln ;
:,2DROP
	,NIP ,DROP ;
:,3DROP
	"lea esi,[esi+8]" ,ln
	,DROP ;
:,4DROP
	"lea esi,[esi+12]" ,ln
	,DROP ;
:,OVER
	,DUP "mov eax,[esi+4]" ,ln ;
:,PICK2
	,DUP "mov eax,[esi+4*2]" ,ln ;
:,PICK3
	,DUP "mov eax,[esi+4*3]" ,ln ;
:,PICK4
	,DUP "mov eax,[esi+4*4]" ,ln ;
:,SWAP
|	"mov edx,eax" ,ln |"xchg eax,[esi]" ,ln ;|ggrr
|	"mov eax,[esi]" ,ln
|	"mov [esi],edx" ,ln ;
	"push eax" ,ln	| otra version (sin dx)
	"mov eax,[esi]" ,ln
	"popd [esi]" ,ln ;
:,ROT
|	"mov ecx,[esi+4]" ,ln
|	"mov edx,[esi]" ,ln
|	"mov [esi],eax" ,ln
|	"mov [esi+4],edx" ,ln
|	"mov eax,ecx" ,ln ;
	"pushd [esi+4]" ,ln	| otra version (sin dx,cx)
	"pushd [esi]" ,ln
	"popd [esi+4]" ,ln
	"mov [esi],eax" ,ln
	"pop eax" ,ln ;
:,2DUP
	,OVER ,OVER ;
:,2OVER
	"mov [esi-4],eax" ,ln
	"lea esi,[esi-8]" ,ln
|	"mov edx,[esi+16]" ,ln
|	"mov [esi],edx" ,ln
	"pushd [esi+16]" ,ln
	"popd [esi]" ,ln
	"mov eax,[esi+12]" ,ln ;
:,2SWAP
|	"mov ecx,[esi+4]" ,ln
	"pushd [esi+4]" ,ln
	"mov [esi+4],eax" ,ln
|	"mov edx,[esi+8]" ,ln
	"pushd [esi+8]" ,ln
	"mov eax,[esi]" ,ln
	"mov [esi+8],eax" ,ln
|	"mov [esi],edx" ,ln
|	"mov eax,ecx" ,ln
	"popd [esi]" ,ln
	"pop eax" ,ln ;

|--------------------------------------------
:,AND
	d.u 0? ( drop "and eax,[esi]" ,ln ,NIP ; ) drop
	2cte? 1? ( drop d.pop2 and d.pushCte ; ) drop
	NOSreg
	"and " ,s ,NOS ,, ,TOS ,cr *DROP ;

:,OR
	d.u 0? ( drop "or eax,[esi]" ,ln ,NIP ; ) drop
	2cte? 1? ( drop d.pop2 or d.pushCte ; ) drop
	NOSreg
	"or " ,s ,NOS ,, ,TOS ,cr *DROP ;

:,XOR
	d.u 0? ( drop "xor eax,[esi]" ,ln ,NIP ; ) drop
	2cte? 1? ( drop d.pop2 xor d.pushCte ; ) drop
	NOSreg
	"xor " ,s ,NOS ,, ,TOS ,cr *DROP ;

:,NOT
	d.u 0? ( drop "not eax" ,ln ; ) drop
	1cte? 1? ( drop d.pop not d.pushCte ; ) drop
	TOSreg
	"not" ,s ,TOS ,cr ;

:,+
	d.u  0? ( drop "add eax,[esi]" ,ln ,NIP ; ) drop
	2cte? 1? ( drop d.pop2 + d.pushCte ; ) drop
	NOSreg
	"add " ,s ,NOS ,, ,TOS ,cr *DROP ;

:,-
	d.u 0? ( drop "neg eax" ,ln "add eax,[esi]" ,ln ,NIP ; ) drop
	2cte? 1? ( drop d.pop2 - d.pushCte ; ) drop
	NOSreg
	"sub " ,s ,NOS ,, ,TOS ,cr *DROP ;

:,*
	d.u 0? ( drop "imul eax,dword [esi]" ,ln ,NIP ; ) drop
	2cte? 1? ( drop d.pop2 * d.pushCte ; ) drop
	NOSreg
	"imul " ,s ,NOS ,, ,TOS ,cr *DROP ;

:,/
	d.u 0? ( drop "idiv eax,dword [esi]" ,ln ,NIP ; ) drop
	2cte? 1? ( drop d.pop2 / d.pushCte ; ) drop
	NOSreg
	"idiv " ,s ,NOS ,, ,TOS ,cr *DROP ;

:,*/
	d.u 0? ( drop
			"mov ecx,eax" ,ln
			,DROP
			"cdq" ,ln
			"imul dword [esi]" ,ln
			"idiv ecx" ,ln
			,NIP ; ) drop
	3cte? 1? ( drop d.pop3 */ d.pushCte ; ) drop
	NOS2eax
	FREEedx
	"cdq" ,ln
	"imul " ,s ,NOS ,cr
	"idiv " ,s ,TOS ,cr
	*2DROP ;

:,*>>
	d.u 0? ( drop
		"mov ecx,eax" ,ln
		,DROP
		"cdq" ,ln
		"imul dword [esi]" ,ln
		"shrd eax,edx,cl" ,ln
		,NIP ; ) drop
	3cte? 1? ( drop d.pop3 *>> d.pushCte ; ) drop
	1cte? 1? ( drop
		NOS2eax
		FREEedx
		"cdq" ,ln
		"imul dword [esi]" ,ln
		"shrd eax,edx," ,s ,TOSbyte ,cr
		*2DROP ; ) drop
	TOSecx
	NOS2eax
	FREEedx
	"cdq" ,ln
	"imul dword [esi]" ,ln
	"shrd eax,edx,cl" ,ln
	*2DROP ;

:,<</
	d.u 0? ( drop
		"mov ecx,eax" ,ln
		"pushd [esi+4]"
		,2DROP
		"cdq" ,ln
	    "shld eax,edx,cl" ,ln
		"pop ecx" ,ln
		"idiv ecx" ,ln ; ) drop
|	3cte? 1? ( drop d.pop3 <</ d.pushCte ; ) drop
	TOSecx
	NOS2eax
	"cdq" ,ln
    "shld eax,edx," ,s ,TOSbyte ,cr
	"idiv " ,s ,NOS ,cr
	*2DROP ;


:,/MOD
	d.u 0? ( drop
		"mov ecx,eax" ,ln
		"mov eax,[esi]" ,ln
		"cdq" ,ln
		"idiv ecx" ,ln
		"mov [esi],eax" ,ln
		"mov eax,edx" ,ln ; ) drop
	2cte? 1? ( drop d.get2 /mod d.pushCte d.pushCte ; )
	NOSeax
	"cdq" ,ln
	"idiv " ,s ,TOS ,cr
	eaxNOS
	edxTOS ;

:,MOD
	d.u 0? ( drop
		"mov ecx,eax" ,ln
		,DROP
		"cdq" ,ln
		"idiv ecx" ,ln
		"mov eax,edx" ,ln ; ) drop
	2cte? 1? ( drop d.get2 mod d.pushCte ; ) drop
	NOSeax
	FREEedx
	"idiv " ,s ,TOS ,cr
	"mov eax,edx" ,ln
	*DROP ;

:,<<
	d.u 0? ( drop
		"mov ecx,eax" ,ln ,DROP
		"sal eax,cl" ,ln ; ) drop
	2cte? 1? ( drop d.get2 << d.pushCte ; ) drop
	NOSreg
	"sal ",s ,NOS ,, ,TOS ,cr
	*DROP ;

:,>>
	d.u 0? ( drop
		"mov ecx,eax" ,ln ,DROP
		"sar eax,cl" ,ln ; ) drop
	2cte? 1? ( drop d.get2 << d.pushCte ; ) drop
	NOSreg
	"sar ",s ,NOS ,, ,TOS ,cr
	*DROP ;

:,ABS
	d.u 0? ( drop
		"cdq" ,ln
		"add eax,edx" ,ln
		"xor eax,edx" ,ln ; ) drop
	1cte? 1? ( drop d.pop abs d.pushCte ; ) drop
	"or " ,s ,TOS ,, ,TOS ,cr
	"jp @f" ,ln
	"neg " ,s ,TOS ,cr
	"@@:" ,ln ;

:,CLZ
	1cte? 1? ( drop d.pop clz d.pushCte ; ) drop

	"or " ,s ,TOS ,, ,TOS ,cr
	"jz @f" ,ln
	"bsr " ,s ,TOS ,, ,TOS ,cr
	"xor " ,s ,TOS ",31" ,ln
	"@@:" ,ln ;

:,NEG
	d.u 0? ( drop "neg eax" ,ln ; ) drop
	1cte? 1? ( drop d.pop neg d.pushCte ; ) drop
	TOSreg
	"neg" ,s ,TOS ,cr ;

:,1+
	d.u 0? ( drop "add eax,1" ,ln ; ) drop
	1cte? 1? ( drop d.pop 1+ d.pushCte ; ) drop
	TOSreg
	"add " ,s ,TOS ",1" ,s ,cr ;

:,1-
	d.u 0? ( drop "add eax,-1" ,ln ; ) drop
	1cte? 1? ( drop d.pop 1- d.pushCte ; ) drop
	TOSreg
	"add " ,s ,TOS ",-1" ,s ,cr ;

:,4+
	d.u 0? ( drop "add eax,4" ,ln ; ) drop
	1cte? 1? ( drop d.pop 4+ d.pushCte ; ) drop
	TOSreg
	"add " ,s ,TOS ",4" ,s ,cr ;


:,2/
	d.u 0? ( drop "sar eax,1" ,ln ; ) drop
	1cte? 1? ( drop d.pop 2/ d.pushCte ; ) drop
	TOSreg
	"sar " ,s ,TOS ",1" ,s ,cr ;

:,2*
	d.u 0? ( drop "sal eax,1" ,ln ; ) drop
	1cte? 1? ( drop d.pop 2* d.pushCte ; ) drop
	TOSreg
	"sal " ,s ,TOS ",1" ,s ,cr ;

|---------------------
:,EXEC
	d.u 0? ( drop
		"mov ecx,eax" ,ln
		,DROP
		"or ecx,ecx" ,ln
		"jz @f" ,ln
		"call ecx" ,ln
		"@@:" ,ln ; ) drop
|	-1 d.plain
	"mov ecx," ,s ,TOS
   	"or ecx,ecx" ,ln
	"jz @f" ,ln
	"call ecx" ,ln
	"@@:" ,ln ;
	;

:,>R
	d.u 0? ( drop
		"push eax" ,ln ,DROP ; ) drop
	"push " ,s ,TOS ,cr *DROP ;
| "mov " ,s ,RTOS ,, ,TOS *DROP ;

:,R>
	d.u 0? ( drop
		,DUP "pop eax" ,ln ; ) drop
	*DUP "pop " ,s ,TOS ,cr ;
|** nada/mov/ push

:,R
	d.u 0? ( drop
		,DUP "mov eax,[esp]" ,ln ; ) drop
	*DUP
	"mov " ,s ,TOS ,RTOS ,cr ;

:,RDROP
	d.u 0? ( drop
		"lea esp,[esp+4]" ,ln ; ) drop
	*RDROP ;

:,R+
	d.u 0? ( drop
		"add [esp],eax" ,ln ,DROP ; ) drop
	"add [" ,s ,RTOS "]," ,s ,TOS ,cr
	*DROP ;

:,R!+
	d.u 0? ( drop
		"pop edx" ,ln
		"mov [edx],eax" ,ln
		"add edx,4" ,ln
		"push edx" ,ln
		,DROP ; ) drop
	"mov [" ,s ,RTOS "]," ,s ,TOS ,cr
	"add " ,s ,RTOS ",4" ,ln
	*DROP ;

:,R@+
	d.u 0? ( drop
		,DUP
		"mov eax,[esp]" ,ln
		"mov eax,[eax]" ,ln
		"add [esp],4" ,ln
	|	"pop edx" ,ln
	|	"mov eax,[edx]" ,ln
	|	"add edx,4" ,ln
	|	"push edx" ,ln
    	; ) drop
	*DUP
	"mov " ,s ,TOS ",[" ,s ,RTOS "]" ,ln
	"add " ,s ,RTOS ",4" ,ln ;

:,@
	d.u 0? ( drop "mov eax,dword [eax]" ,ln ; ) drop
	"mov " ,s ,TOS "dword [" ,s ,TOS "]" ,s ,cr ;

:,C@
	d.u 0? ( drop "movsx eax,byte [eax]" ,ln ; ) drop
	"movsx " ,s ,TOS "byte [" ,s ,TOS "]" ,s ,cr ;

:,W@
	d.u 0? ( drop "movsx eax,word [eax]" ,ln ; ) drop
	"movsx " ,s ,TOS "word [" ,s ,TOS "]" ,s ,cr ;

:,!
	d.u 0? ( drop
		"mov ecx,[esi]" ,ln
		"mov [eax],ecx" ,ln
		,2DROP ; ) drop
	"mov [" ,s ,TOS "]," ,s ,NOS ,cr
	*2DROP ;

:,C!
	d.u 0? ( drop
		"mov ecx,[esi]" ,ln
		"mov byte [eax],cl" ,ln
		,2DROP ; ) drop
	"mov byte [" ,s ,TOS "]," ,s ,NOSbyte ,cr
	*2DROP ;

:,W!
	d.u 0? ( drop
		"mov ecx,[esi]" ,ln
		"mov word [eax],cx" ,ln
		,2DROP ; ) drop
	"mov word [" ,s ,TOS "]," ,s ,NOSword ,cr
	*2DROP ;

:,+!
	d.u 0? ( drop
		"mov ecx,[esi]" ,ln
		"add [eax],ecx" ,ln
		,2DROP ; ) drop
	"add [" ,s ,TOS "]," ,s ,NOS ,cr
	*2DROP ;

:,W+!
	d.u 0? ( drop
		"mov ecx,[esi]" ,ln
		"add word [eax],cx" ,ln
		,2DROP ; ) drop
	"add word [" ,s ,TOS "]," ,s ,NOSword ,cr
	*2DROP ;

:,C+!
	d.u 0? ( drop
		"mov ecx,[esi]" ,ln
		"add byte [eax],cl" ,ln
		,2DROP ; ) drop
	"add byte [" ,s ,TOS "]," ,s ,NOSbyte ,cr
	*2DROP ;

:,!+
	d.u 0? ( drop
		"mov ecx,[esi]" ,ln
		"mov [eax],ecx" ,ln
		"add eax,4" ,ln
		,NIP ; ) drop
	"mov [" ,s ,TOS "]," ,s ,NOS ,cr
	"add " ,s ,TOS ",4" ,s ,cr
	*NIP ;

:,W!+
	d.u 0? ( drop
		"movsx ecx,word [esi]" ,ln
		"mov [eax],cx" ,ln
		"add eax,2" ,ln
		,NIP ; ) drop
	"mov word [" ,s ,TOS "]," ,s ,NOSword ,cr
	"add " ,s ,TOS ",2" ,s ,cr
	*NIP ;

:,C!+
	d.u 0? ( drop
		"movsx ecx,byte [esi]" ,ln
		"mov [eax],cl" ,ln
		"inc eax" ,ln
		,NIP ; ) drop
	"mov byte [" ,s ,TOS "]," ,s ,NOSbyte ,cr
	"add " ,s ,TOS ",1" ,s ,cr
	*NIP ;

:,@+
	d.u 0? ( drop
		"mov ecx,[eax]" ,ln
		"add eax,4" ,ln
		"mov [esi-4],eax" ,ln
		"mov eax,ecx" ,ln
		"lea esi,[esi-4]" ,ln ; ) drop
	*DUP
	"mov " ,s ,TOS ",[" ,s ,NOS "]" ,ln
	"add " ,s ,NOS ",4" ,ln ;

:,W@+
	d.u 0? ( drop
		"movsx ecx,word [eax]" ,ln
		"add eax,2" ,ln
		"mov [esi-4],eax" ,ln
		"mov eax,ecx" ,ln
		"lea esi,[esi-4]" ,ln ; ) drop
	*DUP
	"movsx " ,s ,TOS ",word [" ,s ,NOS "]" ,ln
	"add " ,s ,NOS ",2" ,ln ;


:,C@+
	d.u 0? ( drop
		"movsx ecx,byte [eax]" ,ln
		"inc eax" ,ln
		"mov [esi-4],eax" ,ln
		"mov eax,ecx" ,ln
		"lea esi,[esi-4]" ,ln ; ) drop
	*DUP
	"movsx " ,s ,TOS ",byte [" ,s ,NOS "]" ,ln
	"add " ,s ,NOS ",1" ,ln ;

|------------------------------------
:,0?
	d.u 0? ( drop
		"or eax,eax" ,ln
		"jnz " ,s ; ) drop
	"or " ,s ,TOS ,, ,TOS ,cr
	"jnz " ,s ;

:,+?
	d.u 0? ( drop
		"or eax,eax" ,ln
		"js " ,s ; ) drop
	"or " ,TOS ,, ,TOS ,cr
	"js " ,s ;

:,-?
	d.u 0? ( drop
		"or eax,eax" ,ln
		"jns " ,s ; ) drop
	"or " ,s ,TOS ,, ,TOS ,cr
	"jns " ,s ;

:,1?
	d.u 0? ( drop
		"or eax,eax" ,ln
		"jz " ,s ; ) drop
	"or " ,s ,TOS ,, ,TOS ,cr
	"jz " ,s ;

:,=?
	d.u 0? ( drop
		"mov ecx,eax" ,ln ,DROP
		"cmp eax,ecx" ,ln
		"jnz " ,s ; ) drop
	"cmp " ,s ,NOS ,, ,TOS ,cr *DROP
	"jnz " ,s ;

:,<?
	d.u 0? ( drop
		"mov ecx,eax" ,ln ,DROP
		"cmp eax,ecx" ,ln
		"jge " ,s ; ) drop
	"cmp " ,s ,NOS ,, ,TOS ,cr *DROP
	"jge " ,s ;

:,>?
	d.u 0? ( drop
		"mov ecx,eax" ,ln ,DROP
		"cmp eax,ecx" ,ln
		"jle " ,s ; ) drop
	"cmp " ,s ,NOS ,, ,TOS ,cr *DROP
	"jle " ,s ;

:,<=?
	d.u 0? ( drop
		"mov ecx,eax" ,ln ,DROP
		"cmp eax,ecx" ,ln
		"jg " ,s ; ) drop
	"cmp " ,s ,NOS ,, ,TOS ,cr *DROP
	"jg " ,s ;

:,>=?
	d.u 0? ( drop
		"mov ecx,eax" ,ln ,DROP
		"cmp eax,ecx" ,ln
		"jl " ,s ; ) drop
	"cmp " ,s ,NOS ,, ,TOS ,cr *DROP
	"jl " ,s ;

:,<>?
	d.u 0? ( drop
		"mov ecx,eax" ,ln ,DROP
		"cmp eax,ecx" ,ln
		"jz " ,s ; ) drop
	"cmp " ,s ,NOS ,, ,TOS ,cr *DROP
	"jz " ,s ;

:,and?
	d.u 0? ( drop
		"mov ecx,eax" ,ln ,DROP
		"test eax,ecx" ,ln
		"jz " ,s ; ) drop
	"test " ,s ,NOS ,, ,TOS ,cr *DROP
	"jz " ,s ;

:,nand?
	d.u 0? ( drop
		"mov ecx,eax" ,ln ,DROP
		"test eax,ecx" ,ln
		"jnz " ,s ; ) drop
	"test " ,s ,NOS ,, ,TOS ,cr *DROP
	"jnz " ,s ;

|--------- Sistema
:,DIR
	"call SYSDIR" ,ln ;
:,FILE
	"call SYSFILE" ,ln ;
:,FSIZE
	"call SYSFSIZE" ,ln ;
:,VOL
	"call SYSVOL" ,ln ;
:,LOAD
	"call SYSLOAD" ,ln ;
:,SAVE
	"call SYSSAVE" ,ln ;
:,UPDATE
	"call SYSUPDATE" ,ln ;
:,MSEC
	"call SYSMSEC" ,ln ;
:,TIME
	"call SYSTIME" ,ln ;
:,DATE
	"call SYSDATE" ,ln ;
:,END
	"jmp SYSEND" ,ln ;
:,RUN
	"call SYSRUN" ,ln ;
:,SW
	,DUP  "mov eax,[SYSW]" ,ln ;
:,SH
	,DUP  "mov eax,[SYSH]" ,ln ;
:,MEM
	,DUP  "mov eax,FREE_MEM" ,ln ;

:,PAPER
	"mov [SYSPAPER],eax" ,ln ,DROP ;
:,CLS
	"call SYSCLS" ,ln ;
:,REDRAW
	"call SYSREDRAW" ,ln ;

:,FRAMEV
	,DUP  "mov eax,SYSFRAME" ,ln ;

:,XFB
	,DUP  "mov eax,XFB" ,ln ;
:,>XFB
	"call SYSTOXFB" ,ln ;
:,XFB>
	"call SYSXFBTO" ,ln ;

:,SETXY | x y --
	"imul eax,dword [SYSW]" ,ln
	"add eax,[esi]" ,ln
	"lea ebp,[SYSFRAME+eax*4]" ,ln
	,2DROP ;

:,PX+!	| s --
	"lea ebp,[ebp+eax*4]" ,ln
	,DROP ;
:,PX!+	| rgb --
	"mov [ebp],eax" ,ln
	"add ebp,4" ,ln
	,DROP ;
:,PX@	| -- rgb
	,DUP "mov eax,[ebp]" ,ln ;

:,iPEN! | v --
	"mov [SYSiPEN],eax" ,ln
	,DROP ;

:,TPEN | --
	,DUP
	"mov eax,[MCNT]" ,ln
	"dec eax" ,ln
	"mov [MBUFF],eax" ,ln
	"xor eax,eax" ,ln
	"inc eax" ,ln
	"mov [MCNT],eax" ,ln
	"mov eax,MBUFF" ,ln ;

:,XYMOUSE | -- x y
	,DUP
	"lea esi,[esi-4]" ,ln
	"mov eax,[SYSXYM]" ,ln
	"mov ecx,eax" ,ln
	"and ecx,$ffff" ,ln
	"shr eax,16" ,ln
	"mov [esi],ecx" ,ln ;

:,BMOUSE | -- c
	,DUP "mov eax,[SYSBM]" ,ln ;

:,iKEY! | v --
	"mov [SYSiKEY],eax" ,ln
	,DROP ;

:,KEY	| -- c
	,DUP "mov eax,[SYSKEY]" ,ln ;

|-----------definiciones en asmbase.txt ---------------
:,MOVE :,MOVE> :,CMOVE :,CMOVE>
:,SQRT
:,INK :,INK@ :,ALPHA :,OP :,CP :,LINE :,CURVE :,PLINE :,PCURVE
:,POLI :,FCOL :,FCEN :,FMAT :,SFILL :,LFILL :,RFILL :,TFILL

:,CNTJOY :,GETJOY
:,SLOAD :,SPLAY :,MLOAD :,MPLAY
:,SERVER :,CLIENT :,SEND :,RECV :,CLOSE
:,DOCINI :,DOCEND :,DOCAT :,DOCLINE :,DOCTEXT :,DOCFONT :,DOCBIT
:,DOCRES :,DOCSIZE

:,SYSTEM ;
|-----------definiciones en asmbase.txt ---------------

:,defw :,defv ;

:,;
	jmp? 1? ( drop 0 'jmp? ! ; ) drop
	|d.resortstack | reacomoda pila
	"ret" ,ln ;
:,(
	+etiqueta salto? 1? ( swap label ,cr 1 )( swap label ":" ,ln 2 ) >pilac drop ;
:,)(
	<pilac salto? 0? ( drop
			1 =? ( <pilac +etiqueta jmp, label ":" ,ln 1 >pilac drop ; )
			)( drop
			2 =? ( <pilac +etiqueta label ,cr >pilac 3 >pilac drop ; ) )
	drop ;
:,)
	<pilac salto? 0? ( drop
			1 =? ( <pilac label ":" ,ln drop ; )
			2 =? ( <pilac jmp, drop ; )
			3 =? ( <pilac jmp, <pilac label ":" ,ln drop ; )
		)( drop
			2 =? ( <pilac label ,cr drop ; ) )
	drop ;

|---- nivel 0 - sin desordenar la pila
#nivel0 0
,defw ,defv ,lit ,lit ,lit ,lit ,lits ,wor ,var ,dwo ,dva
,; ,( ,)( ,) ,[ ,] ,EXEC
,0? ,+? ,-? ,1? ,=? ,<? ,>? ,<=? ,>=? ,<>? ,AND? ,NAND? |..30

*DUP *DROP *OVER *PICK2 *PICK3 *PICK4 *SWAP *NIP	|--- pila
*ROT *2DUP *2DROP *3DROP *4DROP *2OVER *2SWAP

,>R ,R> ,R ,R+ ,R@+ ,R!+ ,RDROP					|--- pila direcciones  52
,AND ,OR ,XOR ,NOT  								|--- logicas
,+ ,- ,* ,/ ,*/ ,*>> ,/MOD ,MOD ,ABS  			|--- aritmeticas
,SQRT ,CLZ ,<</
,NEG ,1+ ,4+ ,1- ,2/ ,2* ,<< ,>> | 73
,@ ,C@ ,W@ ,! ,C! ,W! ,+! ,C+! ,W+!  			|--- memoria
,@+ ,!+ ,C@+ ,C!+ ,W@+ ,W!+ | 88
,MOVE ,MOVE> ,CMOVE ,CMOVE>
,MEM ,DIR ,FILE ,FSIZE ,VOL ,LOAD ,SAVE			|--- memoria bloques
,UPDATE ,MSEC ,TIME ,DATE ,END ,RUN 				|--- sistema
,SW ,SH ,CLS ,REDRAW ,FRAMEV  						|--- pantalla
,SETXY ,PX+! ,PX!+ ,PX@
,XFB ,>XFB ,XFB>
,PAPER ,INK ,INK@ ,ALPHA							|--- color
,OP ,CP ,LINE ,CURVE ,PLINE ,PCURVE ,POLI		|--- dibujo
,FCOL ,FCEN ,FMAT ,SFILL ,LFILL ,RFILL ,TFILL
,TPEN ,XYMOUSE ,BMOUSE
,IKEY! ,KEY
,CNTJOY ,GETJOY
,SLOAD ,SPLAY	,MLOAD ,MPLAY					|--- Sonido
,SERVER ,CLIENT ,SEND ,RECV ,CLOSE
,DOCINI ,DOCEND ,DOCAT ,DOCLINE ,DOCTEXT ,DOCFONT ,DOCBIT ,DOCRES ,DOCSIZE  |-- impresora
,SYSTEM

:print.dumpvstack
	mark
	d.cnt ( 1? )( 1- dup ,vstack ,sp ,sp ) drop ,eol
	empty here print ;

:print.regused
	'regused
	'regname
	5 ( 1? )( rot @+ 0? ( " " )( ">" ) print drop
			rot @+ print cr
			rot 1- ) 3drop

	;

#codehere
:printdebug
    fonti home verde
	"-----------------------" print cr
	print.dumpvstack cr
	"-----------------------" print cr
	print.regused
	"-----------------------" print cr
	dup
	11 >? ( 12 - macroname print  )( "%d" print ) cr cr
	0 here ! codehere print
	;

:espera
	inigui
	'exit >esc<
	show clrscr
		printdebug cflecha ;

| compila nivel 0 de palabras
:,token0 | a -- a.
	reg.refresh
	@+ dup
	$ff and espera
	2 << 'nivel0 + @ exec
	drop
	;

:makevstack | nro --
	nro>mov @ 24 << 24 >> dup 'uquieto !
	d.ini
	0? ( drop ; )
	neg 1- ( 1? )( dup d.pushEsi 1- )
	d.pushReg
	reg.refresh ;

::,compword | nro --
	0 'niva !
	0 'compara? !
	0 'jmp? !
	dup makevstack
	here 'codehere !
	nro>toklen
	( 1? )( 1- swap	,token0 swap )
	2drop ;
