| rutinas graficas 2
| para compilador
| PHREDA 2009
|----------------------------
^lib/gui.txt
^lib/trace.txt

| lineas
#xa #ya
#xb #yb

| segmentos
#.... -1 -1 -1 -1
#segs )( 2048
#segs> 'segs

| activos por linea
#activos )( 1024
#activos> 'activos

| linea de segmentos
#..... 0
#linea )( 1024
#linea> 'linea

| color
#rc #gc #bc
#sr #sg #sb

|--------------------------------------
:fillsolid | cnt --
	( 1? )( 1- inka px!+ ) drop ;

|--------------------------------------
:pasocol | -- col
	rc sr + dup 'rc ! $ff0000 and
	gc sg + dup 'gc ! 8 >> $ff00 and or
	bc sb + dup 'bc ! 16 >> $ff and or ;

:fillramp | cnt --
	inka px!+ 1- ( 1? )( 1- pasocol px!+ ) drop inkb 'inka ! ;

:setramp | cnt --
	inka inkb
	over $ff0000 and dup 'rc ! over $ff0000 and swap - pick3  / 'sr !
	over 8 << $ff0000 and dup 'gc ! over 8 << $ff0000 and swap - pick3  / 'sg !
	swap 16 << $ff0000 and dup 'bc ! swap 16 << $ff0000 and swap - swap  / 'sb ! ;

:addramp | cnt --
	sr over * 'rc +!
	sg over * 'gc +!
	sb * 'bc +! ;

| degrade entre dos colores
|------------------------------------
::cmorph | cant col1 col2 --
	over px!+
	over $ff0000 and dup 'rc ! over $ff0000 and swap - pick3  / 'sr !
	over 8 << $ff0000 and dup 'gc ! over 8 << $ff0000 and swap - pick3  / 'sg !
	swap 16 << $ff0000 and dup 'bc ! swap 16 << $ff0000 and swap - over  / 'sb !
	1- ( 1? )( 1- pasocol px!+ ) drop ;

|---------------------------------
| formato de scanline
| 00 <-color
|   000 <-cantidad de pixels
|      000 <-pixel de inicio
| precondiciones:
| pixel de inicio esta ordenado
| la cantidad de pixels puede solaparse
|
|
#paleta0
$0ff
$ff
$ff00
$ff0000

#scanline
$0100f002
$0000f003
$0200303f
$0000f04f
$0300f06f
$0000f07f
0

#scanline2
$0100f003
$0000f005
$0200303f
$0000f045
$0300f06f
$0000f075
0

#scanline3
$01005032
0

| 1.- xini es > a xact.. rellenar lo que falta (o avanzar)
| 2.- calcular degrade (antes buscar colores)
| 3.- buscar solapamiento del siguiente

#xact 0
:renderscanline | 'scanline --
	0 'inka !
	0 'xact !
	( @+ 1? )(
		dup $fff and
		xact >? ( dup xact - fillsolid )

		over 22 >> $3fc and 'paleta0 + @ 'inkb !
		swap 12 >> $fff and 1? ( dup setramp fillramp )( drop )

		'xact !
		inkb 'inka !
		) 2drop
	;

:insscan | v dir-4 vx --
	4+ dup | v dir d2
	4+ over linea> over - 2 >> move>
	!
	4 'linea> +! ;

:addscan | v --
	linea>
	( 'linea >? )( 4 -
		dup @ $fff and pick2 $fff and
		<? ( drop insscan ; )
		drop )
	drop
	linea> !+ 'linea> !	;

:generoscanline
	'linea 'linea> !
	'activos
	( activos> <? )( @+ | dir
		4+ dup
		@+ swap @ | dirx x deltax
		over + | x newx
		rot over swap ! | actualiza x
		over >? ( swap ) | x2 x1
		8 >> swap 8 >> over - | x1 dif
		12 << $fff000 and or
		$02000000 or | color
		addscan
		) drop
	0 linea> !
	'linea renderscanline
|	'scanline3 renderscanline
	;
|---------------------------------

:iniseg
	'segs 'segs> ! ;

:insseg | ymax deltax x ymin seg --
	16 + dup
	16 + over segs> over - 2 >> move>
	!+ !+ !+ !
	16 'segs> +!
	;

:addseg | ymax deltax x ymin --
	segs>
	( 'segs >=? )( 16 -
		dup @ pick2 <? ( drop insseg ; )
		drop )
	drop
	segs> !+ !+ !+ !+ 'segs> ! ;

:addline
	ya yb >? ( xa xb yb 'ya ! 'xa ! 'xb ! 'yb ! ya ) | ymin (xa ya yminimos)
	sw >=? ( drop ; )
	xb 8 <<
	xa 8 << - 			| ymin delx
	yb -? ( 3drop ; )	| ymin delx ymax
	pick2 - /			| ymin deltax
	swap -? ( neg over * 'xa +! 0 ) | deltax ymin
	yb rot rot xa 8 << swap
	addseg | ymax deltax x ymin --
	;

|---------------------------------
:nline | x y --
	2dup 'yb ! 'xb !
	ya <>? ( addline ) | ya=yb no dibuja
:nop | x y --
	'ya ! 'xa ! ;

|----
:addact | dir+4 -- dir+4
	dup 4 - activos> !+ 'activos> ! ;

:delactr | y dir+4 v -- y dir+4 v
	-4 'activos> +!
	activos> @ pick2 4 - !
	;

:delact | y -- y
	'activos
	( activos> <? )( @+
		12 + @ pick2 <=? ( delactr )
		drop )
	drop
	;

:npoli
	-1 dup dup dup segs> !+ !+ !+ ! | marca ultimo
	'activos 'activos> !
	'segs
	0 ( sw <? )(
		0 over setxy
		swap ( @+ pick2 =? )( drop addact 12 + ) drop 4 - swap
		generoscanline
		delact
		1+ )
	2drop ;

|---------------------------------
:nhline | x y dx --
	-? ( neg swap pick2 | ax>x
		)( swap xa )
						| x cnt x y
	setxy 1+
	( 1? )( 1- ink@ px!+ ) drop
	'xa ! ;

:nvline | x y --
	dup ya - | x y dy
	-? ( neg rot pick2	| ya>y
		)( rot ya )
						| y cnt x y
	setxy 1+
	( 1? )( 1- ink@ px!+ sw 1- px+! ) drop
	'ya ! ;

:li00 | x y dx dy -- x y .. +dx +dy
	2over
:cont00 | x y dx dy x1 y1 ....
	2dup setxy ink@ px!+
	2swap
	over <? ( | x y x1 y1 dx dy ...dy<dx
		16 << over / 0 rot	| x y x1 y1 ea ec dx
		( 1? )( 1- >r		| x y x1 y1 ea ec
			2dup +		| x y x1 y1 ea ec ea+ec
			swap <=? ( rot 1+ rot rot )
			>r rot 1+ rot rot >r
			| falta alpha
			2over setxy ink@ px!+
|			2over 1+ setxy ink@ px!+
			r> )
		)(
		swap 16 << over / 0 rot | x y x1 y1 ea ec dx
		( 1? )( 1- >r
			2dup +
			swap <=? ( >r rot 1+ rot rot r> )
        	rot 1+ rot rot
			| falta alpha
			2over setxy ink@ px!+
|			ink@ px!+
			r> )
		)
 	nip 4drop ;

:li11 | x y dx dy -- x y ; -dx -dy
	neg swap neg swap xa ya cont00 ;

:li01 | x y dx dy -- x y ... -dx +dy
	2over
:cont01 | x y dx dy x1 y1 ....
	2dup setxy ink@ px!+
	2swap swap neg swap
	over <? ( | x y x1 y1 dx dy ...dy<dx
		16 << over / 0 rot	| x y x1 y1 ea ec dx
		( 1? )( 1- >r		| x y x1 y1 ea ec
			2dup +		| x y x1 y1 ea ec ea+ec
			swap <=? ( rot 1+ rot rot )
			>r rot 1- rot rot >r
			| falta alpha
			2over setxy ink@ px!+
|			2over 1+ setxy ink@ px!+
			r> )
		)(
		swap 16 << over / 0 rot | x y x1 y1 ea ec dx
		( 1? )( 1- >r
			2dup +
			swap <=? ( >r rot 1- rot rot r> )
        	rot 1+ rot rot
			| falta alpha
			2over setxy ink@ px!+
|			ink@ px!+
			r> )
		)
 	nip 4drop ;

:li10 | x y dx dy -- x y ; +dx -dy
	neg swap neg swap xa ya cont01 ;

#acclin li00 li01 li10 li11

:nlinean | x y --
	over xa - 0? ( drop nvline ; )
	over ya - 0? ( drop nhline ; )
	| x y dx dy
	over 29 >> $4 and
	over 28 >> $8 and or 'acclin + @ exec
	'ya ! 'xa !

|void gr_line(int x1,int y1,int x2,int y2)
|{
|if (!gr_clipline(&x1,&y1,&x2,&y2)) return;
|int dx,dy,sx,d;
|if (x1==x2) { if (y1>y2) swap(y1,y2); gr_vline(x1,y1,y2);return; }
|if (y1==y2) { if (x1>x2) swap(x1,x2); gr_hline(x1,y1,x2);return; }
|if (y1>y2) { swap(x1,x2);swap(y1,y2); }
|dx=x2-x1;dy=y2-y1;
|if (dx>0) sx=1; else { sx=-1;dx=-dx; }
|WORD ea,ec=0;BYTE ci;
|register DWORD *gr_pos;
|GR_SET(x1,y1);gr_pixel(gr_pos);
|if (dy>dx) 	{
|	ea=(dx<<16)/dy;
|    while (dy>0) {
|        dy--;d=ec;ec+=ea;if (ec<=d) x1+=sx;
|        y1++;ci=ec>>8;
|		GR_SET(x1,y1);gr_pixela(gr_pos,255-ci);GR_X(sx);gr_pixela(gr_pos,ci);
|		}
|} else {// DY < DX
|    ea=(dy<<16)/dx;
|    while (dx>0) {
|        dx--;d=ec;ec+=ea;if (ec<=d) y1++;
|        x1+=sx;ci=ec>>8;
|		GR_SET(x1,y1);gr_pixela(gr_pos,255-ci);
|        GR_Y(1);gr_pixela(gr_pos,ci);
|		}
|	}
|}


:prueba1
	iniseg
	sw 2/ sh 2/ 2dup
	nop
	xymouse nline
	sw 2 >> sh 2 >> nline
    xymouse swap nline
	2dup nline
|	'segs memmap
	npoli
	rojo
	sw 2/ sh 2/ 2dup op
	xymouse line
	sw 2 >> sh 2 >> line
    xymouse swap line
	line


	azul
	sw 2/ 1+ sh 2/ op
	xymouse 1+ line
	sw 2 >> 1+ sh 2 >> line
;

:main
	inigui
	'exit >esc<
	show clrscr

		prueba1
		fonti home verde
		'segs
		( segs> <? )(
			@+ "y:%d " print @+ "x:%d " print @+ "dx:%d " print @+ "ymax:%d " print cr
			) drop
		dup "%d" print
		cflecha ;
:l
		0 20 setxy 'scanline renderscanline
		0 21 setxy 'scanline2 renderscanline

		10 10 setxy
		$ff00 'inka !
		20 fillsolid
		0 'inkb !
		50 setramp
		20 addramp
		30 fillramp

		10 11 setxy
		$ff00 'inka !
		20 fillsolid
		50 $ff00 $0 cmorph
;
: 33 main ;