| 2d Utilidades 
| PHREDA 2008
|-----------------------------------------------
|^reda4.txt

|db =(b.x*b.x + b.y*b.y)
|dp = (a.x*b.x + a.y*b.y)
|proj.x = ( dp / db ) * b.x;
|proj.y = ( dp / db ) * b.y;
|-----------------------------
::2dproj | bx by ax ay -- cx cy 
	pick2 * >r pick2 * r> + | bx by dp
	pick2 dup * pick2 dup * + | bx by dp db
	0? ( 2drop ; ) >r | bx by dp r:db
	swap over * r / | bx dp py r:db
	rot rot * r> / swap ; 

:v+ | v1 v2 -- v3
	over 16 >> over 16 >> + 16 << >r + $ffff and r> or ; 
:vdot | v1 v2 -- d
	over 16 >> over 16 >> * >r
	$ffff and swap $ffff and * r> + ;

:vqs | x y x y -- x y x y d
	pick3 pick2 - dup * pick3 pick2 - dup * + ;

:distancia | x y x y -- x^2+y^2
	rot - dup * swap rot - dup * + ;

#xt #yt

:inpolisuma | x y -- 0/1
	'yt ! 'xt ! 0
	'lineas lineas> over  =? (  3drop 0 ; )
	4 - @ d>xy rot  
	( lineas> <? )( | x1 y1 adr
		>r r@+ d>xy | x1 y1 x2 y2
		2swap "%d,%d " print 
		r> ) drop
	"%d,%d " print  ;

|---------- punto en poligono
#inside

:entre | x1 y1 x2 y2 -- x1 y1
	pick3 xt pick3 | x1 y1 x2 y2 x1 xt x2
	<=? ( >=? ( 3drop ; ) )( <? ( 3drop ; ) ) | x1 y1 x2 y2 x1 
	pick2 <? ( pick3 2swap )( pick3 ) | x1 y1 x1 y1 x2 y2
	swap pick3 - | x1 y1 'x1 'y1 'y2 a'
	yt pick3 - *  >r | x1 y1 'x1 'y1 'y2	 r: a | a= x2 x1 - yt y1 - *
	rot xt swap - | x1 y1 'y1 'y2 b'
	swap rot - * r> | x1 y1 b a | b = xt x1 - y2 y1 - *
	>?  ( inside 1 xor 'inside ! ) 
	drop ;

:adentro? | x y -- 0/1
	'yt ! 'xt ! 0 'inside !
	'lineas lineas> |over  =? (  2drop 0 ; )
	4 - @ d>xy | 2dup op 
	rot  
	( lineas> <? )( | x1 y1 adr
		>r r@+ d>xy 2swap | x1 y1 x2 y2
		entre	|	2over op 2dup line
		r> ) 3drop inside ;

|--------------------- version2
:entred | p1 p2 -- p1
	over d>x xt pick2 d>x 
	<=? ( >=? ( 2drop ; ) )( <? ( 2drop ; ) ) | v1 v2  x1 
	over d>x <? ( pick2 d>y rot d>xy 2swap )( pick2 d>y rot d>xy )
	swap pick3 - yt pick3 - *  >r | p1 'x1 'y1 'y2	 r: a | a= x2 x1 - yt y1 - *
	rot xt swap - swap rot - * r> | p1 b a | b = xt x1 - y2 y1 - *
	>?  ( inside 1 xor 'inside ! ) 
	drop ;

:adentrod? | x y adr -- 1/0
	>r 'yt ! 'xt ! 0 'inside !
	r@+ 0? ( rdrop ; ) dup
	( r@+ 1? )( swap entred ) drop
	entred drop rdrop inside ;
