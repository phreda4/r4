| R4i86.txt - PHREDA 2009
| Generacion de codigo para i86-FASM
|
| .. [esp] - pila R
| .. [esi] eax - pila D
|
| ebx edi - Libres
| ecx - libre | sar sal
| edx - libre | * /
|
| ebp - VFRAME pointer
| MMX - auxiliares de almacenamiento
|
| nivel 0 -- como macros
|
|--------------------------------------------
^gui3.txt
^parse.txt
^trace.txt

#ra "eax"
#rb "ebx"
#rc "ecx"
#rd "edx"
#re "edi"
#nos "[esi]"
#cl "cl"

#vTOS ra
#vNOS nos

|||||||||||||||||||| pila virtual |||||||||||||
#vstack )( 1024 | valor
#tstack )( 1024 | tipo
#vstack> 'vstack

:vini | --
	'vstck 'vstack> ! ;
:vpush | valor tipo --
	vstack> swap over 1024 + ! !+ 'vstack> ! ;
:vpushCte | val --
	0 vpush ;
:vpushDirC | val --
	1 vpush ;
:vpushDirD | val --
	2 vpush ;

|---- nivel v - pila virtual solamente
:vDROP | -- || a --
	-4 'vstack> +! ;
:vDUP | -- || a -- a a
	vstack> 4 -
	dup 1024 + @+ swap !
	@+ swap !+ 'vstack> ! ;
:vOVER
	vstack> 8 -
	dup 1024 + @+ swap 4+ !
	@+ swap 4+ !+ 'vstack> ! ;
:vPICK2
	vstack> 12 -
	dup 1024 + @+ swap 8 + !
	@+ swap 8 + !+ 'vstack> ! ;
:vPICK3
	vstack> 16 -
	dup 1024 + @+ swap 12 + !
	@+ swap 12 + !+ 'vstack> ! ;
:vPICK4
	vstack> 20 -
	dup 1024 + @+ swap 16 + !
	@+ swap 16 + !+ 'vstack> ! ;
:vSWAP
	vstack> 8 -
	dup 1024 +
	dup @+ swap @ rot !+ !
	dup @+ swap @ rot !+ ! ;
:vROT	
	vstack> 12 -
	dup 1024 +
	dup >r @+ swap @+ swap @ rot >r !+ !+ !
    dup >r @+ swap @+ swap @ rot >r !+ !+ ! ;

:v2OVER ;
:v2SWAP ;
:v4DROP	vdrop
:v3DROP	vdrop
:v2DROP	vdrop vdrop ;
:vNIP	vswap vdrop ;
:v2DUP	vover vover ;

|||||||| Calculo
:vAND	vstack> 8 - @+ over @ and swap ! ;
:vOR    vstack> 8 - @+ over @ or swap ! ;
:vXOR   vstack> 8 - @+ over @ xor swap ! ;
:vNOT   vstack> 4 - dup @ not swap ! ;
:v+     vstack> 8 - @+ over @ + swap ! ;
:v-     vstack> 8 - @+ over @ - swap ! ;
:v*     vstack> 8 - @+ over @ * swap ! ;
:v/     vstack> 8 - @+ over @ / swap ! ;
:vMOD   vstack> 8 - @+ over @ mod swap ! ;
:v<<    vstack> 8 - @+ over @ << swap ! ;
:v>>    vstack> 8 - @+ over @ >> swap ! ;
:v*/    vstack> 12 - @+ over @+ swap @ */ swap ! ;
:v*>>   vstack> 12 - @+ over @+ swap @ *>> swap ! ;
:v/MOD  vstack> 8 - dup @+ swap @ /mod swap rot !+ ! ;
:vABS   vstack> 4 - dup @ abs swap ! ;
:vNEG   vstack> 4 - dup @ neg swap ! ;
:v1+    vstack> 4 - dup @ 1+ swap ! ;
:v4+    vstack> 4 - dup @ 4+ swap ! ;
:v1-    vstack> 4 - dup @ 1- swap ! ;
:v2/    vstack> 4 - dup @ 2/ swap ! ;
:v2*    vstack> 4 - dup @ 2* swap ! ;

|---- nivel 0 - sin desordenar la pila
:0,DUP || a -- a a
	"lea esi,[esi-4]" ,ln
	"mov [esi],eax" ,ln ;
:0,DROP || a --
	"lodsd" ,ln ;
:0,NIP	|| a b -- b
	"lea esi,[esi+4]" ,ln ;
:0,OVER || a b -- a b a
	0,DUP
	"mov eax,[esi+4]" ,ln ;
:0,PICK2
	0,DUP
	"mov eax,[esi+4*2]" ,ln ;
:0,PICK3
	0,DUP
	"mov eax,[esi+4*3]" ,ln ;
:0,PICK4
	0,DUP
	"mov eax,[esi+4*4]" ,ln ;
:0,SWAP
	"mov edx,eax" ,ln |"xchg eax,[esi]" ,ln ;|ggrr
	"mov eax,[esi]" ,ln
	"mov [esi],edx" ,ln ;
|	"push eax" ,ln	| otra version (sin dx)
|	"mov eax,[esi]" ,ln
|	"pop [esi]" ,ln ;
:0,ROT
	"mov ecx,[esi+4]" ,ln
	"mov edx,[esi]" ,ln
	"mov [esi],eax" ,ln
	"mov [esi+4],edx" ,ln
	"mov eax,ecx" ,ln ;
|	"push [esi+4]" ,ln	| otra version (sin dx,cx)
|	"push [esi]" ,ln
|	"pop [es+4]" ,ln
|	"mov [esi],eax" ,ln
|	"pop eax" ,ln ;
:0,2DUP
	0,OVER 0,OVER ;
:0,2OVER
	"mov [esi-4],eax" ,ln
	"lea esi,[esi-8]" ,ln
	"mov edx,[esi+16]" ,ln
	"mov [esi],edx" ,ln
	"mov eax,[esi+12]" ,ln ;
:0,2SWAP
	"mov ecx,[esi+4]" ,ln
	"mov [esi+4],eax" ,ln
	"mov edx,[esi+8]" ,ln
	"mov eax,[esi]" ,ln
	"mov [esi+8],eax" ,ln
	"mov [esi],edx" ,ln
	"mov eax,ecx" ,ln ;
:0,2DROP
	0,NIP 0,DROP ;
:0,3DROP
	"lea esi,[esi+8]" ,ln
	0,DROP ;
:0,4DROP
	"lea esi,[esi+12]" ,ln
	0,DROP ;

:0,EXEC
	"mov ecx,eax" ,ln
	0,DROP
	"or ecx,ecx" ,ln
	"jz @f" ,ln
	"call ecx" ,ln
	"@@:" ,ln ;

:0,>R
	"push eax" ,ln
	0,DROP ;
:0,R>
	0,DUP
	"pop eax" ,ln ;
:0,R
	0,DUP
	"mov eax,[esp]" ,ln ;
:0,RDROP
	"lea esp,[esp+4]" ,ln ;

:0,R+
	"add [esp],eax" ,ln
	0,DROP ;
:0,R!+
	"pop edx" ,ln
	"mov [edx],eax" ,ln
	"add edx,4" ,ln
	"push edx" ,ln
	0,DROP ;
:0,R@+
	0,DUP
	"pop edx" ,ln
	"mov eax,[edx]" ,ln
	"add edx,4" ,ln
	"push edx" ,ln ;

:0,AND
	"and eax,[esi]" ,ln
	0,NIP ;
:0,OR
	"or eax,[esi]" ,ln
	0,NIP ;
:0,XOR
	"xor eax,[esi]" ,ln
	0,NIP ;
:0,NOT
	"not eax" ,ln ;

:0,+
	"add eax,[esi]" ,ln
	0,NIP ;
:0,-
	"neg eax" ,ln
	"add eax,[esi]" ,ln
	0,NIP ;
:0,*
	"cdq" ,ln
	"imul dword [esi]" ,ln
	0,NIP ;
:0,/
	"mov ecx,eax" ,ln
	0,DROP
	"cdq" ,ln
	"idiv ecx" ,ln ;
:0,*/
	"mov ecx,eax" ,ln
	0,DROP
	"cdq" ,ln
	"imul dword [esi]" ,ln
	"idiv ecx" ,ln
	0,NIP ;
:0,*>>
	"mov ecx,eax" ,ln
	0,DROP
	"cdq" ,ln
	"imul dword [esi]" ,ln
	"shrd eax,edx,cl" ,ln
	0,NIP ;
:0,/MOD
	"mov ecx,eax" ,ln
	"mov eax,[esi]" ,ln
	"cdq" ,ln
	"idiv ecx" ,ln
	"mov [esi],eax" ,ln
	"mov eax,edx" ,ln ;
:0,MOD
	"mov ecx,eax" ,ln
	0,DROP
	"cdq" ,ln
	"idiv ecx" ,ln
	"mov eax,edx" ,ln ;
:0,<<
	"mov ecx,eax" ,ln
	0,DROP
	"sal eax,cl" ,ln ;
:0,>>
	"mov ecx,eax" ,ln
	0,DROP
	"sar eax,cl" ,ln ;
:0,ABS
	"cdq" ,ln
	"add eax,edx" ,ln
	"xor eax,edx" ,ln ;
:0,NEG
	"neg eax" ,ln ;
:0,1+
	"inc eax" ,ln ;
:0,4+
	"add eax,4" ,ln ;
:0,1-
	"dec eax" ,ln ;
:0,2/
	"sar eax,1" ,ln ;
:0,2*
	"sal eax,1" ,ln ; | "add eax,eax" ,ln

:0,@
	"mov eax,dword [eax]" ,ln ;
:0,C@
	"movsx eax,byte [eax]" ,ln ;
:0,W@
	"movsx eax,word [eax]" ,ln ;
:0,!
	"mov ecx,[esi]" ,ln
	"mov [eax],ecx" ,ln
	0,2DROP ;
:0,C!
	"mov ecx,[esi]" ,ln
	"mov byte [eax],cl" ,ln
	0,2DROP ;
:0,W!
	"mov ecx,[esi]" ,ln
	"mov word [eax],cx" ,ln
	0,2DROP ;
:0,+!
	"mov ecx,[esi]" ,ln
	"add [eax],ecx" ,ln
	0,2DROP ;
:0,W+!
	"mov ecx,[esi]" ,ln
	"add word [eax],cx" ,ln
	0,2DROP ;
:0,C+!
	"mov ecx,[esi]" ,ln
	"add byte [eax],cl" ,ln
	0,2DROP ;
:0,!+
	"mov ecx,[esi]" ,ln
	"mov [eax],ecx" ,ln
	"add eax,4" ,ln
	0,NIP ;
:0,W!+
	"movsx ecx,word [esi]" ,ln
	"mov [eax],cx" ,ln
	"add eax,2" ,ln
	0,NIP ;
:0,C!+
	"movsx ecx,byte [esi]" ,ln
	"mov [eax],cl" ,ln
	"inc eax" ,ln
	0,NIP ;
:0,@+
	"mov ecx,[eax]" ,ln
	"add eax,4" ,ln
	"mov [esi-4],eax" ,ln
	"mov eax,ecx" ,ln
	"lea esi,[esi-4]" ,ln ;
:0,W@+
	"movsx ecx,word [eax]" ,ln
	"add eax,2" ,ln
	"mov [esi-4],eax" ,ln
	"mov eax,ecx" ,ln
	"lea esi,[esi-4]" ,ln ;
:0,C@+
	"movsx ecx,byte [eax]" ,ln
	"inc eax" ,ln
	"mov [esi-4],eax" ,ln
	"mov eax,ecx" ,ln
	"lea esi,[esi-4]" ,ln ;

|||||||||| Memoria
:v@		;
:vC@ 	;
:vW@ 	;
:v! 	;
:vC! 	;
:vW! 	;
:v+! 	;
:vW+! 	;
:vC+! 	;
:v!+  	;
:vW!+ 	;
:vC!+  	;
:v@+ 	;
:vW@+  	;
:vC@+  	;



|---- nivel 1 - pila virtual
:1,AND
	vTOS vNOS "and %s,%s" ,print ,cr ;
:1,OR
	vTOS vNOS "or %s,%s" ,print ,cr ;
:1,XOR
	vTOS vNOS "xor %s,%s" ,print ,cr ;
:1,NOT
	vTOS "not %s" ,print ,cr ;
:1,+
	vTOS vNOS "add %s,%s" ,print ,cr ;
:1,-
	vTOS vNOS "sub %s,%s" ,print ,cr ;

:1,*
	"cdq" ,ln
	"imul dword [esi]" ,ln
	0,NIP ;
:1,/
	"mov ecx,eax" ,ln
	0,DROP
	"cdq" ,ln
	"idiv ecx" ,ln ;
:1,*/
	"mov ecx,eax" ,ln
	0,DROP
	"cdq" ,ln
	"imul dword [esi]" ,ln
	"idiv ecx" ,ln
	0,NIP ;
:1,*>>
	"mov ecx,eax" ,ln
	0,DROP
	"cdq" ,ln
	"imul dword [esi]" ,ln
	"shrd eax,edx,cl" ,ln
	0,NIP ;
:1,/MOD
	"mov ecx,eax" ,ln
	"mov eax,[esi]" ,ln
	"cdq" ,ln
	"idiv ecx" ,ln
	"mov [esi],eax" ,ln
	"mov eax,edx" ,ln ;
:1,MOD
	"mov ecx,eax" ,ln
	0,DROP
	"cdq" ,ln
	"idiv ecx" ,ln
	"mov eax,edx" ,ln ;

:1,<<
	vTOS vNOS "sal %s,%s" ,print ,cr ; | cl o cte
:1,>>
	vTOS vNOS "sar %s,%s" ,print cr ; | cl o cte

:0,ABS
	"cdq" ,ln
	"add eax,edx" ,ln
	"xor eax,edx" ,ln ;

:1,NEG
	vTOS "neg %s" ,print ,cr ;
:0,1+
	vTOS "inc %s" ,print ,cr ;
:0,4+
	vTOS "add %s,4" ,print ,cr ;
:0,1-
	vTOS "dec %s" ,print ,cr ;
:0,2/
	vTOS "sar %s,1" ,print ,cr ;
:0,2*
	vTOS "sal %s,1" ,print ,cr ;


|-------------------------------------data
#d1 "dd "
#d2 "dw "
#d3	"db "
#d4 "rb "
#dtipo 'd1
#dini 0

:,d; ;
:,d( dtipo >pilac 'd3 'dtipo ! ;
:,d)( 'd4 'dtipo ! ;
:,d) <pilac 'dtipo ! ;
:,d[ dtipo >pilac 'd2 'dtipo ! ;
:,d] <pilac 'dtipo ! ;

#dmacros ',d; ',d( ',d) ',d)( ',d[ ',d]

#pilac )( 256	#pilac> 'pilac

:>pilac pilac> ! 4 'pilac> +! ;
:<pilac -4 'pilac> +! pilac> @ ;

#etiqueta 0	| etiquetas
#cadena 0	| cadenas

:+etiqueta	| -- nueva   // y agrega a pila
	etiqueta 1+ dup 'etiqueta ! dup >pilac ;

|------ optimizador
:label	"_" ,s ,h 	;
:jmp,	"jmp " ,s label ,cr ;
:dup,	"lea esi,[esi-4]" ,ln "mov [esi],eax" ,ln ;
:drop,	"lodsd" ,ln ;
:nip,	"lea esi,[esi+4]" ,ln ;

#optipo  0 | 0,nro,var,dir,cad,call
#optnro

| nro --
:*nro	dup,
		0? ( drop "xor eax,eax" ,ln ; )
		1 =? ( drop "xor eax,eax" ,ln "inc eax" ,ln ; )
		-1 =? ( drop "xor eax,eax" ,ln "dec eax" ,ln ; )
		"mov eax,$" ,s ,h ,cr  ;
:*var	dup, "mov eax,[w" ,s ,n "]" ,ln ;
:*dir	dup, "mov eax,w" ,s ,n ,cr ;
:*cad	dup, "mov eax,s" ,s ,n ,cr ;
:*call	"call w" ,s ,n ,cr ;
#jopt  0 *nro *var *dir *cad *call
:optfin optipo 1? ( 2 << 'jopt + @ optnro swap exec 0 'optipo ! dup ) drop ;

:optset | nro clase --
	optfin 'optipo ! 'optnro ! ;

:*jump  "jmp w" ,s optnro ,n ,cr 0 'optipo ! ;

| nro --
:**nro 	"$" ,s ,h  ;
:**var	"dword [w" ,s ,n "]" ,s ;
:**dir	"w" ,s ,n ;
:**cad 	"s" ,s ,n ;
:**error drop ;
#wopt **error **nro **var **dir **cad **error
:**write	optipo 2 << 'wopt + @ optnro swap exec	0 'optipo ! ,cr ;
:**write1	optipo 2 << 'wopt + @ optnro swap exec	0 'optipo ! ;

:optcall | --
	optipo 5 =? ( optfin drop 0 ) ;

|---------------------------------------------------
:,;
	optipo 5 =? ( *jump )( optfin "ret" ,ln ) drop ;
:,(
	optfin +etiqueta salto 1? ( swap label ,cr 1 )( swap label ":" ,ln 2 ) >pilac drop ;
:,)(
	optfin <pilac salto 0? ( drop
			1 =? ( <pilac +etiqueta jmp, label ":" ,ln 1 >pilac drop ; )
			)( drop
			2 =? ( <pilac +etiqueta label ,cr >pilac 3 >pilac drop ; ) ) drop
	"**)( error **" 'msgserr ! ; | 1 'error !
:,)
	optfin
	<pilac salto 0? ( drop
			1 =? ( <pilac label ":" ,ln drop ; )
			2 =? ( <pilac jmp, drop ; )
			3 =? ( <pilac jmp, <pilac label ":" ,ln drop ; )
		)( drop
			2 =? ( <pilac label ,cr drop ; ) ) drop
	"**) error **"  'msgserr ! ;
:,[
	optfin dup, +etiqueta +etiqueta "mov eax," ,s label ,cr jmp, <pilac label ":" ,ln ;
:,]
	optfin <pilac label ":" ,ln ;

:,0?	"or eax,eax" ,ln "jnz " ,s ;
:,+?	"or eax,eax" ,ln "js " ,s ;
:,-?	"or eax,eax" ,ln "jns " ,s ;
:,1?	"or eax,eax" ,ln "jz " ,s ;
:,=?
		0? ( "mov ecx,eax" ,ln drop, "cmp eax,ecx" ,ln "jnz " ,s )(
			"cmp eax," ,s **write "jnz " ,s ) drop ;
:,<?
		0? ( "mov ecx,eax" ,ln drop, "cmp eax,ecx" ,ln "jge " ,s )(
			"cmp eax," ,s **write "jge " ,s ) drop ;
:,>?
		0? ( "mov ecx,eax" ,ln drop, "cmp eax,ecx" ,ln "jle " ,s )(
			"cmp eax," ,s **write "jle " ,s ) drop ;
:,<=?
		0? ( "mov ecx,eax" ,ln drop, "cmp eax,ecx" ,ln "jg " ,s )(
			"cmp eax," ,s **write "jg " ,s ) drop ;
:,>=?
		0? ( "mov ecx,eax" ,ln drop, "cmp eax,ecx" ,ln "jl " ,s )(
			"cmp eax," ,s **write "jl " ,s ) drop ;
:,<>?
		0? ( "mov ecx,eax" ,ln drop, "cmp eax,ecx" ,ln "jz " ,s )(
			"cmp eax," ,s **write "jz " ,s ) drop ;
:,and?
		0? ( "mov ecx,eax" ,ln drop, "test eax,ecx" ,ln "jz " ,s )(
			"test eax," ,s **write "jz " ,s ) drop ;
:,nand?
		0? ( "mov ecx,eax" ,ln drop, "test eax,ecx" ,ln "jnz " ,s )(
			"test eax," ,s **write "jnz " ,s ) drop ;

|-----------
|:,MOVE	;
|:,MOVE>	;
|:,CMOVE	;
|:,CMOVE>	;
|------------------
:,DIR		"call SYSDIR" ,ln ;
:,FILE      "call SYSFILE" ,ln ;
:,FSIZE     "call SYSFSIZE" ,ln ;
:,VOL       "call SYSVOL" ,ln ;
:,LOAD      "call SYSLOAD" ,ln ;
:,SAVE      "call SYSSAVE" ,ln ;
:,UPDATE    "call SYSUPDATE" ,ln ;
:,MSEC      "call SYSMSEC" ,ln ;
:,TIME      "call SYSTIME" ,ln ;
:,DATE      "call SYSDATE" ,ln ;
:,END       "jmp SYSEND" ,ln ;
:,RUN       "call SYSRUN" ,ln ;
:,SW
	0,dup
	"mov eax,[SYSW]" ,ln ;
:,SH
	0,dup
	"mov eax,[SYSH]" ,ln ;
:,MEM
	0,dup
	"mov eax,FREE_MEM" ,ln ;

|------------
|:,CLS ;
|------------
:,REDRAW	"call SYSREDRAW" ,ln ;

:,FRAMEV
	0,DUP
	"mov eax,SYSFRAME" ,ln ;

:,SETXY | x y --
	"cdq" ,ln
	"imul dword [SYSW]" ,ln
	"add eax,[esi]" ,ln
	"lea ebp,[SYSFRAME+eax*4]" ,ln
	0,2DROP ;

:,SETXYnoanda | x y --
	"mov ebx,[ROWFRAME+eax*4]" ,ln
	"mov eax,[esi]" ,ln
	"lea ebp,[SYSFRAME+ebx+eax*4]" ,ln
	"sub esi,8" ,ln
	"mov eax,[esi+4]" ,ln
	;

:,PX+!	| s --
	"lea ebp,[ebp+eax*4]" ,ln
	0,DROP ;
:,PX!+	| rgb --
	"mov [ebp],eax" ,ln
	"add ebp,4" ,ln
	0,DROP ;
:,PX@	| -- rgb
	0,DUP
	"mov eax,[ebp]" ,ln ;

:,iPEN! | v --
	"mov [SYSiPEN],eax" ,ln
	0,DROP ;

:,XYMOUSE | -- x y
	0,DUP
	"lea esi,[esi-4]" ,ln
	"mov eax,[SYSXYM]" ,ln
	"mov ecx,eax" ,ln
	"and ecx,$ffff" ,ln
	"shr eax,16" ,ln
	"mov [esi],ecx" ,ln ;

:,BMOUSE | -- c
	0,DUP
	"mov eax,[SYSBM]" ,ln ;

:,iKEY! | v --
	"mov [SYSiKEY],eax" ,ln
	0,DROP ;

:,KEY	| -- c
	0,DUP
	"mov eax,[SYSKEY]" ,ln ;

:,IJOY!
:,CNTJOY
:,GETJOY

:,SLOAD
:,SPLAY
:,MLOAD
:,MPLAY

:,INET!
:,LISTEN
:,CONECT
:,SEND
:,RECV
:,NBI
	;


|---- Agrega palabra al diccionario

:dfin	dini 1? ( dtipo )( "," ) ,s drop 0 'dini ! ;
:dfini	dini 1? ( dtipo ,s 0 ,n ) ,cr drop 0 'dini ! ;
:dfins	dini 1? ( "db " )( "," ) ,s drop 0 'dini ! ;
:dfind	dini 1? ( "dd " )( "," ) ,s drop 0 'dini ! ;


:esdefinicion | a -- a' define palabra
	dfini ghere 0 'modo ! hcode 'here ! optfin
	dup 1+ c@ 33 <? ( drop 2 + "inicio:" ,ln ; ) drop
	"w" ,s cntpal ,n ": " ,s 1 'cntpal +!
	" ;" ,s dup ( c@+ 32 >? )( ,c ) 2drop ,cr
	0 definep ;

:esvariable | a -- a' define variable
	optfin dfini
	ghere 1 'modo ! hdata 'here !
	"w" ,s cntpal ,n " " ,s 1 'cntpal +!
	1 definep
	'd1 'dtipo !
	1 'dini ! ;

|----------------------------------------------------------------
:copydat | a -- a'
	34 ,c 1+
	( c@+ 1? )( 34 =? ( drop c@+ 34 <>? ( drop 34 ,c ",0" ,s ; ) """,34," ,s ) ,c )
	34 ,c drop ",0" ,s  1- ;

:escadena | a -- a' graba cadena  "....."",..."
	modo 0? ( drop
		here 'hcode ! hdata 'here !
		"s" ,s cadena ,n " db " ,s copydat ,cr
		here 'hdata ! hcode 'here !
		cadena 4 optset |******optipo  0 | 0,nro,var,dir,cad,call
		1 'cadena +!
	)( drop dfins copydat ) ;

:esnumero | adr nro -- adr
	0 'salto !
	modo 0? ( drop
		1 optset |******optipo  0 | 0,nro,var,dir,cad,call
	)( drop	dfin ,n ) ;

:espalabra | adr nro -- adr
	0 'salto !
	modo 0? ( drop
		wtipo 1 and 0? ( drop
			5 optset |******optipo  0 | 0,nro,var,dir,cad,call
		)( drop
			2 optset |******optipo  0 | 0,nro,var,dir,cad,call
			)
	)( drop dfind "w" ,s ,n  ) ;

:esdir	| adr nro -- adr
	0 'salto !
	modo 0? ( drop
		3 optset |******optipo  0 | 0,nro,var,dir,cad,call
	)( drop dfind "w" ,s ,n ) ;

:esmacro | adr nro -- adr
	dup modo 0? ( 'fmacros )( 'dmacros ) nip swap 2 << + @ exec
	6 >? ( 19 <? ( 1 )( 0 ) )( 0 ) nip 'salto ! ;

